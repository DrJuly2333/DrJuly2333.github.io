<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JAVA工作总结和面试</title>
    <url>/2024/07/24/Java%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>[TOC] </p>
<blockquote>
<p>本文内容参考：<a href="https://github.com/whx123/JavaHome">https://github.com/whx123/JavaHome</a></p>
</blockquote>
<h2 id="if-else代码优化"><a href="#if-else代码优化" class="headerlink" title="if-else代码优化"></a>if-else代码优化</h2><h3 id="优化方案一：提前return，去除不必要的else"><a href="#优化方案一：提前return，去除不必要的else" class="headerlink" title="优化方案一：提前return，去除不必要的else"></a>优化方案一：提前return，去除不必要的else</h3><p><strong>优化前：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="comment">//doSomething</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优化后：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>（!condition）&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//doSomething</span></span><br></pre></td></tr></table></figure>

<h3 id="优化方案二：使用条件三目运算符"><a href="#优化方案二：使用条件三目运算符" class="headerlink" title="优化方案二：使用条件三目运算符"></a>优化方案二：使用条件三目运算符</h3><p><strong>优化前：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> price;</span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    price = <span class="number">80</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    price = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优化后：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">price</span> <span class="operator">=</span> condition ? <span class="number">80</span> : <span class="number">100</span>;</span><br></pre></td></tr></table></figure>


<h3 id="优化方案三：使用枚举"><a href="#优化方案三：使用枚举" class="headerlink" title="优化方案三：使用枚举"></a>优化方案三：使用枚举</h3><p><strong>优化前：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String OrderStatusDes;</span><br><span class="line"><span class="keyword">if</span> (orderStatus == <span class="number">0</span>) &#123;</span><br><span class="line">    OrderStatusDes = <span class="string">&quot;订单未支付&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (OrderStatus == <span class="number">1</span>) &#123;</span><br><span class="line">    OrderStatusDes = <span class="string">&quot;订单已支付&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (OrderStatus == <span class="number">2</span>) &#123;</span><br><span class="line">    OrderStatusDes = <span class="string">&quot;已发货&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><strong>优化后：</strong></p>
<p>定义一个枚举</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">OrderStatusEnum</span> &#123;</span><br><span class="line">    UN_PAID(<span class="number">0</span>, <span class="string">&quot;订单未支付&quot;</span>),</span><br><span class="line">    PAIDED(<span class="number">1</span>, <span class="string">&quot;订单已支付&quot;</span>),</span><br><span class="line">    SENDED(<span class="number">2</span>, <span class="string">&quot;已发货&quot;</span>),</span><br><span class="line">    ;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> index;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OrderStatusEnum(<span class="type">int</span> index, String desc)&#123;</span><br><span class="line">        <span class="built_in">this</span>.index = index;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OrderStatusEnum <span class="title function_">of</span><span class="params">(<span class="type">int</span> orderStatus)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (OrderStatusEnum temp : OrderStatusEnum.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.getIndex() == orderStatus) &#123;</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用枚举</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">OrderStatusDes</span> <span class="operator">=</span> OrderStatusEnum.of(orderStatus).getDesc();</span><br></pre></td></tr></table></figure>
<h3 id="优化方案四：合并条件表达式"><a href="#优化方案四：合并条件表达式" class="headerlink" title="优化方案四：合并条件表达式"></a>优化方案四：合并条件表达式</h3><p><strong>优化前</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">getVipDiscount</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (age &lt; <span class="number">18</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;深圳&quot;</span>.equals(city)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isStudent) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//do somethig</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优化后</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">getVipDiscount</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (age &lt; <span class="number">18</span> || <span class="string">&quot;深圳&quot;</span>.equals(city) || isStudent) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//doSomthing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优化方案五：使用-Optional"><a href="#优化方案五：使用-Optional" class="headerlink" title="优化方案五：使用 Optional"></a>优化方案五：使用 Optional</h3><p>如果if-else比较多是因为<strong>非空判断</strong>导致的，可以使用java8的Optional进行优化。</p>
<p><strong>优化前：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;testOptional&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (str != <span class="literal">null</span>) &#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Null&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优化后：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;String&gt; strOptional = Optional.of(<span class="string">&quot;testOptional&quot;</span>);</span><br><span class="line">strOptional.ifPresentOrElse(System.out::println, () -&gt; System.out.println(<span class="string">&quot;Null&quot;</span>));</span><br></pre></td></tr></table></figure>


<h3 id="优化方案六：表驱动法"><a href="#优化方案六：表驱动法" class="headerlink" title="优化方案六：表驱动法"></a>优化方案六：表驱动法</h3><p>表驱动法是一种在表(map)中查找信息，省去不必要的逻辑语句。</p>
<p><strong>优化前：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (param.equals(value1)) &#123;</span><br><span class="line">    doAction1(someParams);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (param.equals(value2)) &#123;</span><br><span class="line">    doAction2(someParams);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (param.equals(value3)) &#123;</span><br><span class="line">    doAction3(someParams);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p><strong>优化后：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 泛型 ? 方便演示，可替换为你需要的类型</span></span><br><span class="line">Map&lt;?, Function&lt;?&gt; action&gt; actionMappings = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">actionMappings.put(value1, (someParams) -&gt; &#123; doAction1(someParams)&#125;);</span><br><span class="line">actionMappings.put(value2, (someParams) -&gt; &#123; doAction2(someParams)&#125;);</span><br><span class="line">actionMappings.put(value3, (someParams) -&gt; &#123; doAction3(someParams)&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略多余逻辑语句</span></span><br><span class="line">actionMappings.get(param).apply(someParams);</span><br></pre></td></tr></table></figure>

<h3 id="优化方案七：优化逻辑结构，让正常流程走主干"><a href="#优化方案七：优化逻辑结构，让正常流程走主干" class="headerlink" title="优化方案七：优化逻辑结构，让正常流程走主干"></a>优化方案七：优化逻辑结构，让正常流程走主干</h3><p><strong>优化前：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getAdjustedCapital</span><span class="params">(<span class="type">double</span> capital, <span class="type">double</span> income, <span class="type">int</span> intRate, <span class="type">int</span> duration)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (capital &lt;= <span class="number">0.0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (intRate &gt; <span class="number">0</span> &amp;&amp; duration &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (income / duration) * ADJ_FACTOR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优化后：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getAdjustedCapital</span><span class="params">(<span class="type">double</span> capital, <span class="type">double</span> income, <span class="type">int</span> intRate, <span class="type">int</span> duration)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (capital &lt;= <span class="number">0.0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将条件反转使异常情况先退出</span></span><br><span class="line">    <span class="keyword">if</span> (intRate &lt;= <span class="number">0</span> || duration &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 让正常流程维持在主干流程，可以让代码结构更加清晰</span></span><br><span class="line">    <span class="keyword">return</span> (income / duration) * ADJ_FACTOR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优化方案八：策略模式-工厂方法消除if-else"><a href="#优化方案八：策略模式-工厂方法消除if-else" class="headerlink" title="优化方案八：策略模式+工厂方法消除if else"></a>优化方案八：策略模式+工厂方法消除if else</h3><p>假设需求为：根据不同勋章类型，处理相对应的勋章服务</p>
<p><strong>优化前：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">medalType</span> <span class="operator">=</span> <span class="string">&quot;guest&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;guest&quot;</span>.equals(medalType)) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;嘉宾勋章&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;vip&quot;</span>.equals(medalType)) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;会员勋章&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;guard&quot;</span>.equals(medalType)) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;展示守护勋章&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>优化后：</strong></p>
<ol>
<li>把每个条件逻辑代码块，抽象成一个公共的接口：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 勋章接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IMedalService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showMedal</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>根据每个逻辑条件，定义相对应的策略实现类：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 守护勋章策略实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuardMedalServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IMedalService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showMedal</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;展示守护勋章&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 嘉宾勋章策略实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuestMedalServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IMedalService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showMedal</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;嘉宾勋章&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// VIP勋章策略实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VipMedalServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IMedalService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showMedal</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;会员勋章&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>定义策略工厂类，用来管理这些勋章实现策略类：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//勋章服务工产类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MedalServicesFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, IMedalService&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        map.put(<span class="string">&quot;guard&quot;</span>, <span class="keyword">new</span> <span class="title class_">GuardMedalServiceImpl</span>());</span><br><span class="line">        map.put(<span class="string">&quot;vip&quot;</span>, <span class="keyword">new</span> <span class="title class_">VipMedalServiceImpl</span>());</span><br><span class="line">        map.put(<span class="string">&quot;guest&quot;</span>, <span class="keyword">new</span> <span class="title class_">GuestMedalServiceImpl</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IMedalService <span class="title function_">getMedalService</span><span class="params">(String medalType)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(medalType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>使用了策略+工厂模式之后，代码变得简洁多了：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">medalType</span> <span class="operator">=</span> <span class="string">&quot;guest&quot;</span>;</span><br><span class="line">        <span class="type">IMedalService</span> <span class="variable">medalService</span> <span class="operator">=</span> MedalServicesFactory.getMedalService(medalType);</span><br><span class="line">        medalService.showMedal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java异常处理的十个建议"><a href="#Java异常处理的十个建议" class="headerlink" title="Java异常处理的十个建议"></a>Java异常处理的十个建议</h2><h3 id="一、使用log打印，尽量不要使用e-printStackTrace"><a href="#一、使用log打印，尽量不要使用e-printStackTrace" class="headerlink" title="一、使用log打印，尽量不要使用e.printStackTrace()"></a>一、使用log打印，尽量不要使用e.printStackTrace()</h3><p><strong>反例:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>正例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.info(<span class="string">&quot;运行出错,&#123;&#125;&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>理由：</strong></p>
<ul>
<li>printStackTrace()打印出的堆栈日志跟业务代码日志是混合在一起的，通常排查异常日志不太方便</li>
<li>e.printStackTrace()语句产生的字符串记录的是堆栈信息，如果信息太多，字符串常量池没有空间，导致用户请求卡住</li>
</ul>
<h3 id="二、catch了异常，但是没有打印出具体的exception，无法更好定位问题"><a href="#二、catch了异常，但是没有打印出具体的exception，无法更好定位问题" class="headerlink" title="二、catch了异常，但是没有打印出具体的exception，无法更好定位问题"></a>二、catch了异常，但是没有打印出具体的exception，无法更好定位问题</h3><p><strong>反例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.info(<span class="string">&quot;运行出错&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>正例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.info(<span class="string">&quot;运行出错，&#123;&#125;&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>理由：</strong></p>
<ul>
<li>没有把exception打印出来，排查问题困难，不知道是SQl异常、IO异常还是其他异常</li>
</ul>
<h3 id="三、不要用一个Exception捕捉所有可能的异常"><a href="#三、不要用一个Exception捕捉所有可能的异常" class="headerlink" title="三、不要用一个Exception捕捉所有可能的异常"></a>三、不要用一个Exception捕捉所有可能的异常</h3><p><strong>反例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 抛出 IOException 的代码调用</span></span><br><span class="line">        <span class="comment">// 抛出 SQLException 的代码调用</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">//用基类 Exception 捕捉的所有可能的异常，如果多个层次都这样捕捉，会丢失原始异常的有效信息哦</span></span><br><span class="line">        log.info(<span class="string">&quot;运行出错:&#123;&#125;&quot;</span>,e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>正例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 抛出 IOException 的代码调用</span></span><br><span class="line">        <span class="comment">// 抛出 SQLException 的代码调用</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">//仅仅捕捉 IOException</span></span><br><span class="line">        log.info(<span class="string">&quot;IOException in test,exception:&#123;&#125;&quot;</span>, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        <span class="comment">//仅仅捕捉 SQLException</span></span><br><span class="line">        log.info(<span class="string">&quot;SQLException in test,exception:&#123;&#125;&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>理由：</p>
<ul>
<li>捕获和处理异常时，尽可能保留原始异常作为新的异常的原因</li>
<li>在每个层次记录详细的异常信息和堆栈跟踪</li>
<li>避免在捕获异常时过于宽泛，尽量捕获具体的异常类型，以便更精确地处理</li>
</ul>
<h3 id="四、使用finally或直接try-with-resource关闭流资源"><a href="#四、使用finally或直接try-with-resource关闭流资源" class="headerlink" title="四、使用finally或直接try-with-resource关闭流资源"></a>四、使用finally或直接try-with-resource关闭流资源</h3><p><strong>反例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fdIn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    fdIn = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/jay.txt&quot;</span>));</span><br><span class="line">    <span class="comment">// 在这里关闭流资源？有没有问题呢？如果发生异常了呢？</span></span><br><span class="line">    fdIn.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>正例1：</strong>使用finally关闭流资源：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fdIn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    fdIn = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/jay.txt&quot;</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fdIn != <span class="literal">null</span>) &#123;</span><br><span class="line">            fdIn.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>正例2：</strong>使用JDK7的新特性try-with-resource来处理，它用于自动资源管理</p>
<ul>
<li>资源是指在程序用完了之后必须要关闭的对象</li>
<li>try-with-resources保证了每个声明了的资源在语句结束的时候会被关闭</li>
<li>什么样的对象才能当做资源使用呢？只要实现了java.lang.AutoCloseable接口或者java.io.Closeable接口的对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;jay.txt&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// use resources   </span></span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>理由：</strong></p>
<ul>
<li>如果不使用finally或者try-with-resource，当程序发生异常，IO资源流没关闭，那么这个IO资源就会一直占着，别人没法使用，造成资源浪费</li>
</ul>
<h3 id="五、捕获异常与抛出异常必须是完全匹配，或者捕获异常是抛异常的父类"><a href="#五、捕获异常与抛出异常必须是完全匹配，或者捕获异常是抛异常的父类" class="headerlink" title="五、捕获异常与抛出异常必须是完全匹配，或者捕获异常是抛异常的父类"></a>五、捕获异常与抛出异常必须是完全匹配，或者捕获异常是抛异常的父类</h3><p><strong>反例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BizException 是 Exception 的子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BizException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 抛出父类Exception</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    test(); <span class="comment">// 编译错误</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (BizException e) &#123; <span class="comment">// 捕获异常子类是没法匹配的</span></span><br><span class="line">    log.error(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>正例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抛出子类Exception</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> BizException &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    test();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="六、注意异常对代码层次结构的侵染（早发现早处理）"><a href="#六、注意异常对代码层次结构的侵染（早发现早处理）" class="headerlink" title="六、注意异常对代码层次结构的侵染（早发现早处理）"></a>六、注意异常对代码层次结构的侵染（早发现早处理）</h3><p><strong>反例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> UserInfo <span class="title function_">queryUserInfoByUserId</span><span class="params">(Long userid)</span> <span class="keyword">throw</span> SQLException &#123;</span><br><span class="line">    <span class="comment">// 根据用户Id查询数据库</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>正例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> UserInfo <span class="title function_">queryUserInfoByUserId</span><span class="params">(Long userid)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 根据用户Id查询数据库</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;查询数据库异常，&#123;&#125;&quot;</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//关闭连接，清理资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>理由：</strong></p>
<ul>
<li>我们的项目，一般都会把代码分 Action、Service、Dao 等不同的层次结构，如果你是DAO层处理的异常，尽早处理，如果往上 throw SQLException，上层代码还是要try catch处理，这就污染了你的代码</li>
</ul>
<h3 id="七、自定义封装异常，不要丢弃原始异常的信息Throwable-cause"><a href="#七、自定义封装异常，不要丢弃原始异常的信息Throwable-cause" class="headerlink" title="七、自定义封装异常，不要丢弃原始异常的信息Throwable cause"></a>七、自定义封装异常，不要丢弃原始异常的信息Throwable cause</h3><p>我们常常会想要在捕获一个异常后抛出另一个异常，并且希望把原始异常的信息保存下来，这被称为异常链。公司的框架提供统一异常处理就用到异常链，我们自定义封装异常，不要丢弃原始异常的信息，否则排查问题很头疼</p>
<p><strong>反例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestChainException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> <span class="keyword">throws</span> MyException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;jay.txt&quot;</span>);</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(is);</span><br><span class="line">            <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">                System.out.println(in.next());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// e 保存异常信息</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;文件在哪里呢&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invokeReadFile</span><span class="params">()</span> <span class="keyword">throws</span> MyException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            readFile();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">            <span class="comment">// e 保存异常信息</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;文件找不到&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TestChainException</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestChainException</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t.invokeReadFile();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyException 构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>正例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestChainException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> <span class="keyword">throws</span> MyException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;jay.txt&quot;</span>);</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(is);</span><br><span class="line">            <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">                System.out.println(in.next());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// e 保存异常信息</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;文件在哪里呢&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invokeReadFile</span><span class="params">()</span> <span class="keyword">throws</span> MyException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            readFile();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">            <span class="comment">// e 保存异常信息</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;文件找不到&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TestChainException</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestChainException</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t.invokeReadFile();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyException 构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String message, Throwable cause)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(message, cause);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="八、运行时异常RuntimeException-，不应该通过catch-的方式来处理，而是先预检查，比如：NullPointerException处理"><a href="#八、运行时异常RuntimeException-，不应该通过catch-的方式来处理，而是先预检查，比如：NullPointerException处理" class="headerlink" title="八、运行时异常RuntimeException ，不应该通过catch 的方式来处理，而是先预检查，比如：NullPointerException处理"></a>八、运行时异常RuntimeException ，不应该通过catch 的方式来处理，而是先预检查，比如：NullPointerException处理</h3><p><strong>反例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    obj.method();</span><br><span class="line">&#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>正例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="九、注意异常匹配的顺序，优先捕获具体的异常"><a href="#九、注意异常匹配的顺序，优先捕获具体的异常" class="headerlink" title="九、注意异常匹配的顺序，优先捕获具体的异常"></a>九、注意异常匹配的顺序，优先捕获具体的异常</h3><p>注意异常的匹配顺序，因为只有第一个匹配到异常的catch块才会被执行。</p>
<p><strong>反例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    doSomething(<span class="string">&quot;test exception&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;       </span><br><span class="line">    log.error(e);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    doSomething(<span class="string">&quot;test exception&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;       </span><br><span class="line">    log.error(e);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>理由：</strong></p>
<ul>
<li>因为NumberFormatException是IllegalArgumentException 的子类，反例中，不管是哪个异常，都会匹配到IllegalArgumentException，就不会再往下执行，因此不知道是否是NumberFormatException。所以需要优先捕获具体的异常，把NumberFormatException放前面</li>
</ul>
<h2 id="Java序列化"><a href="#Java序列化" class="headerlink" title="Java序列化"></a>Java序列化</h2><p>在日常开发中，经常看到Java对象<code>implements Serializable</code>。那么，它到底有什么用呢？</p>
<h3 id="一、什么是Java序列化"><a href="#一、什么是Java序列化" class="headerlink" title="一、什么是Java序列化"></a>一、什么是Java序列化</h3><ul>
<li><strong>序列化</strong>：把Java对象转换为字节数组的过程</li>
<li><strong>反序列化</strong>：把字节数组恢复为Java对象的过程</li>
</ul>
<h3 id="二、为什么需要序列化？"><a href="#二、为什么需要序列化？" class="headerlink" title="二、为什么需要序列化？"></a>二、为什么需要序列化？</h3><p>Java对象是运行在JVM堆内存的，JVM停止后，它的生命也就结束了。</p>
<p>如果想在JVM停止后，把这些对象保存到磁盘或者通过网络传输到另一远程机器，怎么办呢？磁盘可不认识Java对象，它只认识二进制，所以就要把这些对象转化为字节数组，这个过程就是序列化</p>
<blockquote>
<p>打个比喻，作为大城市漂泊的码农，搬家是常态。当我们搬书桌时，桌子太大了就通不过比较小的门，因此我们需要把它拆开再搬过去，这个拆桌子的过程就是序列化。 而我们把书桌复原回来（安装）的过程就是反序列化</p>
</blockquote>
<h3 id="三、序列化用途"><a href="#三、序列化用途" class="headerlink" title="三、序列化用途"></a>三、序列化用途</h3><p>序列化使得对象可以脱离程序运行而独立存在，它主要有两种用途：</p>
<ul>
<li>1） 序列化机制可以让对象保存到硬盘上，减轻内存压力的同时，也起了持久化的作用</li>
</ul>
<blockquote>
<p>比如 Web服务器中的Session对象，当有 10+万用户并发访问时，就有可能出现10万个Session对象，内存可能消化不了，于是Web容器就会把一些seesion先序列化到硬盘中，等要用了，再把保存在硬盘中的对象还原到内存中。</p>
</blockquote>
<ul>
<li>2） 序列化机制让Java对象在网络传输不再是天方夜谭<blockquote>
<p>我们在使用Dubbo远程调用服务框架时，需要把传输的Java对象实现Serializable接口，即让Java对象序列化，这样才能让对象在网络上传输。</p>
</blockquote>
</li>
</ul>
<h3 id="四、Java序列化常用API"><a href="#四、Java序列化常用API" class="headerlink" title="四、Java序列化常用API"></a>四、Java序列化常用API</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.io.ObjectOutputStream</span><br><span class="line">java.io.ObjectInputStream</span><br><span class="line">java.io.Serializable</span><br><span class="line">java.io.Externalizable</span><br></pre></td></tr></table></figure>
<h4 id="Serializable-接口"><a href="#Serializable-接口" class="headerlink" title="Serializable 接口"></a>Serializable 接口</h4><p>Serializable接口是一个<strong>标记接口</strong>，没有方法或字段。一旦实现了此接口，就标志该类的对象就是可序列化的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Serializable</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Externalizable-接口"><a href="#Externalizable-接口" class="headerlink" title="Externalizable 接口"></a>Externalizable 接口</h4><p>Externalizable继承了Serializable接口，还定义了两个抽象方法：<code>writeExternal()</code>和<code>readExternal()</code>，如果开发人员使用Externalizable来实现序列化和反序列化，需要重写writeExternal()和readExternal()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Externalizable</span> <span class="keyword">extends</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="java-io-ObjectOutputStream类"><a href="#java-io-ObjectOutputStream类" class="headerlink" title="java.io.ObjectOutputStream类"></a>java.io.ObjectOutputStream类</h4><p>ObjectOutputStream：对象输出流，它的<code>writeObject(Object obj)</code>方法可以对指定obj对象参数进行序列化，再把得到的字节序列写到一个目标输出流中</p>
<h4 id="java-io-ObjectInputStream"><a href="#java-io-ObjectInputStream" class="headerlink" title="java.io.ObjectInputStream"></a>java.io.ObjectInputStream</h4><p>ObjectInputStream：对象输入流，它的<code>readObject()</code>方法，从输入流中读取到字节序列，反序列化成为一个对象，最后将其返回</p>
<h3 id="五、序列化的使用"><a href="#五、序列化的使用" class="headerlink" title="五、序列化的使用"></a>五、序列化的使用</h3><p>序列化的使用的几个关键点：</p>
<ul>
<li>声明一个实体类，实现Serializable接口</li>
<li>使用ObjectOutputStream类的writeObject方法，实现序列化</li>
<li>使用ObjectInputStream类的readObject方法，实现反序列化</li>
</ul>
<h4 id="声明一个Student类，实现Serializable"><a href="#声明一个Student类，实现Serializable" class="headerlink" title="声明一个Student类，实现Serializable"></a>声明一个Student类，实现Serializable</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    -- getter and setter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用ObjectOutputStream类的writeObject方法，对Student对象实现序列化"><a href="#使用ObjectOutputStream类的writeObject方法，对Student对象实现序列化" class="headerlink" title="使用ObjectOutputStream类的writeObject方法，对Student对象实现序列化"></a>使用ObjectOutputStream类的writeObject方法，对Student对象实现序列化</h4><p>把Student对象设置值后，写入一个文件，即序列化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>( <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:\\text.out&quot;</span>));</span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">student.setAge(<span class="number">25</span>);</span><br><span class="line">student.setName(<span class="string">&quot;jay&quot;</span>);</span><br><span class="line">os.writeObject(student);</span><br><span class="line"></span><br><span class="line">os.flush();</span><br><span class="line">os.close();</span><br></pre></td></tr></table></figure>
<h4 id="使用ObjectInputStream类的readObject方法，实现反序列化，重新生成Student对象"><a href="#使用ObjectInputStream类的readObject方法，实现反序列化，重新生成Student对象" class="headerlink" title="使用ObjectInputStream类的readObject方法，实现反序列化，重新生成Student对象"></a>使用ObjectInputStream类的readObject方法，实现反序列化，重新生成Student对象</h4><p>再把test.out文件读取出来，反序列化为Student对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\text.out&quot;</span>));</span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) is.readObject();</span><br><span class="line">System.out.println(<span class="string">&quot;name = &quot;</span> + student.getName());</span><br></pre></td></tr></table></figure>
<h3 id="六、序列化底层"><a href="#六、序列化底层" class="headerlink" title="六、序列化底层"></a>六、序列化底层</h3><h4 id="Serializable底层"><a href="#Serializable底层" class="headerlink" title="Serializable底层"></a>Serializable底层</h4><p>Serializable接口，只是一个空接口，没有方法或字段，为什么这么神奇，实现了它就可以让对象序列化了？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Serializable</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>为了验证Serializable的作用，把以上demo的Student对象，去掉实现Serializable接口，序列化过程就抛出异常了，堆栈信息如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.io.NotSerializableException: com.example.demo.Student</span><br><span class="line">    at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:<span class="number">1184</span>)</span><br><span class="line">    at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:<span class="number">348</span>)</span><br><span class="line">    at com.example.demo.Test.main(Test.java:<span class="number">13</span>)</span><br></pre></td></tr></table></figure>
<p><strong>原来底层是这样：</strong></p>
<blockquote>
<p>ObjectOutputStream#writeObject(Object obj)中的writeObject0(obj, false);</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// remaining cases</span></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    writeString((String) obj, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">    writeArray(obj, desc, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;</span><br><span class="line">    writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">    writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotSerializableException</span>(</span><br><span class="line">            cl.getName() + <span class="string">&quot;\n&quot;</span> + debugInfoStack.toString());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotSerializableException</span>(cl.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ObjectOutputStream 在序列化的时候，会判断被序列化的Object是哪一种类型，<code>String | array | enum | Serializable</code>，如果都不是的话，抛出 NotSerializableException异常。所以<strong>Serializable真的只是一个标志，一个序列化标志</strong></p>
<h4 id="writeObject（Object）"><a href="#writeObject（Object）" class="headerlink" title="writeObject（Object）"></a>writeObject（Object）</h4><p>序列化的方法就是writeObject，基于以上的demo，我们来分析一波它的核心方法调用链吧</p>
<ul>
<li>writeObject直接调用的就是writeObject0方法，</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    ......</span><br><span class="line">    writeObject0(obj, <span class="literal">false</span>);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>writeObject0 主要实现是对象的不同类型，调用不同的方法写入序列化数据，这里面如果对象实现了Serializable接口，就调用writeOrdinaryObject()方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject0</span><span class="params">(Object obj, <span class="type">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// String类型</span></span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        writeString((String) obj, unshared);</span><br><span class="line">        <span class="comment">// 数组类型</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">        writeArray(obj, desc, unshared);</span><br><span class="line">        <span class="comment">// 枚举类型</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;</span><br><span class="line">        writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line">        <span class="comment">// Serializable实现序列化接口</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">        writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 其他情况会抛异常~</span></span><br><span class="line">        <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotSerializableException</span>(</span><br><span class="line">                cl.getName() + <span class="string">&quot;\n&quot;</span> + debugInfoStack.toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotSerializableException</span>(cl.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>

<ul>
<li>writeOrdinaryObject()会先调用writeClassDesc(desc)，写入该类的生成信息，然后调用writeSerialData方法,写入序列化数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeOrdinaryObject</span><span class="params">(Object obj,</span></span><br><span class="line"><span class="params">                                     ObjectStreamClass desc,</span></span><br><span class="line"><span class="params">                                     <span class="type">boolean</span> unshared)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException</span><br><span class="line">    &#123;</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 调用ObjectStreamClass的写入方法</span></span><br><span class="line">    writeClassDesc(desc, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 判断是否实现了Externalizable接口</span></span><br><span class="line">    <span class="keyword">if</span> (desc.isExternalizable() &amp;&amp; !desc.isProxy()) &#123;</span><br><span class="line">        writeExternalData((Externalizable) obj);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 写入序列化数据</span></span><br><span class="line">        writeSerialData(obj, desc);</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>writeSerialData()实现的就是写入被序列化对象的字段数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeSerialData</span><span class="params">(Object obj, ObjectStreamClass desc)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; slots.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (slotDesc.hasWriteObjectMethod()) &#123;</span><br><span class="line">            <span class="comment">// 如果被序列化的对象自定义实现了writeObject()方法，则执行这个代码块</span></span><br><span class="line">            slotDesc.invokeWriteObject(obj, <span class="built_in">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 调用默认的方法写入实例数据</span></span><br><span class="line">            defaultWriteFields(obj, slotDesc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>defaultWriteFields()方法，获取类的基本数据类型数据，直接写入底层字节容器；获取类的obj类型数据，循环递归调用writeObject0()方法，写入数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">defaultWriteFields</span><span class="params">(Object obj, ObjectStreamClass desc)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">// 获取类的基本数据类型数据，保存到primVals字节数组</span></span><br><span class="line">    desc.getPrimFieldValues(obj, primVals);</span><br><span class="line">    <span class="comment">// primVals的基本类型数据写到底层字节容器</span></span><br><span class="line">    bout.write(primVals, <span class="number">0</span>, primDataSize, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取对应类的所有字段对象</span></span><br><span class="line">    ObjectStreamField[] fields = desc.getFields(<span class="literal">false</span>);</span><br><span class="line">    Object[] objVals = <span class="keyword">new</span> <span class="title class_">Object</span>[desc.getNumObjFields()];</span><br><span class="line">    <span class="type">int</span> <span class="variable">numPrimFields</span> <span class="operator">=</span> fields.length - objVals.length;</span><br><span class="line">    <span class="comment">// 获取类的obj类型数据，保存到objVals字节数组</span></span><br><span class="line">    desc.getObjFieldValues(obj, objVals);</span><br><span class="line">    <span class="comment">// 对所有Object类型的字段,循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; objVals.length; i++) &#123;</span><br><span class="line">        ......</span><br><span class="line">            <span class="comment">// 递归调用writeObject0()方法，写入对应的数据</span></span><br><span class="line">            writeObject0(objVals[i],</span><br><span class="line">                         fields[numPrimFields + i].isUnshared());</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="七、日常开发序列化的一些注意点"><a href="#七、日常开发序列化的一些注意点" class="headerlink" title="七、日常开发序列化的一些注意点"></a>七、日常开发序列化的一些注意点</h3><ul>
<li><strong><code>static</code><strong>静态变量和</strong><code>transient</code></strong> 修饰的字段不会被序列化</li>
<li><code>serialVersionUID</code>问题</li>
<li>如果某个序列化类的成员变量是对象类型，则该对象类型的类必须实现序列化</li>
<li>子类实现了序列化，父类没有实现序列化，父类中的字段丢失问题</li>
</ul>
<h4 id="static静态变量和transient-修饰的字段不会被序列化"><a href="#static静态变量和transient-修饰的字段不会被序列化" class="headerlink" title="static静态变量和transient 修饰的字段不会被序列化"></a>static静态变量和transient 修饰的字段不会被序列化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">gender</span> <span class="operator">=</span> <span class="string">&quot;男&quot;</span>;</span><br><span class="line">    <span class="comment">// transient修饰</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">String</span> <span class="variable">specialty</span> <span class="operator">=</span> <span class="string">&quot;计算机专业&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSpecialty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> specialty;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSpecialty</span><span class="params">(String specialty)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.specialty = specialty;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> + <span class="string">&quot;age=&quot;</span> + age + <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&quot;, gender=&#x27;&quot;</span> + gender + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&quot;, specialty=&#x27;&quot;</span> + specialty + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>
<p>打印学生对象，序列化到文件，接着修改静态变量的值，再反序列化，输出反序列化后的对象，运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">序列化前：Student&#123;age=<span class="number">25</span>, name=<span class="string">&#x27;jay&#x27;</span>, gender=<span class="string">&#x27;男&#x27;</span>, specialty=<span class="string">&#x27;计算机专业&#x27;</span>&#125;</span><br><span class="line">序列化后：Student&#123;age=<span class="number">25</span>, name=<span class="string">&#x27;jay&#x27;</span>, gender=<span class="string">&#x27;女&#x27;</span>, specialty=<span class="string">&#x27;null&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>对比结果可以发现：</p>
<ul>
<li>1）序列化前的静态变量性别明明是‘男’，序列化后再在程序中修改，反序列化后却变成‘女’了，显然这个静态属性并没有进行序列化。其实，<strong>静态（static）成员变量是属于类级别的，而序列化是针对对象的~所以不能序列化</strong></li>
<li>2）经过序列化和反序列化过程后，specialty字段变量值由’计算机专业’变为<code>null</code>了，因为transient关键字，<strong>它可以阻止修饰的字段被序列化到文件中</strong>，在被反序列化后，transient 字段的值被设为初始值</li>
</ul>
<h4 id="serialVersionUID问题"><a href="#serialVersionUID问题" class="headerlink" title="serialVersionUID问题"></a>serialVersionUID问题</h4><p>serialVersionUID 表面意思就是<strong>序列化版本号ID</strong>，其实每一个实现Serializable接口的类，都有一个表示序列化版本标识符的静态变量，或者默认等于1L，或者等于对象的哈希码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">6384871967268653799L</span>;</span><br></pre></td></tr></table></figure>
<h5 id="serialVersionUID有什么用？"><a href="#serialVersionUID有什么用？" class="headerlink" title="serialVersionUID有什么用？"></a><strong>serialVersionUID有什么用？</strong></h5><p>JAVA序列化的机制是通过判断类的serialVersionUID来验证版本是否一致的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID和本地相应实体类的serialVersionUID进行比较，如果相同，反序列化成功，如果不相同，就抛出<code>InvalidClassException</code>异常。</p>
<ul>
<li>修改一下Student类，再反序列化操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.io.InvalidClassException: com.example.demo.Student;</span><br><span class="line">local <span class="keyword">class</span> <span class="title class_">incompatible</span>: stream <span class="type">classdesc</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">3096644667492403394</span>,</span><br><span class="line">local <span class="keyword">class</span> <span class="title class_">serialVersionUID</span> = <span class="number">4429793331949928814</span></span><br><span class="line">    at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:<span class="number">687</span>)</span><br><span class="line">    at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:<span class="number">1876</span>)</span><br><span class="line">    at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:<span class="number">1745</span>)</span><br><span class="line">    at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:<span class="number">2033</span>)</span><br><span class="line">    at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:<span class="number">1567</span>)</span><br><span class="line">    at java.io.ObjectInputStream.readObject(ObjectInputStream.java:<span class="number">427</span>)</span><br><span class="line">    at com.example.demo.Test.main(Test.java:<span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<p>从日志堆栈异常信息可以看到，文件流中的class和当前类路径中的class不同了，它们的serialVersionUID不相同，所以反序列化抛出InvalidClassException异常。那么，如果确实需要修改Student类，又想反序列化成功，怎么办呢？可以手动指定serialVersionUID的值，一般可以设置为1L或者让IDE生成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">6564022808907262054L</span>;</span><br></pre></td></tr></table></figure>
<p>实际上，阿里开发手册，强制要求序列化类新增属性时，不能修改serialVersionUID字段</p>
<h4 id="如果某个序列化类的成员变量是对象类型，则该对象类型的类必须实现序列化"><a href="#如果某个序列化类的成员变量是对象类型，则该对象类型的类必须实现序列化" class="headerlink" title="如果某个序列化类的成员变量是对象类型，则该对象类型的类必须实现序列化"></a>如果某个序列化类的成员变量是对象类型，则该对象类型的类必须实现序列化</h4><ul>
<li>给Student类添加一个Teacher类型的成员变量，其中Teacher是没有实现序列化接口的</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Teacher teacher;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Teacher 没有实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span>  &#123;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>序列化运行，报<code>NotSerializableException</code>异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.io.NotSerializableException: com.example.demo.Teacher</span><br><span class="line">    at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:<span class="number">1184</span>)</span><br><span class="line">    at java.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:<span class="number">1548</span>)</span><br><span class="line">    at java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:<span class="number">1509</span>)</span><br><span class="line">    at java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:<span class="number">1432</span>)</span><br><span class="line">    at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:<span class="number">1178</span>)</span><br><span class="line">    at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:<span class="number">348</span>)</span><br><span class="line">    at com.example.demo.Test.main(Test.java:<span class="number">16</span>)</span><br></pre></td></tr></table></figure>
<p>一个对象序列化过程，会循环获取它的Object类型字段进行递归调用来序列化的，也就是说，序列化Student类的时候，会对Teacher类进行序列化，但是对Teacher没有实现序列化接口，因此抛出<code>NotSerializableException</code>异常。所以如果某个实例化类的成员变量是对象类型，则该对象类型的类必须实现序列化</p>
<h4 id="子类实现了Serializable，父类没有实现Serializable接口的话，父类不会被序列化"><a href="#子类实现了Serializable，父类没有实现Serializable接口的话，父类不会被序列化" class="headerlink" title="子类实现了Serializable，父类没有实现Serializable接口的话，父类不会被序列化"></a>子类实现了Serializable，父类没有实现Serializable接口的话，父类不会被序列化</h4><ul>
<li>子类Student实现了Serializable接口，父类User没有实现Serializable接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类实现了Serializable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父类没有实现Serializable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    String userId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">student.setAge(<span class="number">25</span>);</span><br><span class="line">student.setName(<span class="string">&quot;jayWei&quot;</span>);</span><br><span class="line">student.setUserId(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:\\text.out&quot;</span>));</span><br><span class="line">objectOutputStream.writeObject(student);</span><br><span class="line"></span><br><span class="line">objectOutputStream.flush();</span><br><span class="line">objectOutputStream.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化结果</span></span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\text.out&quot;</span>));</span><br><span class="line"><span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> (Student) objectInputStream.readObject();</span><br><span class="line">System.out.println(student1.getUserId());	<span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p>从反序列化结果，可以发现，父类属性值丢失了。因此子类实现了Serializable接口，父类没有实现Serializable接口的话，父类不会被序列化。</p>
<h3 id="八、序列化常见面试题"><a href="#八、序列化常见面试题" class="headerlink" title="八、序列化常见面试题"></a>八、序列化常见面试题</h3><ul>
<li><p>序列化的底层是怎么实现的？</p>
</li>
<li><p>序列化时，如何让某些成员不要序列化？</p>
</li>
<li><p>在 Java 中,Serializable 和 Externalizable 有什么区别</p>
<blockquote>
<p>Externalizable继承了Serializable，给我们提供 writeExternal() 和 readExternal() 方法, 让我们可以控制 Java的序列化机制, 不依赖于Java的默认序列化。正确实现 Externalizable 接口可以显著提高应用程序的性能。</p>
</blockquote>
</li>
<li><p>serialVersionUID有什么用？</p>
</li>
<li><p>是否可以自定义序列化过程, 或者是否可以覆盖 Java 中的默认序列化过程？</p>
<blockquote>
<p>可以。我们都知道,对于序列化一个对象需调用 ObjectOutputStream.writeObject(saveThisObject), 并用 ObjectInputStream.readObject() 读取对象, 但 Java 虚拟机为你提供的还有一件事, 是定义这两个方法。如果在类中定义这两种方法, 则 JVM 将调用这两种方法, 而不是应用默认序列化机制。同时，可以声明这些方法为私有方法，以避免被继承、重写或重载。 </p>
</blockquote>
</li>
<li><p>在 Java 序列化期间,哪些变量未序列化？</p>
<blockquote>
<p>static静态变量和transient 修饰的字段是不会被序列化的。静态（static）成员变量是属于类级别的，而序列化是针对对象的。transient关键字修字段饰，可以阻止该字段被序列化到文件中</p>
</blockquote>
</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://www.cnblogs.com/xdp-gacl/p/3777987.html">Java基础学习总结——Java对象的序列化和反序列化</a></li>
<li><a href="https://segmentfault.com/a/1190000019962661">10个艰难的Java面试题与答案</a></li>
</ul>
<h2 id="Fork-join-框架"><a href="#Fork-join-框架" class="headerlink" title="Fork&#x2F;join 框架"></a>Fork&#x2F;join 框架</h2><p>Java7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。 <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/823a548cf6d64cedb1dd507c5234788f~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<ul>
<li>Fork&#x2F;join计算1-1000累加值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.pdf_test.pdftest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinPoolTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">DURATION_VALUE</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ForkJoinSubTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 子任务开始计算的值</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Integer startValue;</span><br><span class="line">        <span class="comment">// 子任务结束计算的值</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Integer endValue;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">ForkJoinSubTask</span><span class="params">(Integer startValue, Integer endValue)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.startValue = startValue;</span><br><span class="line">            <span class="built_in">this</span>.endValue = endValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 小于一定值DURATION,才开始计算</span></span><br><span class="line">            <span class="keyword">if</span> (endValue - startValue &lt; DURATION_VALUE) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;执行子任务计算：开始值 = &quot;</span> + startValue + <span class="string">&quot;;结束值 = &quot;</span> + endValue);</span><br><span class="line">                <span class="type">int</span> <span class="variable">totalValue</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="built_in">this</span>.startValue; index &lt;= <span class="built_in">this</span>.endValue; index++) &#123;</span><br><span class="line">                    totalValue += index;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> totalValue;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 将任务拆分，拆分成两个任务</span></span><br><span class="line">                <span class="comment">// 0-500</span></span><br><span class="line">                <span class="type">ForkJoinSubTask</span> <span class="variable">subTask1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinSubTask</span>(startValue, (startValue + endValue) / <span class="number">2</span>);</span><br><span class="line">                subTask1.fork();</span><br><span class="line">                <span class="comment">// 501-1000</span></span><br><span class="line">                <span class="type">ForkJoinSubTask</span> <span class="variable">subTask2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinSubTask</span>((startValue + endValue) / <span class="number">2</span> + <span class="number">1</span>, endValue);</span><br><span class="line">                subTask2.fork();</span><br><span class="line">                <span class="keyword">return</span> subTask1.join() + subTask2.join();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// Fork/Join框架的线程池</span></span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        ForkJoinTask&lt;Integer&gt; taskFuture = pool.submit(<span class="keyword">new</span> <span class="title class_">ForkJoinSubTask</span>(<span class="number">1</span>, <span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> taskFuture.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;累加结果是:&quot;</span> + result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">执行子任务计算：开始值 = <span class="number">501</span>;结束值 = <span class="number">563</span></span><br><span class="line">执行子任务计算：开始值 = <span class="number">626</span>;结束值 = <span class="number">688</span></span><br><span class="line">执行子任务计算：开始值 = <span class="number">689</span>;结束值 = <span class="number">750</span></span><br><span class="line">执行子任务计算：开始值 = <span class="number">126</span>;结束值 = <span class="number">188</span></span><br><span class="line">执行子任务计算：开始值 = <span class="number">189</span>;结束值 = <span class="number">250</span></span><br><span class="line">执行子任务计算：开始值 = <span class="number">751</span>;结束值 = <span class="number">813</span></span><br><span class="line">执行子任务计算：开始值 = <span class="number">814</span>;结束值 = <span class="number">875</span></span><br><span class="line">执行子任务计算：开始值 = <span class="number">876</span>;结束值 = <span class="number">938</span></span><br><span class="line">执行子任务计算：开始值 = <span class="number">939</span>;结束值 = <span class="number">1000</span></span><br><span class="line">执行子任务计算：开始值 = <span class="number">439</span>;结束值 = <span class="number">500</span></span><br><span class="line">执行子任务计算：开始值 = <span class="number">564</span>;结束值 = <span class="number">625</span></span><br><span class="line">执行子任务计算：开始值 = <span class="number">376</span>;结束值 = <span class="number">438</span></span><br><span class="line">执行子任务计算：开始值 = <span class="number">314</span>;结束值 = <span class="number">375</span></span><br><span class="line">执行子任务计算：开始值 = <span class="number">64</span>;结束值 = <span class="number">125</span></span><br><span class="line">执行子任务计算：开始值 = <span class="number">251</span>;结束值 = <span class="number">313</span></span><br><span class="line">执行子任务计算：开始值 = <span class="number">1</span>;结束值 = <span class="number">63</span></span><br><span class="line">累加结果是:<span class="number">500500</span></span><br></pre></td></tr></table></figure>

<p>异步执行计算：ForkJoinTask#doExec()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任务的主要执行方法。除非完成，否则调用exec()并记录状态（如果已完成），但不等待，否则完成。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 退出此方法时的状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">doExec</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> s; <span class="type">boolean</span> completed;</span><br><span class="line">        <span class="keyword">if</span> ((s = status) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 执行RecursiveTask#exec()</span></span><br><span class="line">                completed = exec();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line">                <span class="keyword">return</span> setExceptionalCompletion(rex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (completed)</span><br><span class="line">                s = setCompletion(NORMAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行RecursiveTask</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">exec</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// compute()方法在 ForkJoinSubTask进行了重写</span></span><br><span class="line">    result = compute();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Java基础流程"><a href="#Java基础流程" class="headerlink" title="Java基础流程"></a>Java基础流程</h2><h3 id="1-spring的生命周期"><a href="#1-spring的生命周期" class="headerlink" title="1.spring的生命周期"></a>1.spring的生命周期</h3><p>Spring作为当前Java最流行、最强大的轻量级容器框架，了解熟悉spring的生命周期非常有必要；</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7175534-4ee3a40841c582ec?imageMogr2/auto-orient/strip%7CimageView2/2/w/680/format/webp"></p>
<blockquote>
<p><a href="https://blog.csdn.net/qq_33732195/article/details/123837864">https://blog.csdn.net/qq_33732195/article/details/123837864</a></p>
</blockquote>
<ul>
<li>首先容器启动后，对bean进行初始化</li>
<li>按照bean的定义，注入属性</li>
<li>检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给bean，如BeanNameAware等</li>
<li>以上步骤，bean对象已正确构造，通过实现BeanPostProcessor接口，可以再进行一些自定义方法处理。<br>如:postProcessBeforeInitialzation</li>
<li>BeanPostProcessor的前置处理完成后，可以实现postConstruct，afterPropertiesSet，init-method等方法，<br>增加我们自定义的逻辑</li>
<li>通过实现BeanPostProcessor接口，进行postProcessAfterInitialzation后置处理</li>
<li>接着Bean准备好被使用</li>
<li>容器关闭后，如果Bean实现了DisposableBean接口，则会回调该接口的destroy()方法</li>
<li>通过给destroy-method指定函数，就可以在bean销毁前执行指定的逻辑</li>
</ul>
<h3 id="2-TCP三次握手，四次挥手"><a href="#2-TCP三次握手，四次挥手" class="headerlink" title="2.TCP三次握手，四次挥手"></a>2.TCP三次握手，四次挥手</h3><p><img src="https://upload-images.jianshu.io/upload_images/7175534-897b99e555c1d84e?imageMogr2/auto-orient/strip%7CimageView2/2/w/499/format/webp"></p>
<h4 id="三次握手："><a href="#三次握手：" class="headerlink" title="三次握手："></a>三次握手：</h4><ul>
<li>第一次握手(SYN&#x3D;1, seq&#x3D;x)，发送完毕后，客户端进入 SYN_SEND 状态</li>
<li>第二次握手(SYN&#x3D;1, ACK&#x3D;1, seq&#x3D;y, ACKnum&#x3D;x+1)， 发送完毕后，服务器端进入 SYN_RCVD 状态。</li>
<li>第三次握手(ACK&#x3D;1，ACKnum&#x3D;y+1)，发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手，即可以开始数据传输。</li>
</ul>
<h4 id="四次挥手："><a href="#四次挥手：" class="headerlink" title="四次挥手："></a>四次挥手：</h4><ul>
<li>第一次挥手(FIN&#x3D;1，seq&#x3D;a)，发送完毕后，客户端进入 FIN_WAIT_1 状态</li>
<li>第二次挥手(ACK&#x3D;1，ACKnum&#x3D;a+1)，发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态</li>
<li>第三次挥手(FIN&#x3D;1，seq&#x3D;b)，发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。</li>
<li>第四次挥手(ACK&#x3D;1，ACKnum&#x3D;b+1)，客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。</li>
</ul>
<h3 id="3-线程池执行流程图"><a href="#3-线程池执行流程图" class="headerlink" title="3.线程池执行流程图"></a>3.线程池执行流程图</h3><p>线程池：一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务，这避免了在处理短时间任务时创建与销毁线程的代价。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7175534-b5cf53782e14ae69?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp"></p>
<h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><ul>
<li>提交一个任务，线程池里存活的核心线程数小于线程数corePoolSize时，线程池会创建一个核心线程去处理提交的任务。</li>
<li>如果线程池核心线程数已满，即线程数已经等于corePoolSize，一个新提交的任务，会被放进任务队列workQueue排队等待执行。</li>
<li>当线程池里面存活的线程数已经等于corePoolSize了,并且任务队列workQueue也满，判断线程数是否达到maximumPoolSize，即最大线程数是否已满，如果没到达，创建一个非核心线程执行提交的任务。</li>
<li>如果当前的线程数达到了maximumPoolSize，还有新的任务过来的话，直接采用拒绝策略处理。</li>
</ul>
<h4 id="JDK提供了四种拒绝策略处理类"><a href="#JDK提供了四种拒绝策略处理类" class="headerlink" title="JDK提供了四种拒绝策略处理类"></a>JDK提供了四种拒绝策略处理类</h4><ul>
<li>AbortPolicy(抛出一个异常，默认的)</li>
<li>DiscardPolicy(直接丢弃任务)</li>
<li>DiscardOldestPolicy（丢弃队列里最老的任务，将当前这个任务继续提交给线程池）</li>
<li>CallerRunsPolicy（交给线程池调用所在的线程进行处理)</li>
</ul>
<h3 id="4-JVM内存结构"><a href="#4-JVM内存结构" class="headerlink" title="4.JVM内存结构"></a>4.JVM内存结构</h3><p><img src="https://upload-images.jianshu.io/upload_images/7175534-abebcf2aa87680e3?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp"></p>
<h4 id="程序计数器（PC-寄存器）"><a href="#程序计数器（PC-寄存器）" class="headerlink" title="程序计数器（PC 寄存器）"></a>程序计数器（PC 寄存器）</h4><p>程序计数器是一块较小的内存空间，可以看作当前线程所执行的字节码的行号指示器。在虚拟机的模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、异常处理、线程恢复等基础功能都需要依赖计数器完成。</p>
<h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><ul>
<li>与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期与线程相同</li>
<li>每个方法被执行的时候都会创建一个”栈帧”,用于存储局部变量表(包括参数)、操作数栈、动态链接、方法出口等信息。每个方法被调用到执行完的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</li>
<li>局部变量表存放各种基本数据类型boolean、byte、char、short等</li>
</ul>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>与虚拟机栈基本类似，区别在于虚拟机栈为虚拟机执行的java方法服务，而本地方法栈则是为Native方法服务。</p>
<h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><ul>
<li>GC堆是java虚拟机所管理的内存中最大的一块内存区域，也是被各个线程共享的内存区域，在JVM启动时创建。</li>
<li>其大小通过-Xms(最小值)和-Xmx(最大值)参数设置，-Xms为JVM启动时申请的最小内存，-Xmx为JVM可申请的最大内存。</li>
<li>由于现在收集器都是采用分代收集算法，堆被划分为新生代和老年代。新生代由S0和S1构成，可通过-Xmn参数来指定新生代的大小。</li>
<li>所有对象实例以及数组都在堆上分配。</li>
<li>Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种符号引用，这部分内容将在类加载后放到方法区的运行时常量池中。</li>
</ul>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><ul>
<li>也称”永久代” ，它用于存储虚拟机加载的类信息、常量、静态变量、是各个线程共享的内存区域。可以通过-XX:PermSize 和 -XX:MaxPermSize 参数限制方法区的大小。</li>
<li>运行时常量池：是方法区的一部分，其中的主要内容来自于JVM对Class的加载。（<strong>JDK8后在堆中</strong>）</li>
<li>Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种符号引用，这部分内容将在类加载后放到方法区的运行时常量池中。</li>
</ul>
<h3 id="5-Java内存模型"><a href="#5-Java内存模型" class="headerlink" title="5.Java内存模型"></a>5.Java内存模型</h3><p><img src="https://upload-images.jianshu.io/upload_images/7175534-3a68c160832ae950?imageMogr2/auto-orient/strip%7CimageView2/2/w/823/format/webp"></p>
<ul>
<li><p>Java的多线程之间是通过共享内存进行通信的，在通信过程中会存在一系列如可见性、原子性、顺序性等问题，而JMM就是围绕着多线程通信以及与其相关的一系列特性而建立的模型。JMM定义了一些语法集，这些语法集映射到Java语言中就是volatile、synchronized等关键字</p>
<blockquote>
<p><a href="https://www.jianshu.com/p/3c1691aed1a5">https://www.jianshu.com/p/3c1691aed1a5</a></p>
</blockquote>
</li>
<li><p>Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。</p>
</li>
</ul>
<h3 id="6-springMVC执行流程"><a href="#6-springMVC执行流程" class="headerlink" title="6.springMVC执行流程"></a>6.springMVC执行流程</h3><p><img src="https://upload-images.jianshu.io/upload_images/7175534-e2e338ea3a1479a4?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp"></p>
<ul>
<li>User向服务器发送request,前端控制Servelt DispatcherServlet捕获;</li>
<li>DispatcherServlet对请求URL进行解析，调用HandlerMapping获得该Handler配置的所有相关的对象，最后以HandlerExecutionChain对象的形式返回.</li>
<li>DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter.</li>
<li>提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)</li>
<li>Handler执行完成后，返回一个ModelAndView对象到DispatcherServlet </li>
<li>根据返回的ModelAndView，选择一个适合的ViewResolver</li>
<li>ViewResolver 结合Model和View，来渲染视图</li>
<li>将渲染结果返回给客户端。</li>
</ul>
<h3 id="7-JDBC执行流程"><a href="#7-JDBC执行流程" class="headerlink" title="7.JDBC执行流程"></a>7.JDBC执行流程</h3><p><img src="https://upload-images.jianshu.io/upload_images/7175534-ee60659c09771e96?imageMogr2/auto-orient/strip%7CimageView2/2/w/323/format/webp"></p>
<h4 id="JDBC执行流程："><a href="#JDBC执行流程：" class="headerlink" title="JDBC执行流程："></a>JDBC执行流程：</h4><ul>
<li>连接数据源</li>
<li>为数据库传递查询和更新指令</li>
<li>处理数据库响应并返回的结果</li>
</ul>
<h3 id="8-spring-cloud组件架构"><a href="#8-spring-cloud组件架构" class="headerlink" title="8.spring cloud组件架构"></a>8.spring cloud组件架构</h3><p>Spring Cloud是一个基于Spring Boot实现的云原生应用开发工具，它为基于JVM的云原生应用开发中涉及的配置管理、服务发现、熔断器、智能路由、微代理、控制总线、分布式会话和集群状态管理等操作提供了一种简单的开发方式。<br><img src="https://upload-images.jianshu.io/upload_images/7175534-006823b924ef3772?imageMogr2/auto-orient/strip%7CimageView2/2/w/1020/format/webp"></p>
<ul>
<li>Eureka 负责服务的注册与发现。</li>
<li>Hystrix 负责监控服务之间的调用情况，起到熔断,降级作用。</li>
<li>Spring Cloud Config 提供了统一的配置中心服务。</li>
<li>所有对外的请求和服务，我们都通过Zuul来进行转发，起到 API 网关的作用</li>
<li>最后我们使用 Sleuth+Zipkin 将所有的请求数据记录下来，方便我们进行后续分析。</li>
<li>Spring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端负载均衡的工具。<br>它是一个基于HTTP和TCP的客户端负载均衡器。</li>
<li>Feign是一个声明式的Web Service客户端，它的目的就是让Web Service调用更加简单。</li>
</ul>
<h3 id="9-dubbo-调用"><a href="#9-dubbo-调用" class="headerlink" title="9.dubbo 调用"></a>9.dubbo 调用</h3><p>Dubbo是一个分布式服务框架，致力于提供高性能和透明化的远程服务调用方案，这容易和负载均衡弄混，负载均衡是对外提供一个公共地址，请求过来时通过轮询、随机等，路由到不同server<br><img src="https://upload-images.jianshu.io/upload_images/7175534-f65917a3e25fb3a2?imageMogr2/auto-orient/strip%7CimageView2/2/w/821/format/webp"></p>
<ul>
<li>Provider: 暴露服务的服务提供方。</li>
<li>Consumer: 调用远程服务的服务消费方。</li>
<li>Registry: 服务注册与发现的注册中心。</li>
<li>Monitor: 统计服务的调用次调和调用时间的监控中心。</li>
<li>Container: 服务运行容器。</li>
</ul>
<h2 id="volatile解析"><a href="#volatile解析" class="headerlink" title="volatile解析"></a>volatile解析</h2><h3 id="1-volatile的用法"><a href="#1-volatile的用法" class="headerlink" title="1.volatile的用法"></a>1.volatile的用法</h3><p>volatile关键字是Java虚拟机提供的的<strong>最轻量级的同步机制</strong>，它作为一个修饰符出现，用来<strong>修饰变量</strong>（不包括局部变量）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileTest</span>  &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Task</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;线程t1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;开始通知线程停止&quot;</span>);</span><br><span class="line">                <span class="comment">// 修改stop变量值</span></span><br><span class="line">                task.stop = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程t2&quot;</span>);</span><br><span class="line">        t1.start();  <span class="comment">// 开启线程t1</span></span><br><span class="line">        t2.start();  <span class="comment">// 开启线程t2</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">stop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">s</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程退出&quot;</span> + (System.currentTimeMillis() - s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台输出</span></span><br><span class="line">开始通知线程停止</span><br></pre></td></tr></table></figure>


<blockquote>
<p>线程t1对t2的<strong>stop变量视而不可见</strong>，因此，它一直在死循环running中。如果给变量stop加上volatile修饰，线程t1是可以停下来的：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">stop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">开始通知线程停止</span><br><span class="line">线程退出<span class="number">1002</span></span><br></pre></td></tr></table></figure>

<h3 id="2-vlatile修饰变量的作用"><a href="#2-vlatile修饰变量的作用" class="headerlink" title="2. vlatile修饰变量的作用"></a>2. vlatile修饰变量的作用</h3><p>从以上例子，我们可以发现变量stop，加了vlatile修饰之后，线程t1对stop就可见了。其实，vlatile的作用就是：<strong>保证变量对所有线程可见性</strong>。当然，vlatile还有个作用就是，<strong>禁止指令重排</strong>，但是它<strong>不保证原子性</strong>。<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5177218cf2b491da99d43392c7bd271~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>所以当面试官问你<strong>volatile的作用或者特性</strong>，都可以这么回答：</p>
<ul>
<li>保证变量对所有线程可见性;</li>
<li>禁止指令重排序</li>
<li>不保证原子性</li>
</ul>
<h3 id="3-现代计算机的内存模型（计算机模型，MESI协议，嗅探技术，总线）"><a href="#3-现代计算机的内存模型（计算机模型，MESI协议，嗅探技术，总线）" class="headerlink" title="3. 现代计算机的内存模型（计算机模型，MESI协议，嗅探技术，总线）"></a>3. 现代计算机的内存模型（计算机模型，MESI协议，嗅探技术，总线）</h3><p>为了更好理解volatile，先回顾一下计算机的内存模型与JMM（Java内存模型）吧</p>
<h4 id="计算机模型"><a href="#计算机模型" class="headerlink" title="计算机模型"></a>计算机模型</h4><p>计算机执行程序时，指令是由CPU处理器执行的，而打交道的数据是在主内存当中的。</p>
<p>由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统加入一层读写速度接近处理器运算速度的高速缓存（Cache），以作为来作为内存与处理器之间的缓冲。</p>
<p>在多路处理器系统中，每个处理器都有自己的高速缓存，而它们共享同一主内存。<strong>计算机抽象内存模型</strong>如下：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f995fb284a7241b9b95431e79a1c37b0~tplv-k3u1fbpfcp-zoom-1.image"></p>
<ul>
<li>程序执行时，把需要用到的数据，从主内存拷贝一份到高速缓存。</li>
<li>CPU处理器计算时，从它的高速缓存中读取，把计算完的数据写入高速缓存。</li>
<li>当程序运算结束，把高速缓存的数据刷新会主内存。</li>
</ul>
<p>随着科学技术的发展，为了效率，高速缓存又衍生出一级缓存（L1），二级缓存（L2），甚至三级缓存(L3);<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05fa9ff22d7f42ae82122bfc6c233bd9~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>当多个处理器的运算任务都涉及同一块主内存区域，可能导致<strong>缓存数据不一致</strong>问题。如何解决这个问题呢？有两种方案</p>
<ul>
<li>1、通过在总线加LOCK锁的方式。</li>
<li>2、通过缓存一致性协议（Cache Coherence Protocol）</li>
</ul>
<h4 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h4><blockquote>
<p>总线（Bus）是计算机各种功能部件之间传送信息的公共通信干线，它是由导线组成的传输线束， 按照计算机所传输的信息种类，计算机的总线可以划分为数据总线、地址总线和控制总线，分别用来传输数据、数据地址和控制信号。</p>
</blockquote>
<p>CPU和其他功能部件是通过总线通信的，如果在总线加LOCK锁，那么在锁住总线期间，其他CPU是无法访问内存，这样一来，<strong>效率就比较低了</strong>。</p>
<h4 id="MESI协议"><a href="#MESI协议" class="headerlink" title="MESI协议"></a>MESI协议</h4><p>为了解决一致性问题，还可以通过<strong>缓存一致性协议</strong>。即各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI（IllinoisProtocol）、MOSI、Synapse、Firefly及DragonProtocol等。比较著名的就是Intel的MESI（Modified Exclusive Shared Or Invalid）协议，它的核心思想是：</p>
<blockquote>
<p> 当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p>
</blockquote>
<p>CPU中每个缓存行标记的4种状态（M、E、S、I）,也了解一下吧:</p>
<table>
<thead>
<tr>
<th>缓存状态</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>M，被修改（Modified)</td>
<td>该缓存行只被该CPU缓存，与主存的值不同，会在它被其他CPU读取之前写入内存，并设置为Shared</td>
</tr>
<tr>
<td>E，独享的（Exclusive)</td>
<td>该缓存行只被该CPU缓存，与主存的值相同，被其他CPU读取时置为Shared，被其他CPU写时置为Modified</td>
</tr>
<tr>
<td>S，共享的（Shared)</td>
<td>该缓存行可能被多个CPU缓存，各个缓存中的数据与主存数据相同</td>
</tr>
<tr>
<td>I，无效的（Invalid）</td>
<td>该缓存行数据是无效，需要时需重新从主存载入</td>
</tr>
</tbody></table>
<p>MESI协议是如何实现的？如何保证当前处理器的内部缓存、主内存和其他处理器的缓存数据在总线上保持一致的？</p>
<p><strong>多处理器总线嗅探</strong></p>
<h4 id="嗅探技术"><a href="#嗅探技术" class="headerlink" title="嗅探技术"></a>嗅探技术</h4><blockquote>
<p>在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己的缓存值是不是过期了，如果处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据库读到处理器缓存中。</p>
</blockquote>
<h3 id="4-Java内存模型（JMM）"><a href="#4-Java内存模型（JMM）" class="headerlink" title="4. Java内存模型（JMM）"></a>4. Java内存模型（JMM）</h3><ul>
<li>Java虚拟机规范试图定义一种Java内存模型,来<strong>屏蔽掉各种硬件和操作系统的内存访问差异</strong>，以实现让Java程序在各种平台上都能达到一致的内存访问效果。</li>
<li>Java内存模型<strong>类比</strong>于计算机内存模型。</li>
<li>为了更好的执行性能，Java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存打交道，也没有限制编译器进行调整代码顺序优化。所以Java内存模型<strong>会存在缓存一致性问题和指令重排序问题的</strong>。</li>
<li>Java内存模型规定所有的变量都是存在主内存当中（类似于计算机模型中的物理内存），每个线程都有自己的工作内存（类似于计算机模型的高速缓存）。这里的<strong>变量</strong>包括实例变量和静态变量，但是<strong>不包括局部变量</strong>，因为局部变量是线程私有的。</li>
<li>线程的工作内存保存了被该线程使用的变量的主内存副本，<strong>线程对变量的所有操作都必须在工作内存中进行</strong>，而不能直接操作操作主内存。并且每个线程不能访问其他线程的工作内存。</li>
</ul>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6ca8c98a8cc42c998dd4fe3324ded79~tplv-k3u1fbpfcp-zoom-1.image"></p>
<ul>
<li><p>举个例子，假设i的初始值是0，执行以下语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i = i + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>首先，执行线程t1从主内存中读取到 <code>i=0</code> 到工作内存。然后在工作内存中，赋值 <code>i+1</code> ，工作内存就得到 <code>i=1</code>，最后把结果写回主内存。因此，如果是单线程的话，该语句执行是没问题的。但是呢，线程t2的本地工作内存还没过期，那么它读到的数据就是脏数据了。如图：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0abe171336e4f89a58722a1569d64ce~tplv-k3u1fbpfcp-zoom-1.image"></p>
</li>
</ul>
<p>Java内存模型是围绕着如何在并发过程中如何处理<strong>原子性、可见性和有序性</strong>这3个特征来建立的，我们再来一起回顾一下</p>
<h3 id="5-并发编程的3个特性（原子性、可见性、有序性）"><a href="#5-并发编程的3个特性（原子性、可见性、有序性）" class="headerlink" title="5.并发编程的3个特性（原子性、可见性、有序性）"></a>5.并发编程的3个特性（原子性、可见性、有序性）</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>原子性：指操作是不可中断的，要么执行完成，要么不执行，基本数据类型的访问和读写都是具有原子性（long和double的非原子性协定除外）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i = <span class="number">666</span>; <span class="comment">// 语句1</span></span><br><span class="line">i = j;   <span class="comment">// 语句2</span></span><br><span class="line">i = i + <span class="number">1</span>;  <span class="comment">//语句 3</span></span><br><span class="line">i++;   <span class="comment">// 语句4</span></span><br></pre></td></tr></table></figure>
<ul>
<li>语句1操作显然是原子性的，将数值 666 赋值给 i，即线程执行这个语句时，直接将数值 666 写入到工作内存中</li>
<li>语句2操作看起来也是原子性的，但是它实际上涉及两个操作，先去读 <strong>j</strong> 的值，再把 <strong>j</strong> 的值写入工作内存，两个操作分开都是原子操作，但是合起来就不满足原子性了</li>
<li>语句3读取 <strong>i</strong> 的值，加 1，再写回主存，不是原子性操作</li>
<li>语句4 等同于语句3，也是非原子性操作</li>
</ul>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><ul>
<li>可见性：当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改</li>
<li>Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是volatile变量都是如此</li>
<li>volatile变量，保证新值能立即同步回主内存，以及每次使用前立即从主内存刷新，所以说volatile保证了多线程操作变量的可见性</li>
<li><strong>synchronized</strong>和<strong>Lock</strong>也能够保证可见性，线程在释放锁之前，会把共享变量值都刷回主存。<strong>final</strong>也可以实现可见性。</li>
</ul>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>Java虚拟机这样描述Java程序的有序性：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中，观察另一个线程，所有的操作都是无序的。</p>
<blockquote>
<p>后半句意思就是，在Java内存模型中，<strong>允许编译器和处理器对指令进行重排序</strong>，会影响到多线程并发执行的正确性；前半句意思就是 <strong><code>as-if-serial</code></strong> 的语义，即不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不会被改变。</p>
</blockquote>
<ul>
<li>比如以下程序代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> <span class="number">3.14</span>;    <span class="comment">// A</span></span><br><span class="line"><span class="type">double</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">1.0</span>;     <span class="comment">// B</span></span><br><span class="line"><span class="type">double</span> <span class="variable">area</span> <span class="operator">=</span> pi * r * r; <span class="comment">// C</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>步骤C依赖于步骤A和B，因为指令重排的存在，程序执行顺序可能是A-&gt;B-&gt;C，也可能是B-&gt;A-&gt;C，但是C不能在A或者B前面执行，这将违反as-if-serial语义<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87387195b86749ddbe1f36582a562988~tplv-k3u1fbpfcp-zoom-1.image"></p>
</li>
<li><p>假设程序先执行 <code>read</code> 方法，再执行 <code>add</code> 方法，结果一定是输出sum&#x3D;2吗？</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span> <span class="params">()</span> &#123;</span><br><span class="line">    b = <span class="number">1</span>;              <span class="comment">// 1</span></span><br><span class="line">    flag = <span class="literal">true</span>;        <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;         <span class="comment">// 3</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> b + b;   <span class="comment">// 4</span></span><br><span class="line">        System.out.println(<span class="string">&quot;bb sum is&quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果是单线程，结果应该没问题，如果是多线程，线程t1对步骤1和2进行了<strong>指令重排序</strong>呢？结果sum就不是2了，而是0，如下图所示：<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/093c6e37453c462985bed78c4d239979~tplv-k3u1fbpfcp-zoom-1.image"></li>
</ul>
<p>这是为啥呢？<strong>指令重排序</strong>了解一下，指令重排是指在程序执行过程中,<strong>为了提高性能</strong>, <strong>编译器和CPU可能会对指令进行重新排序</strong>。CPU重排序包括指令并行重排序和内存系统重排序，重排序类型和重排序执行过程如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8a24934eab24bf9b80c402039371aa2~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>实际上，可以给flag加上volatile关键字，来保证有序性。当然，也可以通过synchronized和Lock来保证有序性。synchronized和Lock保证某一时刻是只有一个线程执行同步代码，相当于是让线程顺序执行程序代码了，自然就保证了有序性。</p>
<p>实际上Java内存模型的有序性并不是仅靠volatile、synchronized和Lock来保证有序性的。这是因为Java语言中，有一个<strong>先行发生原则（happens-before）</strong>：</p>
<ul>
<li><strong>程序次序规则</strong>：在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作</li>
<li><strong>管程锁定规则</strong>：一个<code>unLock</code> 操作先行发生于后面对同一个锁的 lock 操作</li>
<li><strong>volatile变量规则</strong>：对一个变量的写操作先行发生于后面对这个变量的读操作</li>
<li><strong>线程启动规则</strong>：Thread对象的start()方法先行发生于此线程的每个动作</li>
<li><strong>线程终止规则</strong>：线程中所有的操作都先行发生于线程的终止检测，可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</li>
<li><strong>线程中断规则</strong>：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li>
<li><strong>对象终结规则</strong>：一个对象的初始化完成先行发生于它的finalize()方法的开始</li>
<li><strong>传递性</strong>：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li>
</ul>
<p>根据happens-before的八大规则，我们回到刚的例子，一起分析一下。给flag加上volatile关键字，look look它是如何保证有序性的，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span> <span class="params">()</span> &#123;</span><br><span class="line">    b = <span class="number">1</span>;              <span class="comment">// 1</span></span><br><span class="line">    flag = <span class="literal">true</span>;        <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;         <span class="comment">// 3</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> b + b;   <span class="comment">// 4</span></span><br><span class="line">        System.out.println(<span class="string">&quot;bb sum is&quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先，flag加上volatile关键字，那就禁止了指令重排，也就是1 happens-before 2了</li>
<li>根据<strong>volatile变量规则</strong>，2 happens-before 3</li>
<li>由<strong>程序次序规则</strong>，得出 3 happens-before 4</li>
<li>最后由<strong>传递性</strong>，得出1 happens-before 4，因此妥妥的输出sum&#x3D;2</li>
</ul>
<h3 id="6-volatile底层原理"><a href="#6-volatile底层原理" class="headerlink" title="6.volatile底层原理"></a>6.volatile底层原理</h3><p>我们知道volatile的语义就是保证变量对所有线程可见性以及禁止指令重排优化。那么，它的底层是如何保证可见性和禁止指令重排的呢？</p>
<h4 id="图解volatile是如何保证可见性的"><a href="#图解volatile是如何保证可见性的" class="headerlink" title="图解volatile是如何保证可见性的"></a>图解volatile是如何保证可见性的</h4><p>假设flag变量的初始值false，现在有两条线程t1和t2要访问它，就可以简化为以下图：<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ddbe230c8dc4501a77ffbe0587b5ba6~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>如果线程t1执行以下代码语句，并且flag没有volatile修饰的话；t1刚修改完flag的值，还没来得及刷新到主内存，t2又跑过来读取了，很容易就数据flag不一致了，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">flag = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc065cf75803496aa1efafd6d68ba968~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>如果flag变量是由volatile修饰的话，就不一样了，如果线程t1修改了flag值，volatile能保证修饰的flag变量后，可以<strong>立即同步回主内存</strong>。如图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27e9e195810a4a71bdeb38dd128b27e4~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>细心的朋友会发现，线程t2不还是flag旧的值吗，这不还有问题嘛？其实volatile还有一个保证，就是<strong>每次使用前立即先从主内存刷新最新的值</strong>，线程t1修改完后，线程t2的变量副本会过期了，如图：<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e67dcdfe9d9412dab89961bf92b5b53~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>显然，这里还不是底层，实际上volatile保证可见性和禁止指令重排都跟<strong>内存屏障</strong>有关，我们编译volatile相关代码看看</p>
<h4 id="DCL单例模式（volatile）-编译对比"><a href="#DCL单例模式（volatile）-编译对比" class="headerlink" title="DCL单例模式（volatile）&amp;编译对比"></a>DCL单例模式（volatile）&amp;编译对比</h4><p>DCL单例模式（Double Check Lock，双重检查锁）比较常用，它是需要volatile修饰的，所以就拿这段代码编译</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译这段代码后，观察有volatile关键字和没有volatile关键字时的instance所生成的汇编代码发现，有volatile关键字修饰时，会多出一个lock addl $0x0,(%esp)，即多出一个lock前缀指令</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0x01a3de0f</span>: mov    $<span class="number">0x3375cdb0</span>,%esi   ;...beb0cd75 <span class="number">33</span>  </span><br><span class="line">                                        ;   &#123;oop(<span class="string">&#x27;Singleton&#x27;</span>)&#125;  </span><br><span class="line"><span class="number">0x01a3de14</span>: mov    %eax,<span class="number">0x150</span>(%esi)   ;..<span class="number">.89865001</span> <span class="number">0000</span>  </span><br><span class="line"><span class="number">0x01a3de1a</span>: shr    $<span class="number">0x9</span>,%esi          ;...c1ee09  </span><br><span class="line"><span class="number">0x01a3de1d</span>: movb   $<span class="number">0x0</span>,<span class="number">0x1104800</span>(%esi)  ;...c6860048 <span class="number">100100</span></span><br><span class="line"><span class="comment">// volatile关键字多了这个lock</span></span><br><span class="line"><span class="number">0x01a3de24</span>: lock addl $<span class="number">0x0</span>,(%esp)     ;...f0830424 <span class="number">00</span>  </span><br><span class="line">                                        ;*putstatic instance  </span><br><span class="line">                                        ; - Singleton::getInstance@<span class="number">24</span> </span><br></pre></td></tr></table></figure>
<p> lock指令相当于一个<strong>内存屏障</strong>，它保证以下这几点：</p>
<ul>
<li>重排序时不能把后面的指令重排序到内存屏障之前的位置</li>
<li>将本处理器的缓存写入内存</li>
<li>如果是写入动作，会导致其他处理器中对应的缓存无效</li>
</ul>
<p>显然，第2、3点是volatile保证可见性的体现，第1点是禁止指令重排列的体现。</p>
<h4 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h4><p>内存屏障四大分类：（Load 代表读取指令，Store代表写入指令）</p>
<table>
<thead>
<tr>
<th>内存屏障类型</th>
<th>抽象场景</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>LoadLoad屏障</td>
<td>Load1; LoadLoad; Load2</td>
<td>在Load2要读取的数据被访问前，保证Load1要读取的数据被读取完毕</td>
</tr>
<tr>
<td>StoreStore屏障</td>
<td>Store1; StoreStore; Store2</td>
<td>在Store2写入执行前，保证Store1的写入操作对其它处理器可见</td>
</tr>
<tr>
<td>LoadStore屏障</td>
<td>Load1; LoadStore; Store2</td>
<td>在Store2被写入前，保证Load1要读取的数据被读取完毕</td>
</tr>
<tr>
<td>StoreLoad屏障</td>
<td>Store1; StoreLoad; Load2</td>
<td>在Load2读取操作执行前，保证Store1的写入对所有处理器可见</td>
</tr>
</tbody></table>
<p>为了实现volatile的内存语义，Java内存模型采取以下的保守策略</p>
<ul>
<li>在每个volatile写操作的前面插入一个StoreStore屏障</li>
<li>在每个volatile写操作的后面插入一个StoreLoad屏障</li>
<li>在每个volatile读操作的后面插入一个LoadLoad屏障</li>
<li>在每个volatile读操作的后面插入一个LoadStore屏障</li>
</ul>
<p>内存屏障这玩意太抽象了，我们照着代码看下：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a85eff53f99f420c8139bb69b2d4f6ae~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>内存屏障保证前面的指令先执行，所以这就保证了禁止了指令重排，同时内存屏障保证缓存写入内存和其他处理器缓存失效，这也就保证了可见性</p>
<h3 id="7-volatile的典型场景"><a href="#7-volatile的典型场景" class="headerlink" title="7.volatile的典型场景"></a>7.volatile的典型场景</h3><p>通常来说，使用volatile必须具备以下2个条件：</p>
<ul>
<li>1）对变量的写操作不依赖于当前值</li>
<li>2）该变量没有包含在具有其他变量的不变式中</li>
</ul>
<p>实际上，volatile场景一般就是<strong>状态标志</strong>，以及<strong>DCL单例模式</strong>。</p>
<h4 id="7-1-状态标志"><a href="#7-1-状态标志" class="headerlink" title="7.1 状态标志"></a>7.1 状态标志</h4><p>《深入理解Java虚拟机》书中的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map configOptions;</span><br><span class="line"><span class="type">char</span>[] configText;</span><br><span class="line"><span class="comment">// 此变量必须定义为 volatile</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">initialized</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设以下代码在线程 A 中运行</span></span><br><span class="line"><span class="comment">// 模拟读取配置信息, 当读取完成后将 initialized 设置为 true 以告知其他线程配置可用</span></span><br><span class="line">configOptions = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">configText = readConfigFile(fileName);</span><br><span class="line">processConfigOptions(configText, configOptions);</span><br><span class="line">initialized = <span class="literal">true</span>;</span><br><span class="line">      </span><br><span class="line"><span class="comment">// 假设以下代码在线程 B 中运行</span></span><br><span class="line"><span class="comment">// 等待 initialized 为 true, 代表线程 A 已经把配置信息初始化完成</span></span><br><span class="line"><span class="keyword">while</span>(!initialized) &#123;</span><br><span class="line">   sleep();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用线程 A 中初始化好的配置信息</span></span><br><span class="line">doSomethingWithConfig();</span><br></pre></td></tr></table></figure>
<h4 id="7-2-DCL单例模式"><a href="#7-2-DCL单例模式" class="headerlink" title="7.2 DCL单例模式"></a>7.2 DCL单例模式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;   </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="literal">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="8-volatile相关经典面试题"><a href="#8-volatile相关经典面试题" class="headerlink" title="8. volatile相关经典面试题"></a>8. volatile相关经典面试题</h3><ul>
<li>谈谈volatile的特性</li>
<li>volatile的内存语义  </li>
<li>说说并发编程的3大特性</li>
<li>什么是内存可见性，什么是指令重排序？</li>
<li>volatile是如何解决java并发中可见性的问题</li>
<li>volatile如何防止指令重排</li>
<li>volatile可以解决原子性嘛？为什么？</li>
<li>volatile底层的实现机制</li>
<li>volatile和synchronized的区别？</li>
</ul>
<h4 id="8-1-谈谈volatile的特性"><a href="#8-1-谈谈volatile的特性" class="headerlink" title="8.1 谈谈volatile的特性"></a>8.1 谈谈volatile的特性</h4><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e624231e978455ebec33c7380ffba0d~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h4 id="8-2-volatile的内存语义"><a href="#8-2-volatile的内存语义" class="headerlink" title="8.2  volatile的内存语义"></a>8.2  volatile的内存语义</h4><ul>
<li>当写一个 volatile 变量时，JMM 会把该线程对应的本地内存中的共享变量值刷新到主内存。</li>
<li>当读一个 volatile 变量时，JMM 会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</li>
</ul>
<h4 id="8-3-说说并发编程的3大特性"><a href="#8-3-说说并发编程的3大特性" class="headerlink" title="8.3 说说并发编程的3大特性"></a>8.3 说说并发编程的3大特性</h4><ul>
<li>原子性</li>
<li>可见性</li>
<li>有序性</li>
</ul>
<h4 id="8-4-什么是内存可见性，什么是指令重排序？"><a href="#8-4-什么是内存可见性，什么是指令重排序？" class="headerlink" title="8.4 什么是内存可见性，什么是指令重排序？"></a>8.4 什么是内存可见性，什么是指令重排序？</h4><ul>
<li>可见性就是指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改</li>
<li>指令重排是指JVM在编译Java代码的时候，或者CPU在执行JVM字节码的时候，对现有的指令顺序进行重新排序</li>
</ul>
<h4 id="8-5-volatile是如何解决java并发中可见性的问题"><a href="#8-5-volatile是如何解决java并发中可见性的问题" class="headerlink" title="8.5 volatile是如何解决java并发中可见性的问题"></a>8.5 volatile是如何解决java并发中可见性的问题</h4><p>底层是通过内存屏障实现的，volatile能保证修饰的变量后，可以立即同步回主内存，每次使用前立即先从主内存刷新最新的值</p>
<h4 id="8-6-volatile如何防止指令重排"><a href="#8-6-volatile如何防止指令重排" class="headerlink" title="8.6 volatile如何防止指令重排"></a>8.6 volatile如何防止指令重排</h4><p>也是内存屏障，跟面试官讲下Java内存的保守策略：</p>
<ul>
<li>在每个volatile写操作的前面插入一个StoreStore屏障</li>
<li>在每个volatile写操作的后面插入一个StoreLoad屏障</li>
<li>在每个volatile读操作的后面插入一个LoadLoad屏障</li>
<li>在每个volatile读操作的后面插入一个LoadStore屏障</li>
</ul>
<p>再讲下volatile的语义，重排序时不能把内存屏障后面的指令重排序到内存屏障之前的位置</p>
<h4 id="8-7-volatile可以解决原子性嘛？为什么？"><a href="#8-7-volatile可以解决原子性嘛？为什么？" class="headerlink" title="8.7 volatile可以解决原子性嘛？为什么？"></a>8.7 volatile可以解决原子性嘛？为什么？</h4><p>不可以，可以直接举i++那个例子，原子性需要synchronzied或者lock保证</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">race</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">        race++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">100</span>; j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待所有累加线程结束</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">1</span>)</span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">        System.out.println(test.race);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-8-volatile底层的实现机制"><a href="#8-8-volatile底层的实现机制" class="headerlink" title="8.8 volatile底层的实现机制"></a>8.8 volatile底层的实现机制</h4><p>可以看本文的第六小节，volatile底层原理哈，主要你要跟面试官讲述，volatile如何保证可见性和禁止指令重排，需要讲到内存屏障</p>
<h4 id="8-9-volatile和synchronized的区别？"><a href="#8-9-volatile和synchronized的区别？" class="headerlink" title="8.9 volatile和synchronized的区别？"></a>8.9 volatile和synchronized的区别？</h4><ul>
<li>volatile修饰的是变量，synchronized一般修饰代码块或者方法</li>
<li>volatile保证可见性、禁止指令重排，但是不保证原子性；synchronized可以保证原子性</li>
<li>volatile不会造成线程阻塞，synchronized可能会造成线程的阻塞，所以后面才有锁优化那么多故事~</li>
<li>哈哈，你还有补充嘛~</li>
</ul>
<blockquote>
<p> <a href="https://juejin.im/post/6844903918653145102">Synchronized解析——如果你愿意一层一层剥开我的心</a></p>
</blockquote>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li>&lt;&lt;深入理解Java虚拟机&gt;&gt;</li>
<li><a href="https://www.cnblogs.com/dolphin0520/p/3920373.html">Java并发编程：volatile关键字解析</a></li>
<li><a href="https://juejin.im/post/6844903520760496141">面试官最爱的volatile关键字</a></li>
<li><a href="https://juejin.im/post/6844904149536997384"> 面试官没想到一个Volatile，我都能跟他扯半小时</a></li>
<li><a href="http://47.103.216.138/archives/2550">再有人问你Java内存模型是什么，就把这篇文章发给他。</a></li>
<li><a href="https://www.cnblogs.com/z00377750/p/9180644.html">【并发编程】MESI–CPU缓存一致性协议</a></li>
<li><a href="https://www.sohu.com/a/211287207_684445">漫画：volatile对指令重排的影响 </a></li>
<li><a href="https://www.jianshu.com/p/765e3abbe89a">volatile三大特性详解</a></li>
</ul>
]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux入门</title>
    <url>/2024/08/05/Linux%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>[TOC] </p>
<h3 id="1、tee和cat使用EOF往文件中添加内容"><a href="#1、tee和cat使用EOF往文件中添加内容" class="headerlink" title="1、tee和cat使用EOF往文件中添加内容"></a>1、<code>tee</code>和<code>cat</code>使用<code>EOF</code>往文件中添加内容</h3><h4 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h4><ul>
<li><p>覆盖：要写入的文件可以放在<strong>中间或最后</strong></p>
<ol>
<li><p>格式一</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &lt;&lt; <span class="string">EOF &gt; /test/test.txt</span></span><br><span class="line"><span class="string">Hello World!</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>格式二</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; /test/test.txt &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">Hello World!</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>追加：追加的写法基本和覆盖一样，不同的是单重定向号变成<code>双重定向号</code></p>
<ol>
<li><p>格式一</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &lt;&lt; <span class="string">EOF &gt;&gt; /test/test.txt</span></span><br><span class="line"><span class="string">Hello World 1!</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>格式二</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt;&gt; /test/test.txt &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">Hello World 1!</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<blockquote>
<p>不论是覆盖还是追加，在涉及到变量操作时是需要进行转义的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF &gt;&gt; /test/a.txt</span></span><br><span class="line"><span class="string">PATH=\$PATH:\$HOME/bin</span></span><br><span class="line"><span class="string">export ORACLE_BASE=/u01/app/oracle</span></span><br><span class="line"><span class="string">export ORACLE_HOME=\$ORACLE_BASE/10.2.0/db_1</span></span><br><span class="line"><span class="string">export ORACLE_SID=yqpt</span></span><br><span class="line"><span class="string">export PATH=\$PATH:\$ORACLE_HOME/bin</span></span><br><span class="line"><span class="string">export NLS_LANG=&quot;AMERICAN_AMERICA.AL32UTF8&quot;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="tee"><a href="#tee" class="headerlink" title="tee"></a>tee</h4><p>语法:</p>
<blockquote>
<p><code>tee [-ai][--help][--version][文件...]</code></p>
</blockquote>
<p>参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-a 或 --append 　				 附加到既有文件的后面，而非覆盖它．</span><br><span class="line">-i 或 --ignore-interrupts 　	 忽略中断信号。</span><br><span class="line">--<span class="built_in">help</span> 　				 	  在线帮助。</span><br><span class="line">--version 　				 	  显示版本信息。</span><br></pre></td></tr></table></figure>

<p>使用指令 <code>tee</code> 将用户输入的数据同时保存到文件 <code>file1</code> 和 <code>file2</code> 中，输入如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在两个文件中复制内容</span></span><br><span class="line">$ <span class="built_in">tee</span> file1 file2</span><br><span class="line"><span class="comment"># 输入需要保存到文件的数据</span></span><br><span class="line">Test <span class="built_in">tee</span> <span class="comment">#提示用户输入数据</span></span><br><span class="line">Test <span class="built_in">tee</span> <span class="comment">#输出数据，进行输出反馈</span></span><br><span class="line"><span class="comment"># Ctrl + C退出</span></span><br><span class="line"><span class="comment"># 验证是否写入成功</span></span><br><span class="line">$ <span class="built_in">cat</span> file1 file2</span><br></pre></td></tr></table></figure>

<h3 id="2、使用-cat-命令结合重定向可以在指定位置写入内容"><a href="#2、使用-cat-命令结合重定向可以在指定位置写入内容" class="headerlink" title="2、使用 cat 命令结合重定向可以在指定位置写入内容"></a>2、使用 <code>cat</code> 命令结合重定向可以在指定位置写入内容</h3><blockquote>
<p><strong>备份原文件</strong></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cp</span> filename.txt filename_backup.txt</span><br></pre></td></tr></table></figure>

<ol>
<li><h4 id="使用-head-和-tail-命令结合重定向"><a href="#使用-head-和-tail-命令结合重定向" class="headerlink" title="使用 head 和 tail 命令结合重定向"></a><strong>使用 <code>head</code> 和 <code>tail</code> 命令结合重定向</strong></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将文件的前5行输出到临时文件temp.txt中</span></span><br><span class="line">$ <span class="built_in">head</span> -n 5 filename.txt &gt; temp.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在temp.txt中添加要插入的内容</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;New content to insert&quot;</span> &gt;&gt; temp.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将文件剩余的内容（即第6行到文件末尾）追加到temp.txt中</span></span><br><span class="line">$ <span class="built_in">tail</span> -n +6 filename.txt &gt;&gt; temp.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将temp.txt内容覆盖到原始文件filename.txt</span></span><br><span class="line">$ <span class="built_in">mv</span> temp.txt filename.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 <code>sed</code> 命令</strong></p>
<p><code>sed</code> 命令可以用于流编辑，可以直接在指定的行后插入内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sed <span class="string">&#x27;5a\</span></span><br><span class="line"><span class="string">New content to insert</span></span><br><span class="line"><span class="string">&#x27;</span> filename.txt &gt; temp.txt &amp;&amp; <span class="built_in">mv</span> temp.txt filename.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 <code>awk</code> 命令</strong></p>
<p><code>awk</code> 可以用于处理文本文件，可以通过它在指定行后插入内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ awk <span class="string">&#x27;NR==5 &#123;print &quot;New content to insert&quot;&#125; 1&#x27;</span> filename.txt &gt; temp.txt &amp;&amp; <span class="built_in">mv</span> temp.txt filename.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用 <code>ed</code> 命令</strong></p>
<p><code>ed</code> 是一个文本编辑器，可以在不打开文件的情况下直接编辑文件内容，适合于批处理脚本中的文件操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 验证安装</span></span><br><span class="line">$ ed --version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 ed</span></span><br><span class="line">$ <span class="built_in">sudo</span> yum install ed     <span class="comment"># 如果使用的是 CentOS 7 或更早版本</span></span><br><span class="line">或</span><br><span class="line">$ <span class="built_in">sudo</span> dnf install ed     <span class="comment"># 如果使用的是 CentOS 8 或更新版本</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ed -s filename.txt &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">5a</span></span><br><span class="line"><span class="string">New content to insert</span></span><br><span class="line"><span class="string">.</span></span><br><span class="line"><span class="string">w</span></span><br><span class="line"><span class="string">q</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="3、sed"><a href="#3、sed" class="headerlink" title="3、sed"></a>3、<code>sed</code></h3><p><code>sed</code>（Stream Editor）是一个非常强大的流式文本编辑工具，它主要用于对文本流进行编辑、转换和过滤。</p>
<p>以下是一些 <code>sed</code> 命令的常用操作和示例：</p>
<ol>
<li><h4 id="替换文本："><a href="#替换文本：" class="headerlink" title="替换文本："></a><strong>替换文本</strong>：</h4><p>使用 <code>s</code> 命令可以在文本中进行<strong>替换</strong>操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在文件中将所有的 &quot;old_text&quot; 替换为 &quot;new_text&quot;</span></span><br><span class="line"><span class="comment"># 不保存</span></span><br><span class="line">$ sed <span class="string">&#x27;s/old_text/new_text/g&#x27;</span> filename.txt</span><br><span class="line"><span class="comment"># 保存修改</span></span><br><span class="line">$ sed -i <span class="string">&#x27;s/old_text/new_text/g&#x27;</span> filename.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅替换每行的第一个匹配</span></span><br><span class="line">$ sed -i <span class="string">&#x27;s/old_text/new_text/&#x27;</span> filename.txt</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="删除行："><a href="#删除行：" class="headerlink" title="删除行："></a><strong>删除行</strong>：</h4><p>使用 <code>d</code> 命令可以删除匹配的行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除包含特定文本的行</span></span><br><span class="line"><span class="comment"># sed &#x27;/pattern_to_delete/d&#x27; filename.txt</span></span><br><span class="line"><span class="comment"># 删除文件 `filename.txt` 中包含单词 &quot;example&quot; 的所有行</span></span><br><span class="line">$ sed -i <span class="string">&#x27;/example/d&#x27;</span> filename.txt</span><br><span class="line"><span class="comment"># 删除文件 `filename.txt` 中所有以 &quot;pattern&quot; 开头的行</span></span><br><span class="line">$ sed -i <span class="string">&#x27;/^pattern/d&#x27;</span> filename.txt</span><br><span class="line"><span class="comment"># 删除文件 `filename.txt` 中所有空白行（只包含空格或制表符的行）</span></span><br><span class="line">$ sed -i <span class="string">&#x27;/^\s*$/d&#x27;</span> filename.txt</span><br><span class="line"><span class="comment"># 删除文件 `filename.txt` 中所有以 &quot;start_with&quot; 开头的行</span></span><br><span class="line">$ sed -i <span class="string">&#x27;/^start_with/d&#x27;</span> filename.txt</span><br><span class="line"><span class="comment"># 删除文件 `filename.txt` 中包含任何数字的所有行：</span></span><br><span class="line">$ sed -i <span class="string">&#x27;/[0-9]/d&#x27;</span> filename.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除第 N 行</span></span><br><span class="line">$ sed -i <span class="string">&#x27;Nd&#x27;</span> filename.txt</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="插入和追加行："><a href="#插入和追加行：" class="headerlink" title="插入和追加行："></a><strong>插入和追加行</strong>：</h4><p>使用 <code>i</code> 命令插入行，在指定行之前插入内容；</p>
<p>使用 <code>a</code> 命令追加行，在指定行之后追加内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在第 N 行前插入内容</span></span><br><span class="line">sed -i <span class="string">&#x27;Ni\</span></span><br><span class="line"><span class="string">This is the new line&#x27;</span> filename.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在第 N 行后追加内容</span></span><br><span class="line">sed -i <span class="string">&#x27;Na\</span></span><br><span class="line"><span class="string">This is the new line&#x27;</span> filename.txt</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="打印行："><a href="#打印行：" class="headerlink" title="打印行："></a><strong>打印行</strong>：</h4><p>使用 <code>p</code> 命令可以打印匹配的行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印包含特定文本的行</span></span><br><span class="line">sed -n <span class="string">&#x27;/pattern_to_print/p&#x27;</span> filename.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印特定行号的内容</span></span><br><span class="line">sed -n <span class="string">&#x27;Np&#x27;</span> filename.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>选定行范围</strong>：</p>
<p>使用起始行号和结束行号，可以选定一个行范围进行操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印从第 N 行到第 M 行之间的内容</span></span><br><span class="line">sed -n <span class="string">&#x27;N,Mp&#x27;</span> filename.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除从第 N 行到第 M 行之间的内容</span></span><br><span class="line">sed <span class="string">&#x27;N,Md&#x27;</span> filename.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>保存修改</strong>：</p>
<p>默认情况下，<code>sed</code> 命令只是在屏幕上显示修改后的内容，并不会修改原始文件。</p>
<p>要将修改保存回原始文件，可以使用重定向操作符结合 <code>-i</code> 选项（原地修改）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将修改后的内容保存回原始文件</span></span><br><span class="line">sed -i <span class="string">&#x27;s/old_text/new_text/g&#x27;</span> filename.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>多个命令组合</strong>：</p>
<p>可以使用分号 <code>;</code> 将多个 <code>sed</code> 命令组合在一起，依次应用于每行文本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将同时执行多个操作：删除包含 &quot;pattern&quot; 的行，将 &quot;old_text&quot; 替换为 &quot;new_text&quot;，并在第 N 行前插入新内容</span></span><br><span class="line">sed <span class="string">&#x27;/pattern/d; s/old_text/new_text/g; Ni\</span></span><br><span class="line"><span class="string">New line to insert&#x27;</span> filename.txt</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些是 <code>sed</code> 命令的一些常见用法示例，<code>sed</code> 的功能非常强大，可以通过组合不同的命令和选项来满足各种文本处理需求。</p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes实战</title>
    <url>/2024/07/30/MiniKube%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<p>[TOC] </p>
<h3 id="前置工作"><a href="#前置工作" class="headerlink" title="前置工作"></a>前置工作</h3><h4 id="1、卸载宝塔面板（可选）"><a href="#1、卸载宝塔面板（可选）" class="headerlink" title="1、卸载宝塔面板（可选）"></a>1、卸载宝塔面板（可选）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">下载脚本</span><br><span class="line">wget http://download.bt.cn/install/bt-uninstall.sh</span><br><span class="line">执行脚本</span><br><span class="line">sh bt-uninstall.sh</span><br></pre></td></tr></table></figure>

<h4 id="2、安装docker"><a href="#2、安装docker" class="headerlink" title="2、安装docker"></a>2、安装docker</h4><ul>
<li>先删除本机旧的或者残留的docker</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum remove docker \</span><br><span class="line">                docker-client \</span><br><span class="line">                docker-client-latest \</span><br><span class="line">                docker-common \</span><br><span class="line">                docker-latest \</span><br><span class="line">                docker-latest-logrotate \</span><br><span class="line">                docker-logrotate \</span><br><span class="line">                docker-engine</span><br></pre></td></tr></table></figure>

<ul>
<li>安装依赖</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum update -y &amp;&amp; <span class="built_in">sudo</span> yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure>

<ul>
<li>配置镜像源</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 阿里源</span><br><span class="line">yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"># 清华源</span><br><span class="line">yum-config-manager --add-repo https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<ul>
<li>安装（二选一）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>

<ul>
<li>安装指定版本</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看版本</span></span><br><span class="line">yum list docker-ce --showduplicates | <span class="built_in">sort</span> -r</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line">docker-ce.x86_64                3:26.1.3-1.el8                  docker-ce-stable</span><br><span class="line">docker-ce.x86_64                3:26.1.2-1.el8                  docker-ce-stable</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择版本安装 例如docker-ce-26.1.3</span></span><br><span class="line"><span class="comment"># yum install docker-ce-&lt;版本号&gt; docker-ce-cli-&lt;版本号&gt; containerd.io</span></span><br><span class="line">yum install docker-ce-26.1.3 docker-ce-cli-26.1.3</span><br></pre></td></tr></table></figure>

<ul>
<li>安装containerd（上一步好像会安装依赖，没有的话就按以下步骤安装）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用rpm -qa命令查看是否安装</span><br><span class="line"># rpm -qa | grep containerd</span><br><span class="line">containerd.io-1.6.32-3.1.el8.x86_64</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看YUM源中containerd版本</span></span><br><span class="line">yum list | grep containerd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">yum -y install containerd.io-&lt;版本号&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置containerd服务启动及开机自启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> containerd</span><br><span class="line">systemctl start containerd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证启动成功</span></span><br><span class="line">systemctl status containerd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看Containerd客户端及服务端相关信息</span></span><br><span class="line">ctr version</span><br></pre></td></tr></table></figure>

<ul>
<li>验证docker</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker --version</span><br></pre></td></tr></table></figure>

<ul>
<li>启动并设置开机自启</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line">systemctl <span class="built_in">enable</span> --now docker</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="docker启动报错"><a href="#docker启动报错" class="headerlink" title="docker启动报错"></a>docker启动报错</h5><p>1、更新<code>docker</code>后启动报错，以下指令都在<code>root</code>用户下执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动docker</span></span><br><span class="line">[root@localhost ~]# service docker start</span><br><span class="line">Redirecting to /bin/systemctl start docker.service</span><br><span class="line">Job <span class="keyword">for</span> docker.service failed because the control process exited with error code.</span><br><span class="line">See <span class="string">&quot;systemctl status docker.service&quot;</span> and <span class="string">&quot;journalctl -xe&quot;</span> <span class="keyword">for</span> details.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看docker状态</span></span><br><span class="line">[root@localhost ~]# systemctl status docker.service</span><br><span class="line">● docker.service - Docker Application Container Engine</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/docker.service; disabled; vendor preset: disabled)</span><br><span class="line">   Active: failed (Result: exit-code) since Wed 2024-07-31 09:06:33 CST; 8s ago</span><br><span class="line">     Docs: https://docs.docker.com</span><br><span class="line">  Process: 2391 ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock (code=exited, status=1/FAILURE)</span><br><span class="line"> Main PID: 2391 (code=exited, status=1/FAILURE)</span><br><span class="line"></span><br><span class="line">7月 31 09:06:33 localhost.localdomain systemd[1]: docker.service: Service RestartSec=2s expired, scheduling restart.</span><br><span class="line">7月 31 09:06:33 localhost.localdomain systemd[1]: docker.service: Scheduled restart job, restart counter is at 3.</span><br><span class="line">7月 31 09:06:33 localhost.localdomain systemd[1]: Stopped Docker Application Container Engine.</span><br><span class="line">7月 31 09:06:33 localhost.localdomain systemd[1]: docker.service: Start request repeated too quickly.</span><br><span class="line">7月 31 09:06:33 localhost.localdomain systemd[1]: docker.service: Failed with result <span class="string">&#x27;exit-code&#x27;</span>.</span><br><span class="line">7月 31 09:06:33 localhost.localdomain systemd[1]: Failed to start Docker Application Container Engine.</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 调试</span></span><br><span class="line">[root@localhost ~]# dockerd --debug                                </span><br><span class="line">...</span><br><span class="line">WARN[2024-07-31T09:21:50.599480393+08:00] could not create bridge network <span class="keyword">for</span> <span class="built_in">id</span> 20e6fbfeebea5ebc9eb3be5e518399a886084976f33980d8d42ef4ee13401c34 bridge name docker0 <span class="keyword">while</span> booting up from persistent state: Failed to program NAT chain: ZONE_CONFLICT: <span class="string">&#x27;docker0&#x27;</span> already bound to a zone </span><br><span class="line">...</span><br><span class="line">failed to start daemon: Error initializing network controller: error creating default <span class="string">&quot;bridge&quot;</span> network: Failed to program NAT chain: ZONE_CONFLICT: <span class="string">&#x27;docker0&#x27;</span> already bound to a zone</span><br></pre></td></tr></table></figure>

<p>问题定位和解决:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取当前活动的防火墙区域（zones）信息</span></span><br><span class="line">[root@localhost ~]# firewall-cmd --get-active-zones</span><br><span class="line">public</span><br><span class="line">  interfaces: ens160</span><br><span class="line">trusted</span><br><span class="line">  interfaces: docker0</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 移除docker0</span></span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --permanent --zone=trusted --remove-interface=docker0</span><br><span class="line"><span class="comment"># 重启防火墙</span></span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --reload</span><br><span class="line"><span class="comment"># 删除daemon 或备份到别的地方</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /etc/docker/daemon.json</span><br><span class="line"><span class="comment"># 重启docker</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>发现启动还是报错，继续dockerd –debug，现在报错如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">failed to start daemon: Error initializing network controller: error creating default <span class="string">&quot;bridge&quot;</span> network: cannot create network 96b0b8273474a5cdf644ad11bf60c5f0a752ee63d05a5af6d22c433af6a4c4b2 (docker0): conflicts with network 20e6fbfeebea5ebc9eb3be5e518399a886084976f33980d8d42ef4ee13401c34 (docker0): networks have same bridge name</span><br></pre></td></tr></table></figure>

<p>怀疑问题出在<code>/var/docker/network/</code>，有很多socket存储在bridge上，这些socket都是用bridge的旧 ID 引用的。删除所有的套接字，删除接口，然后启动 docker，但所有容器都会因为套接字消失而无法工作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip <span class="built_in">link</span> del docker0</span><br><span class="line"><span class="built_in">rm</span> -rf /var/docker/network/*</span><br><span class="line"><span class="comment"># sudo rm -rf /var/lib/docker/network</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /var/docker/network/files</span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="comment"># delete all containers</span></span><br><span class="line">docker ps -a | <span class="built_in">cut</span> -d<span class="string">&#x27; &#x27;</span> -f 1 | xargs -n 1 <span class="built_in">echo</span> docker <span class="built_in">rm</span>  -f</span><br><span class="line"><span class="comment"># recreate all containers</span></span><br></pre></td></tr></table></figure>

<hr>
<p>2、使用非root用户启动报错</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ dockerd --debug</span><br><span class="line">dockerd needs to be started with root privileges. To run dockerd <span class="keyword">in</span> rootless mode as an unprivileged user, see https://docs.docker.com/go/rootless/</span><br></pre></td></tr></table></figure>

<p>运行 Docker 守护程序（dockerd）通常需要 root 权限，但也可以以非特权用户的身份运行，这被称为 rootless 模式。在 rootless 模式下，你可以在没有 root 权限的情况下安全地运行 Docker。Docker 的 rootless 模式支持是从 Docker <strong>19.03</strong> 版本开始引入的，几乎所有比较新的 Docker 版本都支持。</p>
<ul>
<li><p>在普通用户的环境中，设置必要的环境变量，将以下内容添加到用户的 <code>~/.bashrc</code> 或 <code>~/.bash_profile</code> 中，加在最后</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> DOCKER_HOST=unix://<span class="variable">$HOME</span>/.docker/run/docker.sock</span><br></pre></td></tr></table></figure>
</li>
<li><p>使配置生效</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"><span class="comment"># 验证配置生效</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$DOCKER_HOST</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化 Docker rootless 环境</p>
<p>创建必要的目录和配置文件，生成一个 <code>dockerd-rootless.sh</code> 脚本，用于启动 <code>Docker rootless</code> 守护程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ dockerd-rootless-setuptool.sh install --force</span><br><span class="line"><span class="comment"># [ERROR] Aborting because rootful Docker (/var/run/docker.sock) is running and accessible. Set --force to ignore</span></span><br><span class="line"><span class="comment"># 解决：停止和清理已有的 Docker 进程</span></span><br><span class="line"><span class="comment"># sudo systemctl stop docker</span></span><br><span class="line"><span class="comment"># sudo rm -rf /var/run/docker*</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动 Docker rootless 守护程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl --user start docker</span><br><span class="line"># 或者手动执行生成的dockerd-rootless.sh脚本</span><br><span class="line">$HOME/bin/dockerd-rootless.sh --experimental</span><br></pre></td></tr></table></figure>


</li>
<li></li>
</ul>
<hr>
<p>使用k8s时，最好修改docker cgroup驱动，与k8s一致，使用systemd</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改docker cgroup驱动：native.cgroupdriver=systemd</span></span><br><span class="line"><span class="comment"># 镜像加速：https://github.com/dongyubin/DockerHub?tab=readme-ov-file</span></span><br><span class="line"><span class="built_in">cat</span> &gt; /etc/docker/daemon.json &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],</span></span><br><span class="line"><span class="string">  &quot;log-driver&quot;: &quot;json-file&quot;,</span></span><br><span class="line"><span class="string">  &quot;log-opts&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;max-size&quot;: &quot;100m&quot;</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  &quot;registry-mirrors&quot;: [</span></span><br><span class="line"><span class="string">	&quot;https://hub-mirror.c.163.com/&quot;</span></span><br><span class="line"><span class="string">	&quot;https://docker.mirrors.ustc.edu.cn/&quot;</span></span><br><span class="line"><span class="string">	&quot;https://reg-mirror.qiniu.com&quot;</span></span><br><span class="line"><span class="string">	&quot;https://registry.docker-cn.com&quot;</span></span><br><span class="line"><span class="string">  	&quot;https://docker.mrxn.net&quot;,</span></span><br><span class="line"><span class="string">  	&quot;https://dockerhub.icu&quot;,</span></span><br><span class="line"><span class="string">  	&quot;https://doublezonline.cloud&quot;,</span></span><br><span class="line"><span class="string">  	&quot;https://docker.mrxn.net&quot;</span></span><br><span class="line"><span class="string">  ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="comment"># 重启使配置生效</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br><span class="line"><span class="comment"># 验证生效</span></span><br><span class="line">docker info</span><br></pre></td></tr></table></figure>



<h4 id="3、安装kubectl"><a href="#3、安装kubectl" class="headerlink" title="3、安装kubectl"></a>3、安装kubectl</h4><p>安装最新版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -LO https://storage.googleapis.com/kubernetes-release/release/`curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt`/bin/linux/amd64/kubectl</span><br></pre></td></tr></table></figure>

<p>安装指定版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -LO https://storage.googleapis.com/kubernetes-release/release/v1.17.0/bin/linux/amd64/kubectl</span><br></pre></td></tr></table></figure>

<p>把安装包移动到path目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> ./kubectl /usr/local/bin/kubectl</span><br></pre></td></tr></table></figure>

<p>增加执行权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x kubectl</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="kubernetes"><a href="#kubernetes" class="headerlink" title="kubernetes"></a>kubernetes</h2><p><strong>官方文档</strong>：<a href="https://kubernetes.io/zh-cn/docs/home/">Kubernetes 文档 | Kubernetes</a></p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Kubernetes 是一个可移植、可扩展的开源平台，用于管理容器化的工作负载和服务，方便进行声明式配置和自动化。</p>
<h3 id="MiniKube"><a href="#MiniKube" class="headerlink" title="MiniKube"></a>MiniKube</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>Linux安装，选择对应cpu架构版本，通过<code>lscpu</code>命令查询cpu架构，其余架构类推</p>
<p>X86-64架构</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64</span><br><span class="line"><span class="built_in">sudo</span> install minikube-linux-amd64 /usr/local/bin/minikube &amp;&amp; <span class="built_in">rm</span> minikube-linux-amd64</span><br></pre></td></tr></table></figure>

<p>ARM64架构</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-arm64</span><br><span class="line"><span class="built_in">sudo</span> install minikube-linux-arm64 /usr/local/bin/minikube &amp;&amp; <span class="built_in">rm</span> minikube-linux-arm64</span><br></pre></td></tr></table></figure>

<h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p><strong>注意：无法使用root启动</strong>，添加<code>test</code>用户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adduser <span class="built_in">test</span></span><br><span class="line">passwd <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 切换普通用户</span></span><br><span class="line">su - username</span><br><span class="line"><span class="comment"># 切换root，要求输入root密码</span></span><br><span class="line">su -</span><br></pre></td></tr></table></figure>

<blockquote>
<p>普通用户执行sudo 命令报错：test 不在 sudoers 文件中。此事将被报告。</p>
<p>在root用户下执行 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ll /etc/sudoers</span></span><br><span class="line"><span class="comment"># 给root用户加可写权限</span></span><br><span class="line"><span class="built_in">chmod</span> 640 /etc/sudoers</span><br><span class="line"><span class="comment"># 修改文件</span></span><br><span class="line">vim /etc/sudoers</span><br><span class="line"><span class="comment"># 搜索文本：## Allow root to run any commands anywhere</span></span><br><span class="line"><span class="comment"># 在root下加入 test ALL=(ALL) ALL</span></span><br><span class="line"><span class="comment"># 还原权限</span></span><br><span class="line"><span class="built_in">chmod</span> 440 /etc/sudoers</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">minikube start</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line"><span class="comment"># minikube start --vm-driver=docker --base-image=&quot;anjone/kicbase&quot; --image-mirror-country=&#x27;cn&#x27; --kubernetes-version=v1.22.3</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@172-12-0-1 ~]# minikube start</span><br><span class="line">* Centos 8.5.2111 上的 minikube v1.33.1</span><br><span class="line">* 根据用户配置使用 docker 驱动程序</span><br><span class="line">* The <span class="string">&quot;docker&quot;</span> driver should not be used with root privileges. If you wish to <span class="built_in">continue</span> as root, use --force.</span><br><span class="line">* 如果您在VM中运行 minikube，请考虑使用 --driver=none:</span><br><span class="line">*   https://minikube.sigs.k8s.io/docs/reference/drivers/none/</span><br><span class="line"></span><br><span class="line">X 因 DRV_AS_ROOT 错误而退出：docker 驱动不应使用 root 权限。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原因：root账号启动docker导致无法启动</p>
</blockquote>
<blockquote>
<p>解决：先用root用户关闭docker，然后用test用户启动</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 停用</span></span><br><span class="line">systemctl stop docker</span><br><span class="line"><span class="comment"># 启用</span></span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 停用报错：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@172-12-0-1 ~]# systemctl stop docker</span><br><span class="line">Warning: Stopping docker.service, but it can still be activated by:</span><br><span class="line">  docker.socket</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原因：docker默认开启自动唤醒机制，在关闭状态下被访问会自动唤醒docker</p>
</blockquote>
<blockquote>
<p>解决：停用自动唤醒机制</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 停用自动唤醒机制</span><br><span class="line">systemctl stop docker.socket</span><br><span class="line"># 停用docker</span><br><span class="line">systemctl stop docker</span><br><span class="line"># 启用</span><br><span class="line">systemctl start docker.socket</span><br></pre></td></tr></table></figure>

<hr>
<p>再次启用<code>minikube</code>，还是报错</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ minikube start</span><br><span class="line">* Centos 8.5.2111 上的 minikube v1.33.1</span><br><span class="line">* Unable to pick a default driver. Here is what was considered, <span class="keyword">in</span> preference order:</span><br><span class="line">  - docker: Not healthy: <span class="string">&quot;docker version --format &#123;&#123;.Server.Os&#125;&#125;-&#123;&#123;.Server.Version&#125;&#125;:&#123;&#123;.Server.Platform.Name&#125;&#125;&quot;</span> <span class="built_in">exit</span> status 1: permission denied <span class="keyword">while</span> trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get <span class="string">&quot;http://%2Fvar%2Frun%2Fdocker.sock/v1.45/version&quot;</span>: dial unix /var/run/docker.sock: connect: permission denied</span><br><span class="line">  - docker：建议：Add your user to the <span class="string">&#x27;docker&#x27;</span> group: <span class="string">&#x27;sudo usermod -aG docker $USER &amp;&amp; newgrp docker&#x27;</span> &lt;https://docs.docker.com/engine/install/linux-postinstall/&gt;</span><br><span class="line">* 或者你也可以安装以下驱动程序：</span><br><span class="line">  - kvm2: Not installed: <span class="built_in">exec</span>: <span class="string">&quot;virsh&quot;</span>: executable file not found <span class="keyword">in</span> <span class="variable">$PATH</span></span><br><span class="line">  - qemu2: Not installed: <span class="built_in">exec</span>: <span class="string">&quot;qemu-system-x86_64&quot;</span>: executable file not found <span class="keyword">in</span> <span class="variable">$PATH</span></span><br><span class="line">  - podman: Not installed: <span class="built_in">exec</span>: <span class="string">&quot;podman&quot;</span>: executable file not found <span class="keyword">in</span> <span class="variable">$PATH</span></span><br><span class="line">  - virtualbox: Not installed: unable to find VBoxManage <span class="keyword">in</span> <span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line">X 因 DRV_NOT_HEALTHY 错误而退出：找到个驱动程序，但没有一个是健康的。有关如何修复已安装的驱动程序的建议，请参阅上文。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原因：需要docker组启动</p>
</blockquote>
<blockquote>
<p>解决：将test用户加入docker组</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建docker组</span></span><br><span class="line"><span class="built_in">sudo</span> groupadd docker</span><br><span class="line"><span class="comment"># 将test用户添加到docker组</span></span><br><span class="line"><span class="built_in">sudo</span> usermod -aG docker <span class="variable">$USER</span></span><br><span class="line"><span class="comment"># 切换root用户设置docker组密码</span></span><br><span class="line">su -</span><br><span class="line">gpasswd docker</span><br><span class="line"><span class="comment"># test用户激活对组的修改</span></span><br><span class="line">su - <span class="built_in">test</span></span><br><span class="line">newgrp docker</span><br></pre></td></tr></table></figure>

<p>再次运行<code>minikube start</code>，会下载<code>Kubernetes</code> 的预加载文件，下载image失败</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">E0731 11:24:42.377184    4531 cache.go:189] Error downloading kic artifacts:  failed to download kic base image or any fallback image</span><br><span class="line">...</span><br><span class="line">X 因 GUEST_PROVISION 错误而退出：error provisioning guest: Failed to start host: recreate: creating host: create: creating: setting up container node: preparing volume <span class="keyword">for</span> minikube container: docker run --<span class="built_in">rm</span> --name minikube-preload-sidecar --label created_by.minikube.sigs.k8s.io=<span class="literal">true</span> --label name.minikube.sigs.k8s.io=minikube --entrypoint /usr/bin/test -v minikube:/var gcr.io/k8s-minikube/kicbase:v0.0.44@sha256:eb04641328b06c5c4a14f4348470e1046bbcf9c2cbc551486e343d3a49db557e -d /var/lib: <span class="built_in">exit</span> status 125</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原因：1、k8s使用的docker Registry是google container register，在国内无法访问，所以image会拉取失败</p>
<p>2、因为有个镜像下载不下来，这个镜像不是从阿里云上下载的 gcr.io&#x2F;k8s-minikube&#x2F;kicbase:v0.0.10</p>
</blockquote>
<blockquote>
<p>解决：1、start 命令后添加镜像地区参数</p>
<p>2、查找替代的镜像，比如anjone&#x2F;kicbase</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 上边拉取失败，删除iamge</span></span><br><span class="line">minikube delete</span><br><span class="line"><span class="comment">#下载对应镜像</span></span><br><span class="line">docker pull anjone/kicbase</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">minikube start --vm-driver=docker --base-image=<span class="string">&quot;anjone/kicbase&quot;</span> --image-mirror-country=<span class="string">&#x27;cn&#x27;</span> --kubernetes-version=v1.22.3</span><br></pre></td></tr></table></figure>

<p>启动成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">* 正在验证 Kubernetes 组件...</span><br><span class="line">  - 正在使用镜像 registry.cn-hangzhou.aliyuncs.com/google_containers/storage-provisioner:v5</span><br><span class="line">* 启用插件： storage-provisioner, default-storageclass</span><br><span class="line">* kubectl 未找到。如果你需要使用它，请尝试：<span class="string">&#x27;minikube kubectl -- get pods -A&#x27;</span></span><br><span class="line">* 完成！kubectl 现在已配置，默认使用<span class="string">&quot;minikube&quot;</span>集群和<span class="string">&quot;default&quot;</span>命名空间</span><br></pre></td></tr></table></figure>

<p>验证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ minikube kubectl -- get pods -A</span><br><span class="line"></span><br><span class="line">NAMESPACE     NAME                               READY   STATUS             RESTARTS      AGE</span><br><span class="line">kube-system   coredns-7d89d9b6b8-vwcrc           0/1     CrashLoopBackOff   3 (35s ago)   95s</span><br><span class="line">kube-system   etcd-minikube                      1/1     Running            0             107s</span><br><span class="line">kube-system   kube-apiserver-minikube            1/1     Running            0             107s</span><br><span class="line">kube-system   kube-controller-manager-minikube   1/1     Running            0             107s</span><br><span class="line">kube-system   kube-proxy-ws9cw                   1/1     Running            0             95s</span><br><span class="line">kube-system   kube-scheduler-minikube            1/1     Running            0             107s</span><br><span class="line">kube-system   storage-provisioner                1/1     Running            1 (73s ago)   106s</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动Dashboard</span></span><br><span class="line">minikube dashboard</span><br></pre></td></tr></table></figure>

<blockquote>
<p>启动失败：一直卡在 <code>正在验证 proxy 运行状况 ...</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启用Dashboard（默认是disabled的）</span></span><br><span class="line"><span class="comment"># Dashboard是kubernetes addon,Addons是利用kubernetes的资源（DaemonSet, Deployment等）实现的，在整个集群层面的上功能(cluster feature)</span></span><br><span class="line">minikube addons list</span><br><span class="line"><span class="comment"># 启用Dashboard</span></span><br><span class="line">minikube addons <span class="built_in">enable</span> dashboard</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看更详细的报错信息</span><br><span class="line">minikube dashboard --alsologtostderr -v=1</span><br><span class="line"># 发现启动一直报 503 错误，然后不断地重试</span><br><span class="line"># 执行以下命令查看所有pod，发现 kubernetes-dashboard 一直没启动成功，在不断地重试</span><br><span class="line">minikube kubectl -- get pods -A</span><br><span class="line"># 执行如下命令查看该 Pod 的 log</span><br><span class="line">kubectl logs --namespace=kubernetes-dashboard kubernetes-dashboard-744fc84fb7-bxkmq</span><br><span class="line"># Error from server (BadRequest): container &quot;kubernetes-dashboard&quot; in pod &quot;kubernetes-dashboard-744fc84fb7-bxkmq&quot; is waiting to start: trying and failing to pull image</span><br><span class="line">kubectl describe pod kubernetes-dashboard-744fc84fb7-bxkmq --namespace kubernetes-dashboard</span><br></pre></td></tr></table></figure>

<ul>
<li>拉取metrics-scraper镜像</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 手动pull</span></span><br><span class="line"><span class="comment"># https://github.com/kubernetes-sigs/dashboard-metrics-scraper查看最新版本</span></span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/metrics-scraper:v1.0.8</span><br><span class="line"></span><br><span class="line"><span class="comment">#打上tag</span></span><br><span class="line">docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/metrics-scraper:v1.0.8 docker.io/kubernetesui/metrics-scraper:v1.0.8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将镜像导入minikube</span></span><br><span class="line">minikube image load kubernetesui/metrics-scraper:v1.0.</span><br><span class="line"></span><br><span class="line"><span class="comment">#重新生成pod</span></span><br><span class="line"><span class="comment"># kubectl delete pod -n &lt;podNameSpace&gt; &lt;podName&gt;</span></span><br><span class="line">kubectl delete pod -n kubernetes-dashboard dashboard-metrics-scraper-687748788c-bczzs</span><br></pre></td></tr></table></figure>

<ul>
<li>拉取dashboard镜像</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#手动pull</span></span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/dashboard:v2.7.0</span><br><span class="line"></span><br><span class="line"><span class="comment">#打上tag</span></span><br><span class="line">docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/dashboard:v2.7.0 kubernetesui/dashboard:v2.7.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将镜像导入minikube</span></span><br><span class="line">minikube image load kubernetesui/dashboard:v2.7.0</span><br><span class="line"></span><br><span class="line"><span class="comment">#重新生成pod</span></span><br><span class="line">kubectl delete pod -n kubernetes-dashboard dkubernetes-dashboard-744fc84fb7-bxkmq</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不知道怎么查看镜像最新版本，后面再补充，可能要登录阿里云控制台</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker search registry.cn-hangzhou.aliyuncs.com/google_containers/&lt;镜像名&gt;</span><br></pre></td></tr></table></figure>

<p>这种方式报错：Error response from daemon: Unexpected status code 404</p>
</blockquote>
<p>再次检查pod状态：<code>minikube kubectl -- get pods -A</code>，发现pod正常了</p>
<p>使用 <code>minikube dashboard</code>启动，<a href="http://127.0.0.1:42975/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/">http://127.0.0.1:42975/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/</a></p>
</blockquote>
<blockquote>
<p>补充：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成 /etc/containerd/config.toml文件</span></span><br><span class="line">containerd config default &gt; /etc/containerd/config.toml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认使用的是官方源，很慢，需要换成国内源</span></span><br><span class="line"><span class="comment"># 修改配置文件：/etc/containerd/config.toml</span></span><br><span class="line"><span class="comment"># 在[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors]下边添加如下内容：</span></span><br><span class="line">[plugins.<span class="string">&quot;io.containerd.grpc.v1.cri&quot;</span>.registry.mirrors.<span class="string">&quot;docker.io&quot;</span>]</span><br><span class="line">  endpoint = [<span class="string">&quot;https://ustc-edu-cn.mirror.aliyuncs.com&quot;</span>, <span class="string">&quot;http://hub-mirror.c.163.com&quot;</span>, <span class="string">&quot;https://docker.mirrors.ustc.edu.cn/&quot;</span>]</span><br><span class="line">[plugins.<span class="string">&quot;io.containerd.grpc.v1.cri&quot;</span>.registry.mirrors.<span class="string">&quot;k8s.gcr.io&quot;</span>]</span><br><span class="line">  endpoint = [<span class="string">&quot;registry.cn-hangzhou.aliyuncs.com/google_containers&quot;</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重启containerd</span></span><br><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart containerd</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>重新启动后发现 <code>dashboard-metrics-scraper</code> 又拉取不了镜像了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看所有镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="comment"># 发现有两个一样的镜像</span></span><br><span class="line"><span class="comment"># kubernetesui/metrics-scraper                                          v1.0.9    ac9017206ce5   16 months ago   43.8MB</span></span><br><span class="line"><span class="comment"># registry.cn-hangzhou.aliyuncs.com/google_containers/metrics-scraper   v1.0.9    ac9017206ce5   16 months ago   43.8MB</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除镜像 image id 前3位就行</span></span><br><span class="line">docker rmi ac9</span><br><span class="line"><span class="comment"># 报错：Error response from daemon: conflict: unable to delete ac9017206ce5 (must be forced) - image is referenced in multiple repositories</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除多余的标签：如果镜像被多个标签引用，可以逐个删除这些标签来解决问题</span></span><br><span class="line"><span class="comment"># docker rmi -f repository/image:tag</span></span><br><span class="line">docker rmi -f kubernetesui/metrics-scraper:v1.0.9</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>minikube kubectl – get pods -A查看pod 发现 coredns CrashLoopBackOff 问题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ minikube kubectl -- get pods -A</span><br><span class="line">NAMESPACE             NAME          READY    STATUS         RESTARTS   AGE</span><br><span class="line">kube-system coredns-7d89d9b6b8-vwcrc 0/1 CrashLoopBackOff 50 (25s ago) 18h</span><br></pre></td></tr></table></figure>

<p>查看日志</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ kubectl logs -f coredns-7d89d9b6b8-vwcrc -n kube-system</span><br><span class="line"> [FATAL] plugin/loop: Loop (127.0.0.1:39174 -&gt; :53) detected <span class="keyword">for</span> zone <span class="string">&quot;.&quot;</span>, see https://coredns.io/plugins/loop#troubleshooting. Query: <span class="string">&quot;HINFO 1252716524163381999.4934294265190733081.&quot;</span></span><br><span class="line"> </span><br><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ kubectl describe pod coredns-7d89d9b6b8-vwcrc -n kube-system</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason   Age                     From     Message</span><br><span class="line">  ----     ------   ----                    ----     -------</span><br><span class="line">  Normal   Pulled   15h (x37 over 18h)      kubelet  Container image <span class="string">&quot;registry.cn-hangzhou.aliyuncs.com/google_containers/coredns:v1.8.4&quot;</span> already present on machine</span><br><span class="line">  Warning  BackOff  2m52s (x1078 over 18h)  kubelet  Back-off restarting failed container</span><br></pre></td></tr></table></figure>

<p>发现出现了Loop…detected…，这意味着<code>loop</code>检测插件已检测到上游 DNS 服务器之一中的无限转发循环</p>
<p>当 Kubernetes 中部署的 CoreDNS Pod 检测到循环时，CoreDNS Pod 将开始“CrashLoopBackOff”。 这是因为每次 CoreDNS 检测到循环并退出时，Kubernetes 都会尝试重新启动 Pod</p>
<p>转发循环通常由以下原因引起：</p>
<ul>
<li>最常见的是，CoreDNS 将请求直接转发给自身。例如，通过环回地址，例如127.0.0.1，::1或127.0.0.53</li>
<li>较不常见的是，CoreDNS转发到上游服务器，而上游服务器又将请求转发回CoreDNS。</li>
</ul>
<p>解决办法：</p>
<p>替换<code>forward . /etc/resolv.conf</code>为您上游 DNS 的 IP 地址，例如<code>forward . 8.8.8.8.</code> 但这只是解决了 CoreDNS 的问题，kubelet 会继续将无效的转发resolv.conf到所有defaultdnsPolicy Pod，让它们无法解析 DNS</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改系统/etc/resolv.conf文件</span></span><br><span class="line">$ vim /etc/resolv.conf</span><br><span class="line"><span class="comment"># 在文件后添加</span></span><br><span class="line">nameserver 8.8.8.8</span><br><span class="line">nameserver 8.8.4.4</span><br><span class="line"></span><br><span class="line">$ kubectl edit -n kube-system cm coredns</span><br><span class="line"><span class="comment"># Please edit the object below. Lines beginning with a &#x27;#&#x27; will be ignored,</span></span><br><span class="line"><span class="comment"># and an empty file will abort the edit. If an error occurs while saving this file will be</span></span><br><span class="line"><span class="comment"># reopened with the relevant failures.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">data:</span><br><span class="line">  Corefile: |</span><br><span class="line">    .:53 &#123;</span><br><span class="line">        <span class="built_in">log</span></span><br><span class="line">        errors</span><br><span class="line">        health &#123;</span><br><span class="line">           lameduck 5s</span><br><span class="line">        &#125;</span><br><span class="line">        ready</span><br><span class="line">        kubernetes cluster.local in-addr.arpa ip6.arpa &#123;</span><br><span class="line">           pods insecure</span><br><span class="line">           fallthrough in-addr.arpa ip6.arpa</span><br><span class="line">           ttl 30</span><br><span class="line">        &#125;</span><br><span class="line">        prometheus :9153</span><br><span class="line">        hosts &#123;</span><br><span class="line">           192.168.49.1 host.minikube.internal</span><br><span class="line">           fallthrough</span><br><span class="line">        &#125;</span><br><span class="line">        forward . /etc/resolv.conf &#123;</span><br><span class="line">           max_concurrent 1000</span><br><span class="line">        &#125;</span><br><span class="line">        cache 30</span><br><span class="line">        <span class="comment">#loop  // 注释这里</span></span><br><span class="line">        reload</span><br><span class="line">        loadbalance</span><br><span class="line">    &#125;</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: <span class="string">&quot;2024-07-31T07:10:41Z&quot;</span></span><br><span class="line">  name: coredns</span><br><span class="line">  namespace: kube-system</span><br><span class="line">  resourceVersion: <span class="string">&quot;22986&quot;</span></span><br><span class="line">  uid: 80c66b34-4e84-4f9c-b020-a87be7c5d3df</span><br></pre></td></tr></table></figure>

<p>将coredns的pod重新删除后就恢复正常</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl delete -n kube-system pod &lt;podName&gt;</span><br><span class="line"><span class="comment"># 验证，发现状态正常了</span></span><br><span class="line">$ minikube kubectl -- get pods -A</span><br></pre></td></tr></table></figure>
</blockquote>
<p>为Dashboard分配一个固定端口	</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># address为虚拟机ip， ip a指令查看ensXXX的inet</span><br><span class="line">kubectl proxy --address=&#x27;192.168.64.128&#x27; --accept-hosts=&#x27;^*$&#x27; --port=8001</span><br></pre></td></tr></table></figure>

<blockquote>
<p>端口占用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@172-12-0-1 ~]# kubectl proxy --address=<span class="string">&#x27;0.0.0.0&#x27;</span>  --accept-hosts=<span class="string">&#x27;^*$&#x27;</span> --port=8001</span><br><span class="line">error: listen tcp 0.0.0.0:8001: <span class="built_in">bind</span>: address already <span class="keyword">in</span> use</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装net-tools工具（netstat命令未找到的时候需要安装）</span></span><br><span class="line">yum install -y net-tools</span><br><span class="line"></span><br><span class="line"><span class="comment"># netstat -tulpn [| grep 8001]</span></span><br><span class="line">netstat -tulpn | grep 8001</span><br><span class="line"></span><br><span class="line">tcp6  0  0 	:::8001  	:::*  	LISTEN  	62614/kubectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 释放端口占用</span></span><br><span class="line"><span class="built_in">kill</span> -9 62614</span><br></pre></td></tr></table></figure>
</blockquote>
<p>访问<a href="http://192.168.64.128:8001/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/%E6%8A%A5%E9%94%99">http://192.168.64.128:8001/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/报错</a> <code>dial tcp 192.168.64.128:6443: connect: connection refused</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@172-12-0-1 ~]# kubectl proxy --address=<span class="string">&#x27;192.168.64.128&#x27;</span>  --accept-hosts=<span class="string">&#x27;^*$&#x27;</span> --port=8001</span><br><span class="line">Starting to serve on 192.168.64.128:8001</span><br><span class="line">E0801 10:55:04.678103  104769 proxy_server.go:147] Error <span class="keyword">while</span> proxying request: dial tcp 192.168.64.128:6443: connect: connection refused</span><br></pre></td></tr></table></figure>

<p>通常表示 <code>kubectl proxy</code> 无法连接到 Kubernetes API Server，可以从以下方面排查：</p>
<ul>
<li><p>Kubernetes API Server 未启动或不可访问</p>
<p>确保 Kubernetes 的 API Server 在 Minikube 中正常运行，如果状态为 <code>Running</code>，则 API Server 应该在运行中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ minikube status</span><br><span class="line">minikube</span><br><span class="line"><span class="built_in">type</span>: Control Plane</span><br><span class="line">host: Running</span><br><span class="line">kubelet: Running</span><br><span class="line">apiserver: Running</span><br><span class="line">kubeconfig: Configured</span><br></pre></td></tr></table></figure>
</li>
<li><p>网络配置问题</p>
<p>确保你的网络配置允许 <code>kubectl proxy</code> 访问 Minikube 的 API Server。有时可能需要调整防火墙或者网络策略以允许从你的机器（192.168.64.128）到 Minikube 虚拟机的6443端口的连接。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 确保防火墙打开</span></span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --state</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出当前的防火墙规则</span></span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --list-all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许访问6443端口</span></span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --zone=public --add-port=6443/tcp --permanent</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新加载防火墙设置</span></span><br><span class="line"><span class="built_in">sudo</span> firewall-cmd --reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证端口访问</span></span><br><span class="line">telnet 192.168.64.128 6443</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">nc -zv 192.168.64.128 6443</span><br></pre></td></tr></table></figure>
</li>
<li><p>kubectl 配置</p>
<p>确保 kubectl 配置正确指向 Minikube</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl config current-context</span><br></pre></td></tr></table></figure></li>
</ul>
<p>到这里应该可以正常启动dashboard了，浏览器访问：<a href="http://192.168.64.128:8001/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/">http://192.168.64.128:8001/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/</a></p>
<hr>
<h3 id="部署应用"><a href="#部署应用" class="headerlink" title="部署应用"></a>部署应用</h3><h4 id="nginx部署"><a href="#nginx部署" class="headerlink" title="nginx部署"></a>nginx部署</h4><p>使用 <code>kubectl create</code> 命令创建管理 Pod 的 Deployment。该 Pod 根据提供的 Docker 镜像运行 Container</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 需要先拉取nginx镜像</span></span><br><span class="line">$ docker pull nginx:latest</span><br><span class="line">$ minikube image load nginx:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行一个名称为 nginx-deployment 的 pod 作为 nginx 镜像的 Deployment</span></span><br><span class="line">$ kubectl create deployment nginx-deployment --image=nginx:latest</span><br><span class="line">$ kubectl get deployment nginx-deployment -o yaml &gt; deployment.yaml</span><br><span class="line"><span class="comment"># 编辑生成的 deployment.yaml 文件，找到 containers 部分，修改 imagePullPolicy 为 Never。</span></span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">    - name: nginx</span><br><span class="line">      image: nginx:latest</span><br><span class="line">      imagePullPolicy: Never</span><br><span class="line">      ...</span><br><span class="line">      </span><br><span class="line"><span class="comment"># 删除 Deployment</span></span><br><span class="line">$ kubectl delete -n default deployment nginx-deployment</span><br><span class="line"><span class="comment"># 应用更新</span></span><br><span class="line">$ kubectl apply -f deployment.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Deployment</span></span><br><span class="line">kubectl get deployments</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Pod</span></span><br><span class="line">kubectl get pods</span><br><span class="line"><span class="comment"># 删除 Pod</span></span><br><span class="line"><span class="comment"># kubectl delete -n default pod hello-nginx-557d767db6-zgtjf</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 状态变成Ready代表可用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看集群事件</span></span><br><span class="line">kubectl get events</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 kubectl 配置</span></span><br><span class="line">kubectl config view</span><br></pre></td></tr></table></figure>

<p>nginx 运行成功</p>
<p><a href="https://imgse.com/i/pkj9q41"><img src="https://s21.ax1x.com/2024/08/02/pkj9q41.png" alt="pkj9q41.png"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl expose deployment nginx --port=80 --target-port=80 --type=NodePort</span><br><span class="line"></span><br><span class="line">minikube service nginx-deployment --url</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>微服务学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim使用教程</title>
    <url>/2024/07/29/Vim%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>[TOC] </p>
<h2 id="Vim使用教程"><a href="#Vim使用教程" class="headerlink" title="Vim使用教程"></a>Vim使用教程</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h3><p>一款高度可配置的文本编辑器。</p>
<h3 id="Vim模式"><a href="#Vim模式" class="headerlink" title="Vim模式"></a><strong>Vim模式</strong></h3><h4 id="1、常规模式"><a href="#1、常规模式" class="headerlink" title="1、常规模式"></a><strong>1、常规模式</strong></h4><p>启动编辑器时默认就处于此模式，以下是一些可以在常规模式下使用到的基本命令：</p>
<ul>
<li><strong>移动</strong>：<ul>
<li>方向键</li>
<li><code>h</code> ：左</li>
<li><code>l</code>  ：右</li>
<li><code>j</code>  ：下</li>
<li><code>k</code> ：上</li>
</ul>
</li>
<li><strong>插入：</strong><ul>
<li><code>i</code> ：在光标处插入文本</li>
<li><code>a</code> ：在光标后插入文本</li>
<li><code>A</code> ：在行尾开始插入文本</li>
<li><code>I</code> ： 在行首插入文本</li>
<li><code>o</code> ：在当前行后插入一个新行</li>
<li><code>O</code> ：在当前行前插入一个新行</li>
</ul>
</li>
<li><strong>删除：</strong><ul>
<li><code>x</code> ：删除光标处的文本</li>
<li><code>X</code> ：删除光标前的一个文本，相当于<code>BackSpace</code>键</li>
</ul>
</li>
<li><strong>修改：</strong><ul>
<li><code>r</code> ：替换光标处文本</li>
<li><code>R</code> ：使用寄存器替换光标处文本，可以修改光标后的文本，相当于<code>Insert</code>键</li>
</ul>
</li>
<li><strong>复制和粘贴：</strong><ul>
<li><code>yy</code> ：将文本剪切到剪贴板</li>
<li><code>Y</code>：将一行文本剪切到剪贴板</li>
<li><code>p</code> ：在当前行前粘贴剪贴板的文本</li>
<li><code>P</code>：在当前行后粘贴剪贴板的文本</li>
</ul>
</li>
<li><strong>其他：</strong><ul>
<li>. ：重复上一个命令</li>
<li>$ ：移至行尾</li>
<li>^ ：移至行首</li>
</ul>
</li>
<li></li>
<li></li>
</ul>
<h4 id="2、可视模式"><a href="#2、可视模式" class="headerlink" title="2、可视模式"></a>2、<strong>可视模式</strong></h4><p>按<code>v</code>键进入可视模式，以下是在可视模式中可以使用的一些基本命令：</p>
<ul>
<li><strong>选择：</strong><ul>
<li>方向键</li>
<li><code>h</code>：左</li>
<li><code>l</code>：右</li>
<li><code>j</code>：下</li>
<li><code>k</code>：上</li>
<li><code>V</code>：选择行</li>
<li><code>v</code>：选择字符</li>
</ul>
</li>
<li><strong>删除：</strong><ul>
<li><code>x</code> ：删除选定的文本</li>
<li><code>X</code> ：删除光标所在行</li>
</ul>
</li>
<li><strong>复制和粘贴：</strong><ul>
<li><code>y</code> ：复制选定的文本</li>
<li><code>Y</code> ：复制一整行文本</li>
<li><code>p</code> ：在当前行之前粘贴剪贴板中的文本</li>
<li><code>P</code> ：在当前行之后粘贴剪贴板中的文本</li>
</ul>
</li>
<li>其他：<ul>
<li><code>.</code> ：重复上一个命令</li>
<li><code>G</code> ：移至文件末尾</li>
<li><code>gg</code> ：移至文件开头</li>
<li><code>^</code> ：移至行首</li>
<li><code>$</code> ：移至行尾</li>
<li><code>%</code> ：更改后重复上一个命令</li>
</ul>
</li>
</ul>
<h4 id="3、选择模式"><a href="#3、选择模式" class="headerlink" title="3、选择模式"></a><strong>3、选择模式</strong></h4><p>选择模式看起来像可视模式，在最后一行会显示<code>– 选择 –</code>。</p>
<p>进入选择模式：</p>
<ul>
<li>从可视化模式，按下 <code>CTRL + G</code>。</li>
</ul>
<p>以下是可以用于选择模式的一些基本命令：</p>
<ul>
<li>可打印字符、 和 会导致删除选定内容，Vim 进入插入模式。插入所键入字符。</li>
<li>不可打印的移动命令，同时按下 Shift 键，会扩展所选内容。“keymodel”必须包含“startsel”。</li>
<li>不可打印的移动命令，未按下 Shift 键，会停止选择模式。“keymodel”必须包含“stopsel”。</li>
<li><code>CTRL + O</code> 在一个命令的持续时间内切换至可视化模式</li>
<li><code>CTRL + G</code> 切换至可视模式。</li>
</ul>
<h4 id="4、插入模式"><a href="#4、插入模式" class="headerlink" title="4、插入模式"></a><strong>4、插入模式</strong></h4><p>按 <code>i</code> 键进入插入模式，在插入模式中可以<strong>添加</strong>新文本或<strong>修改</strong>文本。</p>
<p>以下是一些可以在插入模式下使用到的基本命令：</p>
<ul>
<li>插入：<ul>
<li><code>a</code> ：在光标后插入文本。</li>
<li><code>A</code> ：在行尾开始插入文本。</li>
<li><code>I</code> ：在行首插入文本。</li>
<li><code>o</code> ：在当前行后插入一个新行。</li>
<li><code>O</code> ：在当前行前插入一个新行。</li>
</ul>
</li>
<li>其他：<ul>
<li><code>Esc</code> ：退出插入模式并返回常规模式。</li>
</ul>
</li>
</ul>
<h4 id="5、命令模式"><a href="#5、命令模式" class="headerlink" title="5、命令模式"></a><strong>5、命令模式</strong></h4><p>按 <code>:</code> 键将进入命令模式，可以在其中输入 Vim 命令。</p>
<p>以下是在命令模式中可以使用的一些基本命令：</p>
<ul>
<li><code>:w</code> ：在不退出 Vim 的情况下写入或保存文件</li>
<li><code>:q</code> ：退出 Vim。如果有未保存的更改，系统会提示您放弃它们</li>
<li><code>:q!</code>：不保存任何更改而退出 Vim</li>
<li><code>:qa!</code> ： 退出所有窗口并放弃所有未保存的更改</li>
<li><code>:e filename</code> ：打开一个新文件进行编辑</li>
<li><code>:r filename</code> ：在光标位置读取或插入文件的内容</li>
<li><code>/pattern</code> ：在文件中搜索模式。按 <code>n</code> 移动到模式的下一个出现处，按 <code>N</code> 移动到上一个出现处</li>
<li><code>:set paste</code> ：进入粘贴模式，以防止从 Vim 外部粘贴文本时自动缩进</li>
<li><code>:set number</code> 或 <code>:set nu</code> ：在左页边距显示行号</li>
<li><code>:set spell</code> ：为当前文件启用拼写检查</li>
<li><code>:set nospell</code> ：禁用拼写检查</li>
<li><code>:s/old/new/g</code> ：将当前行中的所有<code>old</code>替换为<code>new</code>。使用计数，例如<code>:s/old/new/g 3</code>，以应用替换三次</li>
<li><code>:g/pattern/d</code> ：删除所有与模式匹配的行</li>
</ul>
<h4 id="6-Ex-模式"><a href="#6-Ex-模式" class="headerlink" title="6. Ex 模式"></a>6. <strong>Ex 模式</strong></h4><p>按<code>Q</code>键将进入 ex 模式，可以在 ex 模式中执行 Vim 命令，命令执行后不会离开命令模式，可以继续输入命令并执行。</p>
<h3 id="导航"><a href="#导航" class="headerlink" title="导航"></a><strong>导航</strong></h3><h4 id="在文件中移动"><a href="#在文件中移动" class="headerlink" title="在文件中移动"></a><strong>在文件中移动</strong></h4><ul>
<li><code>h</code> ：光标向左移动</li>
<li><code>l</code> ：光标向右移动</li>
<li><code>j</code> ：光标向下移动</li>
<li><code>k</code> ：光标向上移动</li>
<li><code>0</code>（零）：将光标移到行首</li>
<li><code>^</code> ：将光标移到该行的第一个非空白字符</li>
<li><code>$</code> ：将光标移到该行的末尾</li>
<li><code>g_</code> ：将光标移到该行的最后一个非空白字符</li>
<li><code>G</code>：将光标移到文件的最后一行</li>
<li><code>gg</code>：将光标移到文件的首行</li>
<li><code>Ctrl + D</code> ：向下滚动半屏</li>
<li><code>Ctrl + U</code> ：向上滚动半屏</li>
<li><code>Ctrl + F</code> ：向前移动整个屏幕</li>
<li><code>Ctrl + B</code> ：向后移动整个屏幕</li>
<li><code>H</code> ：将光标移到屏幕顶部</li>
<li><code>M</code> ：将光标移到屏幕中间</li>
<li><code>L</code> ：将光标移到屏幕底部</li>
</ul>
<h4 id="跳转到特定行或单词"><a href="#跳转到特定行或单词" class="headerlink" title="跳转到特定行或单词"></a><strong>跳转到特定行或单词</strong></h4><ul>
<li><code>10G</code> | <code>10gg</code> | <code>:10</code>：跳转到第 10 行</li>
<li><code>*</code>：搜索光标下的单词</li>
<li><code>#</code>：向后搜索光标下的单词</li>
</ul>
<h4 id="在搜索结果中移动"><a href="#在搜索结果中移动" class="headerlink" title="在搜索结果中移动"></a><strong>在搜索结果中移动</strong></h4><ul>
<li><code>/foo</code> : 查找<code>foo</code></li>
<li><code>n</code>：将光标移到下一个匹配项（向前）</li>
<li><code>N</code>：将光标移到上一个匹配项（向后）</li>
</ul>
<h3 id="文本编辑"><a href="#文本编辑" class="headerlink" title="文本编辑"></a><strong>文本编辑</strong></h3><h4 id="插入和追加文本"><a href="#插入和追加文本" class="headerlink" title="插入和追加文本"></a><strong>插入和追加文本</strong></h4><ul>
<li><code>i</code> ：在光标前插入文本</li>
<li><code>I </code>：在行的开头插入文本</li>
<li><code>a</code> ：在光标后追加文本</li>
<li><code>A</code> ：在行的末尾追加文本</li>
</ul>
<h4 id="编辑行"><a href="#编辑行" class="headerlink" title="编辑行"></a><strong>编辑行</strong></h4><ul>
<li><code>J</code> ：将当前行与下一行连接</li>
<li><code>cc</code> | <code>S</code> ：更改整行内容（删除并进入插入模式）</li>
<li><code>cw</code> ：更改光标下的单词（删除并进入插入模式）</li>
<li><code>C</code> ：从光标位置更改剩余行（删除并进入插入模式）</li>
<li><code>r</code> ：用另一个字符替换光标下的单个字符</li>
<li><code>R</code> ：输入替换模式；替换多个字符，直到按 <code>Esc</code></li>
<li><code>g~</code> ：反转光标下字符的大小写</li>
</ul>
<h4 id="删除文本"><a href="#删除文本" class="headerlink" title="删除文本"></a><strong>删除文本</strong></h4><ul>
<li><code>x</code>：删除光标下的字符</li>
<li><code>X</code>：删除光标前的字符</li>
<li><code>dd</code>：删除整行</li>
<li><code>D</code>：从光标位置删除剩余行（剪切），光标所在字符也会被删除</li>
<li><code>cw</code>：更改光标下的单词（删除并进入插入模式）</li>
</ul>
<h4 id="复制和粘贴文本"><a href="#复制和粘贴文本" class="headerlink" title="复制和粘贴文本"></a><strong>复制和粘贴文本</strong></h4><ul>
<li><code>yy</code>：将整行内容剪切（复制）到默认寄存器</li>
<li><code>yw</code>：将光标下的单词剪切（复制）到默认寄存器</li>
<li><code>p</code>：在光标位置前粘贴默认寄存器的内容</li>
<li><code>P</code>：在光标位置后粘贴默认寄存器的内容</li>
</ul>
<h4 id="撤销和重做更改"><a href="#撤销和重做更改" class="headerlink" title="撤销和重做更改"></a><strong>撤销和重做更改</strong></h4><ul>
<li><code>u</code>：撤销对文件进行的最后一次更改</li>
<li><code>Ctrl + R</code> ：重做最后一次撤销的更改</li>
</ul>
<h3 id="搜索和替换文本"><a href="#搜索和替换文本" class="headerlink" title="搜索和替换文本"></a><strong>搜索和替换文本</strong></h3><h4 id="基本搜索命令"><a href="#基本搜索命令" class="headerlink" title="基本搜索命令"></a><strong>基本搜索命令</strong></h4><ul>
<li><code>/foo</code>：<strong>向后</strong>搜索单词 <code>foo</code></li>
<li><code>?bar</code>：<strong>向前</strong>搜索单词 <code>bar</code></li>
<li><code>n</code>：搜索后将光标移至下一个匹配项</li>
<li><code>N</code>：搜索后将光标移至上一个匹配项</li>
</ul>
<h4 id="高级搜索命令"><a href="#高级搜索命令" class="headerlink" title="高级搜索命令"></a><strong>高级搜索命令</strong></h4><ul>
<li><code>:%s/foo/bar/g</code>：在整个文件中查找并用 <code>bar</code> 替换所有出现的 <code>foo</code></li>
</ul>
<h3 id="缩进和格式化"><a href="#缩进和格式化" class="headerlink" title="缩进和格式化"></a><strong>缩进和格式化</strong></h3><h4 id="调整缩进"><a href="#调整缩进" class="headerlink" title="调整缩进"></a><strong>调整缩进</strong></h4><ul>
<li><code>&gt;&gt;</code>：将当前行或选定的行缩进一个制表符位（或移位宽度）</li>
<li><code>&lt;&lt;</code>：将当前行或选定的行向外缩进一个制表符位（或移位宽度）</li>
<li><code>==</code>：将当前行或选定的行缩进到正确的缩进级别</li>
</ul>
<h4 id="格式化段落和代码块"><a href="#格式化段落和代码块" class="headerlink" title="格式化段落和代码块"></a><strong>格式化段落和代码块</strong></h4><ul>
<li><code>gqip</code>：格式化当前段落（两行空格之间的文本）</li>
<li><code>=ap</code>：格式化选定的代码块</li>
<li><code>gwap</code>：将选定的代码块与其镜像交换（例如，翻转函数体）</li>
<li><code>gg=G</code>：格式化整个文件</li>
</ul>
<h3 id="代码折叠和切换"><a href="#代码折叠和切换" class="headerlink" title="代码折叠和切换"></a><strong>代码折叠和切换</strong></h3><h4 id="折叠和展开区域"><a href="#折叠和展开区域" class="headerlink" title="折叠和展开区域"></a><strong>折叠和展开区域</strong></h4><ul>
<li><code>zf</code>：可视模式选择行，将当前行或选定的行折叠到区域中</li>
<li><code>:10,20fold</code> ：折叠指定行范围的代码块</li>
<li><code>za</code>：切换当前行的折叠状态（如果折叠，则打开；如果未折叠，则关闭）</li>
<li><code>zM</code>：关闭当前缓冲区中的所有折叠</li>
<li><code>zR</code>：打开当前缓冲区中的所有折叠</li>
</ul>
<h4 id="设置折叠级别"><a href="#设置折叠级别" class="headerlink" title="设置折叠级别"></a><strong>设置折叠级别</strong></h4><ul>
<li><code>zm</code>：折叠级别减一（关闭折叠或打开更嵌套的折叠）</li>
<li><code>zr</code>：折叠级别加一（打开折叠或创建新折叠）</li>
</ul>
<h3 id="缓冲区管理"><a href="#缓冲区管理" class="headerlink" title="缓冲区管理"></a><strong>缓冲区管理</strong></h3><h4 id="列出和切换缓冲区"><a href="#列出和切换缓冲区" class="headerlink" title="列出和切换缓冲区"></a><strong>列出和切换缓冲区</strong></h4><ul>
<li><code>:ls</code>：列出当前 Vim 会话中的所有缓冲区</li>
<li><code>:b foo</code>：切换到名为 <code>foo</code> 的缓冲区</li>
<li><code>Ctrl+Shift+6</code> ：在最后使用过的两个缓冲区之间切换</li>
</ul>
<h4 id="分割和关闭窗口"><a href="#分割和关闭窗口" class="headerlink" title="分割和关闭窗口"></a><strong>分割和关闭窗口</strong></h4><ul>
<li><code>:split</code> 或 <code>:sp</code>：在当前选项卡页中打开一个包含相同文件的新窗口</li>
<li><code>:split path/to/another/file</code> ：在新窗口打开另一个文件</li>
<li><code>:vsplit</code> 或 <code>:vsp</code>：在当前选项卡页中打开一个包含相同文件的新垂直窗口</li>
<li><code>:vsplit path/to/another/file</code> ：在新窗口打开另一个文件</li>
<li><code>Ctrl + W</code> <code>Ctrl + W</code>：切换窗口</li>
<li><code>:q</code>：退出窗口</li>
</ul>
<h3 id="调整窗口大小"><a href="#调整窗口大小" class="headerlink" title="调整窗口大小"></a><strong>调整窗口大小</strong></h3><ul>
<li><code>Ctrl + W +</code>：将当前窗口的高度增加一行</li>
<li><code>Ctrl + W -</code>：将当前窗口的高度减少一行</li>
<li><code>Ctrl + W &gt;</code>：将当前窗口的宽度增加一列</li>
<li><code>Ctrl + W &lt;</code>：将当前窗口的宽度减少一列</li>
<li><code>Ctrl + W =</code>：将当前窗口水平等分</li>
<li><code>Ctrl + W |</code>：将当前窗口垂直等分</li>
</ul>
<h3 id="移动窗口"><a href="#移动窗口" class="headerlink" title="移动窗口"></a><strong>移动窗口</strong></h3><ul>
<li><code>Ctrl + W + h</code>：将当前窗口移到左边</li>
<li><code>Ctrl + W + j</code>：将当前窗口向下移动</li>
<li><code>Ctrl + W + k</code>：将当前窗口向上移动</li>
<li><code>Ctrl + W + l</code>：将当前窗口移到右边</li>
</ul>
<h3 id="窗口导航"><a href="#窗口导航" class="headerlink" title="窗口导航"></a><strong>窗口导航</strong></h3><ul>
<li><code>Ctrl + W + p</code>：将光标移至前一个窗口（左或上）</li>
<li><code>Ctrl + W + n</code>：将光标移至下一个窗口（右或下）</li>
</ul>
<h3 id="选项卡管理"><a href="#选项卡管理" class="headerlink" title="选项卡管理"></a><strong>选项卡管理</strong></h3><h4 id="打开、关闭和列出选项卡"><a href="#打开、关闭和列出选项卡" class="headerlink" title="打开、关闭和列出选项卡"></a><strong>打开、关闭和列出选项卡</strong></h4><ul>
<li><code>:tabnew</code> 或 <code>:tabedit</code>：打开一个包含空缓冲区的选项卡</li>
<li><code>:tabedit foo.txt</code>：打开一个包含文件 <code>foo.txt</code>的新选项卡</li>
<li><code>:qa</code>：关闭当前 Vim 会话中的所有窗口和选项卡（或在退出前使用 <code>:wq</code> 保存更改）</li>
<li><code>:lt</code>：列出当前 Vim 会话中的所有选项卡</li>
</ul>
<h4 id="在选项卡之间移动"><a href="#在选项卡之间移动" class="headerlink" title="在选项卡之间移动"></a><strong>在选项卡之间移动</strong></h4><ul>
<li><code>Ctrl + W + T</code>：将当前窗口移至其自己的选项卡页</li>
<li><code>gT</code>：将光标移至前一个选项卡页（左或上）</li>
<li><code>gt</code>：将光标移至下一个选项卡页（右或下）</li>
</ul>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a><strong>文件操作</strong></h3><h4 id="打开和保存文件"><a href="#打开和保存文件" class="headerlink" title="打开和保存文件"></a><strong>打开和保存文件</strong></h4><ul>
<li><code>:edit foo.txt</code>：打开一个包含文件 <code>foo.txt</code> 的新缓冲区</li>
<li><code>:write</code> 或 <code>:w</code>：将当前缓冲区的内容保存到其关联的文件</li>
<li><code>:qa</code>：退出当前 Vim 会话中的所有窗口和选项卡（或在退出前使用 <code>:wq</code> 保存更改）</li>
</ul>
<h3 id="使用不同文件分割窗口"><a href="#使用不同文件分割窗口" class="headerlink" title="使用不同文件分割窗口"></a><strong>使用不同文件分割窗口</strong></h3><ul>
<li><code>:split foo.txt</code>：打开一个包含文件 <code>foo.txt</code>的新窗口</li>
<li><code>:vsplit bar.txt</code>：打开一个包含文件 <code>bar.txt</code> 的新垂直窗口</li>
</ul>
<h2 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a><strong>插件安装</strong></h2><p>安装vim-plug插件管理器</p>
<p>在终端输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fLo ~/.vim/autoload/plug.vim --create-dirs \</span><br><span class="line">    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br></pre></td></tr></table></figure>

<p>这条命令会将 vim-plug 下载并安装到 <code>~/.vim/autoload/plug.vim</code> 中。</p>
<p>配置：在你的 <code>~/.vimrc</code>（或 <code>~/.config/nvim/init.vim</code> 如果是 <code>Neovim</code>）文件中添加以下内容来配置 vim-plug：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot; vim-plug settings</span></span><br><span class="line"><span class="string">call plug#begin(&#x27;~/.vim/plugged&#x27;)</span></span><br><span class="line"><span class="string">&quot;</span> 插件列表</span><br><span class="line"><span class="string">&quot; 例如：Plug &#x27;junegunn/vim-easy-align&#x27;</span></span><br><span class="line"><span class="string">call plug#end()</span></span><br></pre></td></tr></table></figure>

<p>在 <code>call plug#begin()</code> 和 <code>call plug#end()</code> 之间，列出你想安装的插件。每个插件由 <code>Plug &#39;github用户/仓库&#39;</code> 格式定义。</p>
<p>在Vim运行以下命令安装插件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:PlugInstall</span><br></pre></td></tr></table></figure>

<p><strong>常用插件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Nerdtree：一个在屏幕左侧添加文件树的插件，可以让你更轻松地浏览文件。</span><br><span class="line">Syntastic：一个为多种编程语言提供语法高亮的插件。</span><br><span class="line">Vim-Airline：一个高度可配置的 Vim 状态栏，易于自定义，可提高你的整体编辑效率。</span><br><span class="line">Nerd Commenter：这个插件可以帮助你轻松注释和取消注释各种编程语言中的代码行。</span><br><span class="line">FZF：一个命令行模糊查找器，具有语法高亮、键盘导航和文件过滤功能。</span><br><span class="line">YouCompleteMe：一个适用于 Vim 的快速按需代码补全引擎。</span><br><span class="line">Coc.nvim：一个语言服务器协议 (LSP) 插件，为许多热门编程语言提供 IntelliSense 功能，如自动完成和跳转到定义。</span><br><span class="line">Vim-Fugitive：这个插件允许你轻松地在 Vim 中管理 Git 存储库。</span><br><span class="line">Ale：一个与许多热门编程语言搭配使用的语法和样式检查器，可在键入时提供实时错误检查。</span><br><span class="line">Vim-surround：这个插件让你可以轻松处理文件中的文本周围成对的字符（如引号或括号）。</span><br><span class="line">Lightline：一个轻量级且可配置的 Vim 状态栏/选项卡栏插件。</span><br><span class="line">Vim-easymotion：EasyMotion 提供了一种更简单的方式来使用 vim 中的一些动作。它通过突出显示所有可能的选择并允许你按一个键直接跳转到目标来消除 w 或 f&#123;char&#125; 中的 。</span><br><span class="line">Vim-lsp：一个提供语言服务器协议支持的插件，让你可以使用高级语言特性，如代码补全和语法高亮。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call plug#begin(&#x27;~/.vim/plugged&#x27;)</span><br><span class="line">	Plug &#x27;preservim/nerdtree&#x27;</span><br><span class="line">	Plug &#x27;vim-syntastic/syntastic&#x27;</span><br><span class="line">	Plug &#x27;vim-airline/vim-airline&#x27;</span><br><span class="line">	Plug &#x27;preservim/nerdcommenter&#x27;</span><br><span class="line">	Plug &#x27;ycm-core/YouCompleteMe&#x27;</span><br><span class="line">	Plug &#x27;junegunn/vim-easy-align&#x27;</span><br><span class="line">	Plug &#x27;neoclide/coc.nvim&#x27;, &#123;&#x27;branch&#x27;: &#x27;release&#x27;&#125;</span><br><span class="line">call plug#end()</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>软件使用教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora使用教程</title>
    <url>/2024/07/24/Typora%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>[TOC] </p>
<h3 id="一、Typora安装"><a href="#一、Typora安装" class="headerlink" title="一、Typora安装"></a><strong>一、Typora安装</strong></h3><h4 id="1、下载"><a href="#1、下载" class="headerlink" title="1、下载"></a><strong>1、下载</strong></h4><p>Typora中文官网：<a href="https://typoraio.cn/">https://typoraio.cn/</a><br>Typora官网：<a href="https://typora.io/releases/all">https://typora.io/releases/all</a></p>
<h4 id="2、激活"><a href="#2、激活" class="headerlink" title="2、激活"></a><strong>2、激活</strong></h4><ol>
<li>用编辑器打开<code>D:\Program Files\Typora\resources\page-dist\static\js\LicenseIndex.180dd4c7.4da8909c.chunk.js</code>，将 <code>e.hasActivated=&quot;true&quot;==e.hasActivated</code>  替换为 <code>e.hasActivated=&quot;true&quot;==&quot;true&quot;</code></li>
<li>关闭软件每次启动时的已激活弹窗，用编辑器打开<code>D:\Program Files\Typora\resources\page-dist\license.html</code>，将  <code>&lt;/body&gt;&lt;/html&gt;</code> 替换为 <code>&lt;/body&gt;&lt;script&gt;window.οnlοad=function()&#123;setTimeout(()=&gt;&#123;window.close();&#125;,5);&#125;&lt;/script&gt;&lt;/html&gt;</code></li>
<li>去除左下角软件未激活提示，用编辑器打开<code>D:\Program Files\Typora\resources\locales\zh-Hans.lproj\Panel.json</code>，将 <code>&quot;UNREGISTERED&quot;:&quot;未激活&quot;</code> 替换为 <code>&quot;UNREGISTERED&quot;:&quot; &quot;</code>，激活成功。</li>
</ol>
<h4 id="3、鼠标右键新建-Markdown-文件"><a href="#3、鼠标右键新建-Markdown-文件" class="headerlink" title="3、鼠标右键新建 Markdown 文件"></a><strong>3、鼠标右键新建 Markdown 文件</strong></h4><p>新建一个<strong>txt</strong> 文本文件，写入以下内容，然后将后缀 <code>.txt</code> 改名<code>.reg</code>，该文件为注册表项，双击运行</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">Windows Registry Editor Version <span class="number">5.00</span></span><br><span class="line"> </span><br><span class="line">[<span class="type">HKEY_CLASSES_ROOT</span>\<span class="type">.md</span>]</span><br><span class="line"><span class="selector-tag">@</span>=<span class="string">&quot;Typora.md&quot;</span></span><br><span class="line"><span class="string">&quot;Content Type&quot;</span>=<span class="string">&quot;text/markdown&quot;</span></span><br><span class="line"><span class="string">&quot;PerceivedType&quot;</span>=<span class="string">&quot;text&quot;</span></span><br><span class="line"> </span><br><span class="line">[<span class="type">HKEY_CLASSES_ROOT</span>\<span class="type">.md</span>\<span class="type">ShellNew</span>]</span><br><span class="line"><span class="string">&quot;NullFile&quot;</span>=<span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p> 右键新建<code>markdown</code>文件以后，可能会发现文件有几十MB那么大。</p>
</blockquote>
<blockquote>
<p> 解决方法：<code>win+R</code>后输入<code>regedit</code>打开注册表，打开路径<code>\HKEY_CLASSES_ROOT\.md\ShellNew</code></p>
<p>删除多余的文件，只保留两项（<code>默认</code>和<code>NullFile</code>）。然后关闭注册表</p>
</blockquote>
<h4 id="4、目前发现只能打开一个窗口，暂未找到解决办法"><a href="#4、目前发现只能打开一个窗口，暂未找到解决办法" class="headerlink" title="4、目前发现只能打开一个窗口，暂未找到解决办法"></a><strong>4、目前发现只能打开一个窗口，暂未找到解决办法</strong></h4><h3 id="二、常用快捷键"><a href="#二、常用快捷键" class="headerlink" title="二、常用快捷键"></a><strong>二、常用快捷键</strong></h3><table>
<thead>
<tr>
<th align="left">快捷键</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>ctrl + /</code></td>
<td align="left">切换 源代码模式&#x2F;预览模式</td>
</tr>
<tr>
<td align="left"><code>ctrl + 1 ~6</code></td>
<td align="left">一 ~ 六级标题，最多六级标题，<code>ctrl + 0</code>清除</td>
</tr>
<tr>
<td align="left"><code>ctrl + B</code></td>
<td align="left">粗体</td>
</tr>
<tr>
<td align="left"><code>ctrl + i 斜体</code></td>
<td align="left">斜体</td>
</tr>
<tr>
<td align="left"><code>ctrl + T</code></td>
<td align="left">表格</td>
</tr>
<tr>
<td align="left">&#96;&#96;&#96;&#96; + Enter<code>或</code>Ctrl + Shift + k&#96;</td>
<td align="left">代码块</td>
</tr>
<tr>
<td align="left"><code>&gt; + 空格</code></td>
<td align="left">引用</td>
</tr>
<tr>
<td align="left"><code>\ + 字符</code></td>
<td align="left">转义</td>
</tr>
<tr>
<td align="left"><code>Ctrl + u</code></td>
<td align="left">下划线</td>
</tr>
<tr>
<td align="left"><code>alt + shift + 5</code> 或 <code>~~内容~~</code></td>
<td align="left">删除线</td>
</tr>
<tr>
<td align="left"><code>--- + Enter</code>  或 <code>*** + Enter</code></td>
<td align="left">分割线</td>
</tr>
<tr>
<td align="left"><code>- + 空格</code> 或 <code>* + 空格</code> 或 <code>Ctrl + Shift + ]</code></td>
<td align="left">无序列表</td>
</tr>
<tr>
<td align="left"><code>数字 + . + 空格</code> 或 <code>Ctrl + Shift + [</code></td>
<td align="left">有序列表，降级：<code>Tab</code>，升级：<code>Shift + Tab</code></td>
</tr>
<tr>
<td align="left">- 内容，选中后右键选择<code>任务列表</code></td>
<td align="left">- 任务列表</td>
</tr>
<tr>
<td align="left"><code>[TOC] + Enter</code></td>
<td align="left">生成目录</td>
</tr>
<tr>
<td align="left"><code>Ctrl + L</code></td>
<td align="left">选中一整行</td>
</tr>
<tr>
<td align="left"><code>Ctrl + d</code></td>
<td align="left">选中单词</td>
</tr>
<tr>
<td align="left"><code>Ctrl + e</code></td>
<td align="left">选中相同格式的文字(例如：加粗、斜体)</td>
</tr>
<tr>
<td align="left"><code>Ctrl + home</code></td>
<td align="left">跳转到文章开头</td>
</tr>
<tr>
<td align="left"><code>Ctrl + end</code></td>
<td align="left">跳转到文章结尾</td>
</tr>
<tr>
<td align="left"><code>Ctrl + f</code></td>
<td align="left">搜索</td>
</tr>
<tr>
<td align="left"><code>Ctrl + h</code></td>
<td align="left">替换</td>
</tr>
<tr>
<td align="left"><code>Ctrl + k</code></td>
<td align="left">插入链接</td>
</tr>
<tr>
<td align="left"><code>$$ + Enter</code></td>
<td align="left">数学公式</td>
</tr>
<tr>
<td align="left"><code>: + 单词 + :</code></td>
<td align="left">表情（<a href="https://www.webfx.com/tools/emoji-cheat-sheet/">常用表情</a>）:coffee:</td>
</tr>
<tr>
<td align="left"><code>直接拖动到指定位置</code> 或 <code>Ctrl + Shift + i</code></td>
<td align="left">插入图片（图片可以直接拖进来，但是图片是相对路径，只能在本地使用，如果要放到博客中，要用绝对路径）</td>
</tr>
<tr>
<td align="left"><code>&lt;sub&gt;内容&lt;/sub&gt;</code></td>
<td align="left"><sub>下标</sub></td>
</tr>
<tr>
<td align="left"><code>&lt;sup&gt;内容&lt;/sup&gt;</code></td>
<td align="left"><sup>上标</sup></td>
</tr>
<tr>
<td align="left"><code> [+^+脚注]</code></td>
<td align="left">[^脚注] （<strong>最前面有个空格</strong>）</td>
</tr>
<tr>
<td align="left"><code>==内容==</code></td>
<td align="left">&#x3D;&#x3D;高亮&#x3D;&#x3D;</td>
</tr>
<tr>
<td align="left"><code>Ctrl + Shift + </code> &#96;</td>
<td align="left">着重</td>
</tr>
<tr>
<td align="left"><del><code>+ 内容 +</code></del></td>
<td align="left"><del>淡化</del></td>
</tr>
<tr>
<td align="left"><code>Ctrl + \</code></td>
<td align="left">清除格式</td>
</tr>
<tr>
<td align="left"><code>&lt;center&gt;+居中内容+&lt;center&gt;</code></td>
<td align="left">居中</td>
</tr>
<tr>
<td align="left"><code>&lt;p align=&quot;right&quot;&gt;右对齐&lt;/p&gt;</code></td>
<td align="left">右对齐</td>
</tr>
<tr>
<td align="left"><code>&lt;p align=&quot;left&quot;&gt;左对齐&lt;/p&gt;</code></td>
<td align="left">左对齐</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">操作相关</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>Ctrl + N</code></td>
<td align="left">新建</td>
</tr>
<tr>
<td align="left"><code>Ctrl + Shift + N</code></td>
<td align="left">新建窗口</td>
</tr>
<tr>
<td align="left"><code>Ctrl + O</code></td>
<td align="left">打开</td>
</tr>
<tr>
<td align="left"><code>Ctrl + P</code></td>
<td align="left">快速打开</td>
</tr>
<tr>
<td align="left"><code>Ctrl + S</code></td>
<td align="left">保存</td>
</tr>
<tr>
<td align="left"><code>Ctrl + Shift + S</code></td>
<td align="left">另存为</td>
</tr>
<tr>
<td align="left"><code>Ctrl + W</code></td>
<td align="left">关闭</td>
</tr>
<tr>
<td align="left"><code>Ctrl + Z</code></td>
<td align="left">撤销</td>
</tr>
<tr>
<td align="left"><code>Ctrl + Y</code></td>
<td align="left">重做</td>
</tr>
<tr>
<td align="left"><code>Ctrl+Shift+C</code></td>
<td align="left">复制为<code>MarkDown</code></td>
</tr>
<tr>
<td align="left"><code>Ctrl+Shift+V</code></td>
<td align="left">粘贴为纯文本</td>
</tr>
<tr>
<td align="left"><code>Ctrl+Shift+1</code></td>
<td align="left">大纲视图</td>
</tr>
<tr>
<td align="left"><code>Ctrl+Shift+2</code></td>
<td align="left">文档列表视图</td>
</tr>
<tr>
<td align="left"><code>Ctrl+Shift+3</code></td>
<td align="left">文件树视图</td>
</tr>
<tr>
<td align="left"><code>Ctrl+Shift+L</code></td>
<td align="left">显示隐藏侧边栏</td>
</tr>
<tr>
<td align="left"><code>F8</code></td>
<td align="left">专注模式</td>
</tr>
<tr>
<td align="left"><code>F9</code></td>
<td align="left">打字机模式</td>
</tr>
<tr>
<td align="left"><code>F11</code></td>
<td align="left">切换全屏</td>
</tr>
<tr>
<td align="left"><code>Ctrl+Shift+0</code></td>
<td align="left">实际大小</td>
</tr>
<tr>
<td align="left"><code>Ctrl + Shift+ +/-</code></td>
<td align="left">放大&#x2F;缩小</td>
</tr>
<tr>
<td align="left"><code>Ctrl+Tab</code></td>
<td align="left">应用内窗口切换</td>
</tr>
<tr>
<td align="left"><code>Shift+F12</code></td>
<td align="left">打开<code>DevTools</code></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<p>​	</p>
<h4 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h4><ul>
<li><p>插入本地图片</p>
<ul>
<li>拖放图片</li>
<li>Markdown语法</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">图片描述</span>](<span class="link">example.png</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>插入网络图片</p>
<ul>
<li>Markdown语法</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">图片描述</span>](<span class="link">https://example.com/path/to/image.jpg</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>图片链接的额外选项</p>
<ul>
<li>设置图片大小</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;example.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;图片描述&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200&quot;</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>免费图床</p>
<p><a href="https://picui.cn/upload">https://picui.cn/upload</a></p>
</blockquote>
<p>你掌握了以上操作了吗？</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 是</li>
<li><input disabled="" type="checkbox"> 否</li>
</ul>
<h3 id="三、-生成pdf、html等文件"><a href="#三、-生成pdf、html等文件" class="headerlink" title="三、 生成pdf、html等文件"></a><strong>三、 生成pdf、html等文件</strong></h3><p>文件→导出→选择要导出文件的格式</p>
<h3 id="四、画图"><a href="#四、画图" class="headerlink" title="四、画图"></a><strong>四、画图</strong></h3><p>以下内容参考博客：<a href="https://blog.csdn.net/whatday/article/details/88655461">markdown 画图_markdown graph subgraph-CSDN博客</a></p>
<ol>
<li><h4 id="graph-流程图"><a href="#graph-流程图" class="headerlink" title="graph 流程图"></a>graph 流程图</h4><ul>
<li><code>TB</code>：从上到下</li>
<li><code>TD</code>：从上到下</li>
<li><code>BT</code>：从下到上</li>
<li><code>RL</code>：从右到左</li>
<li><code>LR</code>：从左到右</li>
</ul>
<h5 id="节点形状"><a href="#节点形状" class="headerlink" title="节点形状"></a><strong>节点形状</strong></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">默认节点 A</span><br><span class="line">文本节点 B[bname]</span><br><span class="line">圆角节点 C(cname)</span><br><span class="line">圆形节点 D((dname))</span><br><span class="line">非对称节点 E&gt;ename]</span><br><span class="line">菱形节点 F&#123;fname&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> A~F 是当前节点名字，类似于变量名，画图时便于引用</p>
</blockquote>
<blockquote>
<p> [b~f]name是节点中显示的文字，默认节点的名字和显示的文字都为A</p>
</blockquote>
   <pre class="mermaid">      graph LR;
       A-->B[文本]
       B[文本]-->C(圆角)
       C(圆角)-->D((圆形))
       D((圆形))-->E>非对称节点]
       E>非对称节点]-->F{菱形}
       F{菱形}-->A</pre>

<h5 id="连线"><a href="#连线" class="headerlink" title="连线"></a><strong>连线</strong></h5><p>节点间的连接线有多种形状，可以在连接线中加入标签：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">箭头连接 A1–-&gt;B1</span><br><span class="line">开放连接 A2—B2</span><br><span class="line">标签连接 A3–text—B3</span><br><span class="line">箭头标签连接 A4–text–&gt;B4</span><br><span class="line">虚线开放连接 A5.-B5</span><br><span class="line">虚线箭头连接 A6-.-&gt;B6</span><br><span class="line">标签虚线连接 A7-.text.-B7</span><br><span class="line">标签虚线箭头连接 A8-.text.-&gt;B8</span><br><span class="line">粗线开放连接 A9===B9</span><br><span class="line">粗线箭头连接 A10==&gt;B10</span><br><span class="line">标签粗线开放连接 A11==text===B11</span><br><span class="line">标签粗线箭头连接 A12==text==&gt;B12</span><br></pre></td></tr></table></figure>

<pre class="mermaid">   graph TB
  A1-->B1
  A2---B2
  A3--text---B3
  A4--text-->B4
  A5-.-B5
  A6-.->B6
  A7-.text.-B7
  A8-.text.->B8
  A9===B9
  A10==>B10
  A11==text===B11
  A12==text==>B12</pre>

<h5 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h5><pre class="mermaid">   
graph LR
  start("input x") --> handler("x > 0?")
  handler --yes--> yes("output x")
  handler --no--> start
  yes --> exit("exit")</pre>



</li>
<li><h4 id="flow-流程图"><a href="#flow-流程图" class="headerlink" title="flow 流程图"></a>flow 流程图</h4><h5 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a><strong>关键字</strong></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start/end，表示程序的开始与结束</span><br><span class="line">operation，表示程序的处理块</span><br><span class="line">subroutine，表示子程序块</span><br><span class="line">condition，表示程序的条件判断</span><br><span class="line">inputoutput，表示程序的出入输出</span><br><span class="line">right/left，表示当前连线在当前模块上的起点(默认从下端开始)</span><br><span class="line">yes/no， 表示condition判断的分支(可以和right，left同时使用)</span><br></pre></td></tr></table></figure>

<p>通过定义模块与连接，再结合以上关键词即可定义简单流程图的各个模块。</p>
<p>模块定义(模块标识与模块名称可以任意定义名称，但是不能为关键词)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">模块标识(相当于变量名)=&gt;模块关键词: 模块名称(模块中显示的文字)</span><br></pre></td></tr></table></figure>

<p>连接定义如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">模块标识1-&gt;模块标识2</span><br><span class="line">模块标识1-&gt;模块标识2-&gt;模块标识3</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>进行连接的时候，可以通过<code>right</code>，<code>left</code>确定箭头的起点。</p>
<p>使用<code>condition</code>关键词定义的判断框的连接需要结合yes或者no使用，如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cond1=&gt;condition: x&gt;0?</span><br><span class="line">cond1(yes)-&gt;module1</span><br><span class="line">cond1(no)-&gt;moudle2</span><br><span class="line"> </span><br><span class="line"># 指定方向,如果后面占用了这个方向, 前面的无效   </span><br><span class="line">cond1(yes,right)-&gt;module1</span><br><span class="line">cond1(no)-&gt;moudle2</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 先自定义变量,然后画图</span><br><span class="line">st=&gt;start: 开始</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line">op=&gt;operation: 输入x</span><br><span class="line">sub=&gt;subroutine: 是否重新输入</span><br><span class="line">cond1=&gt;condition: x&gt;0?</span><br><span class="line">cond2=&gt;condition: yes/no </span><br><span class="line">io=&gt;inputoutput: 输出x  </span><br><span class="line"> </span><br><span class="line">st(right)-&gt;op-&gt;cond1</span><br><span class="line">cond1(yes)-&gt;io(right)-&gt;e</span><br><span class="line">cond1(no)-&gt;sub(right)-&gt;cond2()</span><br><span class="line">cond2(yes, right)-&gt;op</span><br><span class="line">cond2(no)-&gt;e</span><br></pre></td></tr></table></figure>

<div id="flowchart-0" class="flow-chart"></div></li>
</ol>
<script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">   st=>start: 开始
   e=>end: 结束
   op=>operation: 输入x
   sub=>subroutine: 是否重新输入
   cond1=>condition: x>0?
   cond2=>condition: yes/no 
   io=>inputoutput: 输出x  
    
   st(right)->op->cond1
   cond1(yes)->io(right)->e
   cond1(no)->sub(right)->cond2()
   cond2(yes, right)->op
   cond2(no)->e</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script>]]></content>
      <tags>
        <tag>软件使用教程</tag>
      </tags>
  </entry>
  <entry>
    <title>鸟哥的Linux实战阅读笔记</title>
    <url>/2024/08/10/%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>[TOC] </p>
<h1 id="一、计算机概论"><a href="#一、计算机概论" class="headerlink" title="一、计算机概论"></a>一、计算机概论</h1><p>计算机：接受输入指令与数据，经由中央处理器的数学与逻辑单元运算处理后，以产生或储存成有用的信息。</p>
<p>计算机由五个主要单元所组成的，包括<strong>输入单元、输出单元、CPU 内部的控制单元、算数逻辑单元与内存</strong>五大部分。</p>
<p>重点在于中央处理器（<code>Central Processing Unit</code>,  CPU），CPU 为一个具有特定功能的芯片，里头含有<strong>微指令集</strong>。</p>
<p>CPU 的工作主要在于<strong>管理与运算</strong>，因此在CPU 内又可分为两个主要的单元：算数逻辑单元与控制单元。</p>
<ul>
<li>算数逻辑单元：主要负责程序运算与逻辑判断</li>
<li>控制单元：协调各周边元件与各单元间的工作。</li>
</ul>
<p>CPU 读取的数据都是从内存来的，内存内的数据则是从输入单元所传输进来！而 CPU 处理完毕的数据也必须要先写回内存中，最后数据才从内存传输到输出单元。</p>
<pre class="mermaid">graph LR
    输入输出设备 --输入--> 内存
    内存 --读取--> CPU
    CPU --传输--> 内存
    内存 --输出--> 输入输出设备</pre>



<span id="more"></span>

<h2 id="CPU-架构"><a href="#CPU-架构" class="headerlink" title="CPU 架构"></a>CPU 架构</h2><p>主要有两种 CPU 架构，分别是：精简指令集（<code>RISC</code>）与复杂指令集（<code>CISC</code>）系统。</p>
<ul>
<li><p>精简指令集（<code>Reduced Instruction Set Computer,</code>  <code>RISC</code>）：这种 CPU 的微指令集较为精简，每个指令的执行时间都很短，完成的动作也很单纯，指令的执行性能较佳；但是若要做复杂的事情，就要由多个指令来完成。.</p>
<blockquote>
<p>常见的 RISC微指令集 CPU :</p>
<p>甲骨文（Oracle）公司的 SPARC 系列，常用于学术领域的大型工作站中和银行金融体系的主要服务器</p>
<p>IBM 公司的 <code>PowerArchitecture</code> （包括 <code>PowerPC</code>）系列，<code>PS3</code>的Cell处理器等</p>
<p>安谋公司（ARM Holdings）的 ARM CPU 系列，手机、<code>PDA</code>、导航系统、网络设备（交换器、路由器等）等</p>
</blockquote>
</li>
<li><p>复杂指令集（<code>Complex Instruction Set Computer</code>, <code>CISC</code>）：与<code>RISC</code>不同的，<code>CISC</code>在微指令集的每个小指令可以执行一些较低阶的硬件操作，指令数目多而且复杂，每条指令的长度并不相同。因为指令执行较为复杂所以每条指令花费的时间较长，但每条个别指令可以处理的工作较为丰富。</p>
<p>常见的<code>CISC</code>微指令集CPU主要有<code>AMD</code>、<code>Intel</code>、<code>VIA</code>等<code>x86</code>架构的CPU。</p>
<blockquote>
<p>为啥叫<code>x86</code>？</p>
<p>因为最早的那颗Intel发展出来的CPU代号称为<strong>8086</strong>，后来依此架构又开发出80286, 80386…，因此这种架构的CPU就被称为<code>x86</code>架构了。在2003年以前由Intel所开发的<code>x86</code>架构CPU由8位升级到16、32位，后来<code>AMD</code>依此架构修改新一代的CPU为64位，为了区别两者的差异，因此64位的CPU又被统称为<code>x86_64</code>的架构</p>
</blockquote>
<blockquote>
<p>所谓的位指的是<strong>CPU一次数据读取的最大量</strong>！64位CPU代表CPU一次可以读写<code>64bits</code>的数据，32位CPU一次只能读取<code>32bits</code>的数据。</p>
<p>因为CPU读取数据量有限制，因此能够从内存中读写的数据也就有所限制。所以，一般32位的CPU所能读写的最大数据量，大概就是<code>4GB</code>左右</p>
</blockquote>
</li>
</ul>
<h3 id="CPU的工作频率"><a href="#CPU的工作频率" class="headerlink" title="CPU的工作频率"></a>CPU的工作频率</h3><p>每秒钟可以执行的时钟周期数，而不是直接表示可以进行多少次工作。频率越高表示CPU单位时间内可以作更多的事情。 </p>
<p>例如：<code>i7-4790</code> CPU频率为<code>3.6GHz</code>，表示每秒钟可以进行3.6 × 10^9 次时钟周期，如果每个时钟周期可以完成一项基本操作，那么理论上每秒钟可以完成3.6 × 10^9 次基本操作.</p>
<h3 id="外频与倍频"><a href="#外频与倍频" class="headerlink" title="外频与倍频"></a>外频与倍频</h3><p>早期的 CPU 架构主要通过<strong>北桥</strong>来链接系统最重要的 <code>CPU、内存与显卡设备</code>。因为所有的设备都得通过北桥来链接，每个设备的工作频率应该要相同，于是就有所谓的前端总线（<code>FSB</code>）。由于 CPU 的运算速度比其他的设备都快，又为了要满足<code>FSB</code> 的频率，因此厂商就在 CPU 内部再进行加速，于是就有所谓的外频与倍频了。</p>
<ul>
<li>外频：CPU与外部元件进行数据传输时的速度</li>
<li>倍频：CPU 内部用来加速工作性能的一个倍数，两者相乘才是CPU的频率速度</li>
</ul>
<p>例如 <code>Intel Core 2 E8400</code> 的内频为 <code>3.0GHz</code>，而外频是<code>333MHz</code>，因此倍频就是9倍！（<code>3.0G = 333M x 9</code>）</p>
<blockquote>
<p>超频的原理？</p>
<p>以前的超频：将CPU的倍频或者是外频通过主板的设置功能更改成较高频率的一种方式。但因为CPU的倍频通常在出厂时已经被锁定而无法修改，因此较常被超频的为<strong>外频</strong>。</p>
<p>目前的<strong>CPU自动超频</strong></p>
<p>CPU自动超频通常是指通过处理器内部的动态频率调整技术，如<code>Intel的Turbo Boost</code>或<code>AMD的Precision Boost</code>，来自动提升处理器的工作频率，以在需要时提供更高的性能</p>
<p>手动超频：</p>
<p>超频需要主板和BIOS的支持。主板的设计和电源供应必须足够强大，同时BIOS提供了设置频率、电压等参数的界面和选项</p>
<p>1、时钟发生器调整</p>
<p>改变时钟发生器的输出频率，使CPU执行的时钟周期增加，从而提高CPU的工作频率</p>
<p>2、电压调整</p>
<p>增加CPU的电压，以确保处理器在更高频率下能够稳定运行</p>
</blockquote>
<p>但如此一来所有的数据都被北桥卡死了，北桥又不可能比 CPU 更快，因此这家伙常常是系统性能的瓶颈。为了解决这个问题，新的 CPU 设计中，已经将<strong>内存控制器</strong>整合到 CPU 内部，而链接 <strong>CPU 与内存、显卡</strong>的控制器的设计，在<code>Intel</code>部份使用 <code>QPI （Quick PathInterconnect）</code>与 <code>DMI</code> 技术，而 <code>AMD</code> 部份则使用 <code>Hyper Transport</code> 了，这些技术都可以让CPU 直接与内存、显卡等设备分别进行沟通，而不需要通过外部的链接芯片了。</p>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>个人电脑的内存主要元件为动态随机存取内存（Dynamic Random Access Memory, DRAM），随机存取内存只有在<strong>通电</strong>时才能记录与使用，断电后数据就消失了。因此也称这种RAM为挥发性内存。</p>
<h3 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h3><p><code>DRAM</code>根据技术的更新分好几代，使用上较广泛的是<code>SDRAM</code>与<code>DDR SDRAM</code>两种。这两种内存的差别除了<strong>脚位</strong>与<strong>工作电压</strong>上的不同之外，<code>DDR</code>是双倍数据传送速度（Double Data Rate），可以在一次工作周期中进行两次数据的传送，所以传输频率方面比<code>SDRAM</code>还要好。<code>DDR2</code> 的频率倍数是<code>DDR</code>的 4 倍，而<code>DDR3</code> 则是 8 倍。</p>
<p><code>DDR3/DDR3L</code>：新的制程中降低了内存的操作电压，<code>DDR3</code> 标准电压为 <code>1.5V</code>，但 <code>DDR3L</code> 则仅须 <code>1.35V</code> ，需要主板支持。</p>
<h4 id="内存容量"><a href="#内存容量" class="headerlink" title="内存容量"></a>内存容量</h4><p>内存容量不够大的话将会导致某些<strong>大容量数据</strong>无法被完整的载入，此时已存在内存当中但暂时没有被使用到的数据必须要先被<strong>释放</strong>，使得可用内存容量大于该数据，那份新数据才能够被载入。所以，通常越大的内存代表越快速的系统，这是因为系统不用常常释放一些内存内部的数据。</p>
<h4 id="多通道"><a href="#多通道" class="headerlink" title="多通道"></a>多通道</h4><p>由于所有的数据都必须要存放在内存，所以内存的数据宽度当然是越大越好。但传统的总线宽度一般大约仅达64位，为了加大这个宽度，芯片组厂商将两个内存汇整在一起，如果一支内存可达64位，两支内存就可以达到128位了，这就是双通道的设计理念。启用双通道的功能必须要安插两支（或四支）内存，最好连内存型号都一样，因为数据是同步写入&#x2F;读出这一对内存。</p>
<h4 id="内存信道"><a href="#内存信道" class="headerlink" title="内存信道"></a>内存信道</h4><p>计算机系统中用于传输数据和指令的路径或通道，其作用类似于数据在计算机内存和其他硬件组件（如CPU、显卡等）之间的桥梁。</p>
<h5 id="作用和功能"><a href="#作用和功能" class="headerlink" title="作用和功能"></a>作用和功能</h5><ul>
<li><p><strong>数据传输</strong>：内存信道负责将数据从计算机的主存储器（RAM）传输到其他硬件组件，如<code>CPU</code>、<code>GPU</code>等，或者反之。</p>
</li>
<li><p><strong>并发性</strong>：现代计算机系统通常具有多个内存信道，允许同时进行多条数据传输，以提高整体系统的带宽和效率。</p>
</li>
<li><p><strong>速度匹配</strong>：内存信道的设计要与处理器、系统总线和其他硬件组件的速度匹配，以确保高效的数据交换和处理。</p>
</li>
</ul>
<h3 id="CPU内部高速缓存"><a href="#CPU内部高速缓存" class="headerlink" title="CPU内部高速缓存"></a>CPU内部高速缓存</h3><p>CPU内部高速缓存（CPU Cache）是位于CPU内部的一种高速存储器，用于临时存放<strong>频繁使用</strong>的数据和指令，减少从主存（<code>RAM</code>）读取数据的时间，以提高处理器访问数据的速度和效率。</p>
<p>静态随机存取内存（<code>StaticRandom Access Memory, SRAM</code>）：是一种基于静态存储单元的存储器技术。<code>SRAM</code>主要用于实现高速缓存、寄存器文件和其他需要快速访问的存储器部件，包括但不限于CPU内部缓存。</p>
<h4 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h4><p><strong>三级缓存</strong>：现代CPU通常包含多层级别的高速缓存，包括 <code>L1</code>（一级缓存）、<code>L2</code>（二级缓存）和<code>L3</code>（三级缓存）。</p>
<ul>
<li>**<code>L1 Cache</code>**：位于CPU核心内部，速度最快，但容量较小。</li>
<li>**<code>L2 Cache</code>**：通常位于CPU核心之间或者与核心紧密结合，速度次于<code>L1</code>，容量比<code>L1</code>大。</li>
<li>**<code>L3 Cache</code>**：位于处理器芯片上，用于共享所有CPU核心之间的数据，速度比<code>L2</code>和<code>L1</code>略慢，但容量最大。</li>
</ul>
<h4 id="命中和失效"><a href="#命中和失效" class="headerlink" title="命中和失效"></a>命中和失效</h4><ul>
<li><p><strong>缓存命中（Cache Hit）</strong>：当处理器需要访问数据时，如果数据恰好在缓存中，则可以直接从缓存中读取，这称为缓存命中。</p>
</li>
<li><p><strong>缓存失效（Cache Miss）</strong>：如果需要的数据不在缓存中，则发生缓存失效，处理器必须从主存中读取数据，并将其存入缓存，以备将来使用。</p>
</li>
</ul>
<h3 id="ROM（Read-Only-Memory，只读存储器）"><a href="#ROM（Read-Only-Memory，只读存储器）" class="headerlink" title="ROM（Read-Only Memory，只读存储器）"></a>ROM（Read-Only Memory，只读存储器）</h3><p>一种计算机存储器类型，主要特点是一旦数据被存储在其中，就无法直接修改或写入新的数据。这使得<code>ROM</code>适合存储那些不需要经常更改的固定数据，例如系统固件、基本输入输出系统（BIOS）、引导程序等</p>
<p><strong>种类和应用</strong>：</p>
<ul>
<li><strong><code>EPROM</code>（可擦除可编程ROM）</strong>：<code>EPROM</code>可以通过特定的擦除设备进行擦除和重新编程，但通常需要专业的设备，不适合常规用户。</li>
<li><strong><code>EEPROM</code>（电可擦除可编程ROM）</strong>：<code>EEPROM</code>相对更容易擦除和重新编程，可以通过特定的电压信号来实现擦除操作。</li>
<li><strong><code>Flash</code>存储器</strong>：<code>Flash</code>存储器是一种基于<code>EEPROM</code>技术的可编程存储器，适合大容量数据存储和固件更新。</li>
</ul>
<h2 id="显卡"><a href="#显卡" class="headerlink" title="显卡"></a>显卡</h2><p>显卡又称为VGA（<code>Video Graphics Array</code>），用于图形影像的显示。</p>
<p>一般对于图形影像的显示重点在于分辨率与色彩深度，每个图像显示的颜色会占用掉内存，显卡上面会有一个内存的容量，这个显存容量会影响屏幕分辨率与色彩深度。</p>
<p>除了显存之外，显卡的运算能力也很重要。一些<code>3D</code>的运算早期是交给CPU去运行的，但是CPU并非完全针对这些<code>3D</code>来进行设计的，而且CPU平时已经非常忙碌了！所以显卡厂商直接在显卡上面嵌入一个<code>3D</code>加速的芯片，这就是所谓的<code>GPU</code>称谓的由来。</p>
<h3 id="PCIe"><a href="#PCIe" class="headerlink" title="PCIe"></a><code>PCIe</code></h3><p><code>PCIe</code>（Peripheral Component Interconnect Express，外设组件互联扩展）是一种用于连接高速外设和主板的计算机总线标准，使用的是类似管线的概念来处理，在 <code>PCIe 1.0</code>中，每条管线可以具有<code>250MBytes/s</code>的带宽性能，管线越多（通常设计到 <code>x16</code>管线）则总带宽越高。</p>
<table>
<thead>
<tr>
<th>规格</th>
<th>1x带宽</th>
<th>16x带宽</th>
<th>速度</th>
</tr>
</thead>
<tbody><tr>
<td>PCIe 1.0</td>
<td>250MB&#x2F;s</td>
<td>4GB&#x2F;s</td>
<td>2.5 GT&#x2F;s</td>
</tr>
<tr>
<td>PCIe 2.0</td>
<td>500MB&#x2F;s</td>
<td>8GB&#x2F;s</td>
<td>5 GT&#x2F;s</td>
</tr>
<tr>
<td>PCIe 3.0</td>
<td>1GB&#x2F;s</td>
<td>16GB&#x2F;s</td>
<td>8 GT&#x2F;s</td>
</tr>
<tr>
<td>PCIe 4.0</td>
<td>2GB&#x2F;s</td>
<td>32GB&#x2F;s</td>
<td>16 GT&#x2F;s</td>
</tr>
<tr>
<td>PCIe 5.0</td>
<td>4GB&#x2F;s</td>
<td>64GB&#x2F;s</td>
<td>32 GT&#x2F;s</td>
</tr>
</tbody></table>
<h2 id="硬盘和储存设备"><a href="#硬盘和储存设备" class="headerlink" title="硬盘和储存设备"></a>硬盘和储存设备</h2><p>硬盘（Hard Disk Drive，HDD）是一种用于存储数据的计算机存储设备，它由多个磁性盘片（通常为金属或玻璃材料制成）组成，盘片上覆盖有磁性材料，用来存储数据。</p>
<h4 id="结构和工作原理"><a href="#结构和工作原理" class="headerlink" title="结构和工作原理"></a>结构和工作原理</h4><h5 id="磁盘和磁头"><a href="#磁盘和磁头" class="headerlink" title="磁盘和磁头"></a><strong>磁盘和磁头</strong></h5><ul>
<li><strong>磁盘片</strong>：硬盘内部有一个或多个磁盘片，通常是金属或玻璃材料制成，表面上有一层磁性材料。</li>
<li><strong>磁头</strong>：每个磁盘片的两面都有读写磁头，负责在盘片表面上读取和写入数据。</li>
</ul>
<h5 id="数据存储原理："><a href="#数据存储原理：" class="headerlink" title="数据存储原理："></a><strong>数据存储原理</strong>：</h5><ul>
<li><strong>磁性记录</strong>：硬盘通过在磁盘片表面创建的磁性颗粒来记录数据。这些颗粒在磁场的作用下会根据磁性状况的不同，存储0和1的数据。</li>
</ul>
<h5 id="工作过程："><a href="#工作过程：" class="headerlink" title="工作过程："></a><strong>工作过程</strong>：</h5><ul>
<li><strong>读取数据</strong>：当计算机需要读取硬盘上的数据时，磁头会定位到相应的磁道（一个圆形的路径），并读取相应的磁性颗粒上的数据。</li>
<li><strong>写入数据</strong>：写入数据时，磁头会通过改变磁性颗粒的磁性状态来记录新的数据</li>
</ul>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><h5 id="传统硬盘驱动器（HDD）："><a href="#传统硬盘驱动器（HDD）：" class="headerlink" title="传统硬盘驱动器（HDD）："></a><strong>传统硬盘驱动器（HDD）</strong>：</h5><ul>
<li><strong>机械结构</strong>：传统HDD内部有机械运动部件，如旋转的磁盘片和移动的读写磁头。</li>
<li><strong>容量</strong>：通常具有较大的存储容量，目前主流产品容量从几百GB到数TB不等。</li>
<li><strong>成本</strong>：相对于其他存储设备（如固态硬盘），传统HDD通常价格更低。</li>
</ul>
<h5 id="固态硬盘（SSD）："><a href="#固态硬盘（SSD）：" class="headerlink" title="固态硬盘（SSD）："></a><strong>固态硬盘（SSD）</strong>：</h5><ul>
<li><strong>基于闪存技术</strong>：SSD使用闪存芯片而非机械部件来存储数据，因此没有机械运动，速度更快。</li>
<li><strong>速度</strong>：读写速度比传统HDD快得多，适合需要快速访问数据的应用。</li>
<li><strong>耐用性</strong>：由于没有移动部件，SSD通常比传统HDD更耐用，对震动和冲击更具抵抗力</li>
</ul>
<h4 id="数据存储和访问的物理结构"><a href="#数据存储和访问的物理结构" class="headerlink" title="数据存储和访问的物理结构"></a>数据存储和访问的物理结构</h4><h5 id="扇区（Sector）"><a href="#扇区（Sector）" class="headerlink" title="扇区（Sector）"></a>扇区（Sector）</h5><ul>
<li><strong>定义</strong>：扇区是硬盘上最小的物理数据存储单元。每个扇区可以存储固定大小的数据块。</li>
<li><strong>大小</strong>：传统硬盘通常的扇区大小为512字节或4KB（4096字节）。SSD的扇区大小可能会有所不同，通常为4KB或更大。</li>
<li><strong>作用</strong>：操作系统和硬件使用扇区来读取和写入数据，扇区的大小决定了硬盘能够存储和处理的最小数据单位。</li>
</ul>
<h5 id="磁道（Track）"><a href="#磁道（Track）" class="headerlink" title="磁道（Track）"></a>磁道（Track）</h5><ul>
<li><strong>定义</strong>：磁道是硬盘盘片表面上的一个圆形轨道，沿着盘片的半径方向布置。</li>
<li><strong>结构</strong>：硬盘通常有多个磁道，每个磁道被划分为多个扇区。同一个磁道上的扇区具有相同的物理距离，这有助于保持读写数据的稳定性和一致性。</li>
<li><strong>作用</strong>：磁道用于组织和管理硬盘上的数据，操作系统可以通过磁头在磁道上的移动来访问不同扇区中的数据。</li>
</ul>
<h5 id="柱面（Cylinder）"><a href="#柱面（Cylinder）" class="headerlink" title="柱面（Cylinder）"></a>柱面（Cylinder）</h5><ul>
<li><strong>定义</strong>：柱面是所有盘片上相同半径位置的磁道的集合体。换句话说，所有盘片上垂直于盘片表面的磁道构成一个柱面。</li>
<li><strong>结构</strong>：硬盘通常有多个盘片，每个盘片上有多个磁道，多个盘片上对应的磁道构成一个柱面。例如，第一个磁头上的第一个磁道，第二磁头上的第一个磁道等等。</li>
<li><strong>作用</strong>：操作系统使用柱面来组织和优化磁头的访问顺序，通过在同一柱面上的不同磁头移动，可以快速访问多个盘片上的数据。</li>
</ul>
<h5 id="物理布局和优化"><a href="#物理布局和优化" class="headerlink" title="物理布局和优化"></a>物理布局和优化</h5><ul>
<li><strong>寻道</strong>：硬盘读取数据时，磁头必须移动到正确的磁道上，这个过程称为寻道。</li>
<li><strong>扇区间隙和同步</strong>：相邻扇区之间通常有间隙和同步字段，用于确保数据的正确读取和写入。</li>
<li><strong>数据组织</strong>：操作系统和硬件通过优化磁道和柱面的访问顺序来最大化硬盘的性能和效率。</li>
</ul>
<h4 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h4><h5 id="MBR（Master-Boot-Record）"><a href="#MBR（Master-Boot-Record）" class="headerlink" title="MBR（Master Boot Record）"></a>MBR（Master Boot Record）</h5><p>传统的分区方案和引导加载程序，用于BIOS（Basic Input&#x2F;Output System）和早期UEFI系统</p>
<ul>
<li>限制：MBR支持的最大磁盘容量为2TB（2^32个扇区），最多支持 4个主分区 或者 3个主分区 和 1个扩展分区</li>
<li>结构：MBR存储在硬盘的第一个扇区（通常是512字节），包括分区表（Partition Table）（64字节）和引导加载程序（Bootloader）</li>
<li>主分区是MBR分区方案中的基本分区类型，最多支持4个主分区</li>
<li>扩展分区是一种特殊的主分区，用于扩展MBR分区方案的分区数量限制</li>
</ul>
<p>有三种类型的分区</p>
<ul>
<li>主分区（Primary Partition）<ul>
<li>MBR分区方案中的基本分区类型，最多支持4个主分区</li>
<li>每个主分区可以包含一个操作系统或数据</li>
<li>可以直接被操作系统识别和引导</li>
<li>每个主分区被描述为一个分区条目，占据分区表的一个条目</li>
</ul>
</li>
<li>扩展分区（Extended Partition）<ul>
<li>一种特殊的主分区，用于扩展MBR分区方案的分区数量限制</li>
<li>只能有一个扩展分区，可以包含多个逻辑分区</li>
<li>本身并不存储文件数据，它仅用于存放其他逻辑分区的信息</li>
</ul>
</li>
<li>逻辑分区<ul>
<li>逻辑分区是存在于扩展分区内的分区，用于克服主分区数量限制</li>
<li>通常用于存储数据，不能直接被操作系统引导</li>
<li>逻辑分区的数量没有明确的限制，只受扩展分区的容量限制</li>
</ul>
</li>
</ul>
<h5 id="GPT（GUID-Partition-Table）"><a href="#GPT（GUID-Partition-Table）" class="headerlink" title="GPT（GUID Partition Table）"></a>GPT（GUID Partition Table）</h5><p>一种现代的分区方案和引导加载程序，设计用于替代 MBR，并广泛支持UEFI（Unified Extensible Firmware Interface）系统</p>
<ul>
<li>容量：GPT支持更大的硬盘容量，最多可达到约8ZB（2^64个扇区，1ZB &#x3D; 230TB）</li>
<li>分区数量：GPT支持128个分区条目，每个分区条目可以是主分区或逻辑分区，且没有主扩展分区的限制</li>
<li>结构：GPT在硬盘的起始位置（通常是第一个扇区）存储主要GPT头（Primary GPT Header）和GPT备份表（Backup GPT Header and Partition Table），这些信息在硬盘上多个位置进行存储，提供了容错性</li>
</ul>
<blockquote>
<p>使用 lscpu 或 cat &#x2F;proc&#x2F;cpuinfo 或 lspci 查看主板各元件信息</p>
</blockquote>
<h1 id="二、Linux学习"><a href="#二、Linux学习" class="headerlink" title="二、Linux学习"></a>二、Linux学习</h1><p>Linux的核心原型是1991年由托瓦兹（Linus Torvalds）写出来的。</p>
<p>Linux的核心版本编号如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看内核版本</span></span><br><span class="line">$ <span class="built_in">uname</span> -r</span><br><span class="line">4.18.0-348.7.1.el8_5.x86_64</span><br><span class="line"><span class="comment"># 各参数说明</span></span><br><span class="line">主版本号（Linux内核的主要版本号）：4</span><br><span class="line">次版本号（内核的次要版本更新）：18</span><br><span class="line">修订版本号（对次版本的小的修正和错误修复）：0</span><br><span class="line">内核编译号（Linux内核编译时的唯一标识）：348</span><br><span class="line">ABI（Application Binary Interface）变化序号（内核与用户空间之间的接口是否发生了变化）：7</span><br><span class="line">发布序号（用于指示特定版本的修订或维护更新）：1</span><br><span class="line">发行标签（表示此内核是为特定的Linux发行版编译的）：el8_5（适用于RHEL 8.5（Red Hat Enterprise Linux 8.5）发行版）</span><br><span class="line">处理器架构（内核编译的目标处理器架构）：x86_64</span><br></pre></td></tr></table></figure>

<p>在Linux系统中，<strong>万物皆为文件</strong></p>
<blockquote>
<p> 比如：SATA接口的硬盘的文件名称即为&#x2F;dev&#x2F;sd[a-d]</p>
</blockquote>
<h2 id="目录树结构"><a href="#目录树结构" class="headerlink" title="目录树结构"></a>目录树结构</h2><p>所谓的目录树结构（directory tree），就是以根目录为主，然后向下呈现分支状的目录结构的一种文件架构。整个目录树架构最重要的就是那个根目录（root directory），用 <code>/</code> 表示，所有的文件都与目录树有关。</p>
<pre class="mermaid">graph TD;
    / --> /etc
    / --> /bin
    / --> /home
    / --> /usr
    / --> ...
    /home --> /www
    /home --> /test
    /test --> 1> 1.txt]
    /test --> 2> 2.txt]</pre>

<h2 id="挂载（文件系统与目录树的关系）"><a href="#挂载（文件系统与目录树的关系）" class="headerlink" title="挂载（文件系统与目录树的关系）"></a>挂载（文件系统与目录树的关系）</h2><p>利用一个目录（挂载点）当成进入点，将磁盘分区的数据放置在该目录下，即进入该目录就可以读取该分区的意思</p>
<blockquote>
<p>如何判断某个文件在哪个partition下</p>
<ul>
<li><p>使用 <code>df</code> 命令</p>
<p>df -h &#x2F;path&#x2F;to&#x2F;your&#x2F;file</p>
</li>
<li><p>使用findmnt命令</p>
<p>findmnt -n -o SOURCE –target &#x2F;path&#x2F;to&#x2F;your&#x2F;file</p>
</li>
<li><p>stat命令</p>
<p>stat -c %D &#x2F;path&#x2F;to&#x2F;your&#x2F;file</p>
</li>
<li><p>通过 <code>/proc</code> 文件系统查看</p>
<p>grep &#x2F;path&#x2F;to&#x2F;your&#x2F;file &#x2F;proc&#x2F;mounts</p>
</li>
</ul>
</blockquote>
<h2 id="Linux系统安装"><a href="#Linux系统安装" class="headerlink" title="Linux系统安装"></a>Linux系统安装</h2><p>以CentOS7为例</p>
<ul>
<li>烧录镜像到到 U盘</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># USB 设备为 /dev/sdc</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=centos7.iso of=/dev/sdc</span><br></pre></td></tr></table></figure>

<ul>
<li>进入BIOS（一般是重启后狂按<code>del</code>或<code>F2</code>）</li>
<li>关闭安全启动</li>
<li>调整开机启动速度，将U盘调整到第一优先开机，F10保存并退出</li>
<li>安装Linux系统（这块后面补充）</li>
</ul>
<blockquote>
<p>关于<code>swap</code>分区：</p>
<p>内存交换空间的功能是：当有数据被存放在内存里面，但又不是常被CPU所取用时，那么这些不常被使用的程序将会被丢到硬盘的swap交换空间当中，将内存空间释放出来给真正需要的程序使用！目前机器内存都比较大，所以一般分配 swap 1-2G足够。</p>
</blockquote>
<h3 id="Kickstart-配置文件"><a href="#Kickstart-配置文件" class="headerlink" title="Kickstart 配置文件"></a>Kickstart 配置文件</h3><p>Kickstart 是 Red Hat 系统上用于自动化安装的一种方法，允许用户定义安装过程中的各种参数和配置选项，从而实现无人值守安装。</p>
<p><code>/root/anaconda-ks.cfg</code> 文件是 Anaconda 安装程序使用的 Kickstart 配置文件。在 Linux 系统中，特别是在基于 Red Hat 的发行版（如 CentOS、Fedora）中，Anaconda 是用于系统安装的图形化和文本界面安装程序。</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul>
<li><p><strong>自动化安装</strong>：通过定义 Kickstart 文件，可以指定安装过程中需要的各种配置选项，如分区设置、软件包选择、网络配置、用户账号等。</p>
</li>
<li><p><strong>批量部署</strong>：Kickstart 文件可以用于批量部署多台机器，确保所有安装过程的配置和参数一致。</p>
</li>
<li><p><strong>简化配置</strong>：避免手动输入和配置，尤其是在大规模部署和测试环境中，可以大大提高效率和减少错误。</p>
</li>
</ul>
<h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h4><ul>
<li>准备 Kickstart 文件，如<code>/root/anaconda-ks.cfg</code> </li>
<li>准备安装介质，如U盘</li>
<li>重启进入引导界面</li>
<li>输入 <code>linux ks=hd:sda1/anaconda-ks.cfg</code>后回车，假设 Kickstart 文件在 sda1 分区上的根目录下</li>
</ul>
<blockquote>
<p> 登陆成功后终端显示如下，其中<code>test</code>表示目前使用者的账号，@之后接的 <code>172-12-0-1</code>是主机名称，<code>~</code>指当前目录（在这里 ~ 等同于 &#x2F;home&#x2F;test），<code>$</code>是提示字符（root用户是#，普通用户是$）</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># root用户</span></span><br><span class="line">[root@172-12-0-1 ~]#</span><br><span class="line"><span class="comment"># 一般用户</span></span><br><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$</span><br></pre></td></tr></table></figure>

<p>登出系统</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 登出当前的终端会话，不是关机</span></span><br><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ <span class="built_in">exit</span></span><br><span class="line"><span class="comment"># 效果同exit</span></span><br><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ <span class="built_in">logout</span></span><br><span class="line"><span class="comment"># 使用Ctrl + D组合键</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制关闭指定用户的所有会话，可能需要管理员权限</span></span><br><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ pkill -KILL -u &lt;username&gt;</span><br></pre></td></tr></table></figure>

<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ <span class="built_in">command</span>  [-options]  parameter1  parameter2 ...</span><br><span class="line"><span class="comment">#						指令		选项		  参数（1）	   参数（2）</span></span><br></pre></td></tr></table></figure>

<ul>
<li>command: 可以是指令或可执行文件</li>
<li>中刮号<code>[]</code>里边是可选的指令，比如 <code>-h</code> 或者 <code>--help</code>（完整全名需要使用 <code>--</code>）</li>
<li>指令太长的时候，可以使用反斜线（<code>\</code>）来换行</li>
<li>指令大小写含义是不同的</li>
</ul>
<h2 id="基础指令"><a href="#基础指令" class="headerlink" title="基础指令"></a>基础指令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看当前日期和时间</span></span><br><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ <span class="built_in">date</span></span><br><span class="line"><span class="comment"># 格式化为 yyyy/MM/dd 格式</span></span><br><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ <span class="built_in">date</span> +%Y/%m/%d</span><br><span class="line"><span class="comment"># 格式化为 HH:mm:ss格式</span></span><br><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ <span class="built_in">date</span> +%H:%M:%S</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示日历</span></span><br><span class="line"><span class="comment"># cal [month] [year]</span></span><br><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ cal</span><br><span class="line"><span class="comment"># 显示一年的日历</span></span><br><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ cal 2024</span><br><span class="line"><span class="comment"># 显示某一年某一月的日历</span></span><br><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ cal 8 2024</span><br></pre></td></tr></table></figure>

<h2 id="中文乱码问题"><a href="#中文乱码问题" class="headerlink" title="中文乱码问题"></a>中文乱码问题</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ locale</span><br><span class="line"><span class="comment"># 语言语系的输出</span></span><br><span class="line">LANG=zh_CN.UTF-8</span><br><span class="line"><span class="comment"># 下面为许多信息的输出使用的特别语系</span></span><br><span class="line">LC_CTYPE=<span class="string">&quot;zh_CN.UTF-8&quot;</span></span><br><span class="line">LC_NUMERIC=<span class="string">&quot;zh_CN.UTF-8&quot;</span></span><br><span class="line"><span class="comment"># 时间方面的语系数据</span></span><br><span class="line">LC_TIME=<span class="string">&quot;zh_CN.UTF-8&quot;</span></span><br><span class="line">LC_COLLATE=<span class="string">&quot;zh_CN.UTF-8&quot;</span></span><br><span class="line">...</span><br><span class="line"><span class="comment"># 全部的数据同步更新的设置值</span></span><br><span class="line">LC_ALL=</span><br></pre></td></tr></table></figure>

<h3 id="修改语言"><a href="#修改语言" class="headerlink" title="修改语言"></a>修改语言</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 临时修改为英文（exit后失效）</span></span><br><span class="line"><span class="comment"># LANG 只与输出讯息有关，若需要更改其他不同的信息，要同步更新 LC_ALL 才行</span></span><br><span class="line"><span class="comment"># 等号两边没有空白字符</span></span><br><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ LANG=en_US.utf8</span><br><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ <span class="built_in">export</span> LC_ALL=en_US.utf8</span><br></pre></td></tr></table></figure>

<h2 id="计算器：bc"><a href="#计算器：bc" class="headerlink" title="计算器：bc"></a>计算器：bc</h2><ul>
<li><p>安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 确认是否安装</span></span><br><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ bc --version</span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ <span class="built_in">sudo</span> yum install -y bc</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用</p>
<ul>
<li><p>基础计算</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ <span class="built_in">echo</span> <span class="string">&quot;2 + 3&quot;</span> | bc</span><br></pre></td></tr></table></figure>
</li>
<li><p>浮点数计算</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 需要设置小数点的精度scale</span></span><br><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ <span class="built_in">echo</span> <span class="string">&quot;scale=2; 5 / 3&quot;</span> | bc</span><br></pre></td></tr></table></figure>
</li>
<li><p>变量和表达式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ <span class="built_in">echo</span> <span class="string">&quot;a=5; b=3; a * b&quot;</span> | bc</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数和计算</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ <span class="built_in">echo</span> <span class="string">&quot;scale=2; sqrt(16)&quot;</span> | bc</span><br><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ <span class="built_in">echo</span> <span class="string">&quot;scale=2; 2^3&quot;</span> | bc</span><br></pre></td></tr></table></figure>
</li>
<li><p>从文件读取表达式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ <span class="built_in">echo</span> <span class="string">&quot;3 + 4&quot;</span> &gt; calc.txt</span><br><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ bc &lt; calc.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>交互式模式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ bc</span><br><span class="line"><span class="comment"># ENTER</span></span><br><span class="line">scale=3</span><br><span class="line">22 / 7</span><br></pre></td></tr></table></figure>
</li>
<li><p>启用数学库，使用 <code>-l</code> 选项启用数学库，提供更多函数支持（如对数、三角函数等）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算 10 的自然对数</span></span><br><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ <span class="built_in">echo</span> <span class="string">&quot;scale=2; l(10)&quot;</span> | bc -l</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>退出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ quit</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Tab代码补全"><a href="#Tab代码补全" class="headerlink" title="Tab代码补全"></a>Tab代码补全</h2><h3 id="代码补全"><a href="#代码补全" class="headerlink" title="代码补全"></a>代码补全</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果d有多个，显示所有d开头的指令，同样适用于文件补全</span></span><br><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ d[Tab][Tab]</span><br><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ <span class="built_in">ls</span> -al ~/.bash[tab][tab]</span><br><span class="line"><span class="comment"># 如果da开头指令只有一个，自动补全</span></span><br><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ da[Tab]</span><br></pre></td></tr></table></figure>

<h3 id="参数-选项补齐"><a href="#参数-选项补齐" class="headerlink" title="参数&#x2F;选项补齐"></a>参数&#x2F;选项补齐</h3><ul>
<li><p>安装<code>bash-completion</code>软件，只适用于 <code>bash</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ <span class="built_in">sudo</span> yum install -y bash-completion</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ <span class="built_in">date</span> --[Tab][Tab]</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果验证不生效，启用 <code>bash-completion</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开 ~/.bashrc 文件，这里使用vim</span></span><br><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ <span class="built_in">sudo</span> vim ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>在文件末尾添加以下行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Enable bash completion</span><br><span class="line">if [ -f /etc/profile.d/bash_completion.sh ]; then</span><br><span class="line">    . /etc/profile.d/bash_completion.sh</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>重新加载配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ <span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="向前向后翻页"><a href="#向前向后翻页" class="headerlink" title="向前向后翻页"></a>向前向后翻页</h2><ul>
<li><p>向前：Shift + PageUp</p>
</li>
<li><p>向后：Shift + PageDown</p>
</li>
</ul>
<h2 id="命令帮助文档"><a href="#命令帮助文档" class="headerlink" title="命令帮助文档"></a>命令帮助文档</h2><h3 id="指令的help求助"><a href="#指令的help求助" class="headerlink" title="指令的help求助"></a>指令的help求助</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">test</span>@172-12-0-1 <span class="built_in">test</span>]$ <span class="built_in">date</span> --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">用法：<span class="built_in">date</span> [选项]... [+格式]	<span class="comment"># 基本语法</span></span><br><span class="line">　或：<span class="built_in">date</span> [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]	<span class="comment"># 设置时间的语法</span></span><br><span class="line">Display the current time <span class="keyword">in</span> the given FORMAT, or <span class="built_in">set</span> the system <span class="built_in">date</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面是主要的选项说明</span></span><br><span class="line">必选参数对长短选项同时适用。</span><br><span class="line">  -d, --<span class="built_in">date</span>=STRING          display time described by STRING, not <span class="string">&#x27;now&#x27;</span></span><br><span class="line">      --debug                annotate the parsed <span class="built_in">date</span>,</span><br><span class="line">                              and warn about questionable usage to stderr</span><br><span class="line">  -f, --file=DATEFILE        like --<span class="built_in">date</span>; once <span class="keyword">for</span> each line of DATEFILE</span><br><span class="line">  ...</span><br><span class="line">  -u, --utc, --universal     <span class="built_in">print</span> or <span class="built_in">set</span> Coordinated Universal Time (UTC)</span><br><span class="line">      --<span class="built_in">help</span>		显示此帮助信息并退出</span><br><span class="line">      --version		显示版本信息并退出</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面是格式化（FORMAT）的主要项目</span></span><br><span class="line">给定的格式FORMAT 控制着输出，解释序列如下：</span><br><span class="line"></span><br><span class="line">  %%	一个文字的 %</span><br><span class="line">  %a	当前locale 的星期名缩写(例如： 日，代表星期日)</span><br><span class="line">  %A	当前locale 的星期名全称 (如：星期日)</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面是几个重要的范例（Example）</span></span><br><span class="line">Examples:</span><br><span class="line">Convert seconds since the epoch (1970-01-01 UTC) to a <span class="built_in">date</span></span><br><span class="line">  $ <span class="built_in">date</span> --<span class="built_in">date</span>=<span class="string">&#x27;@2147483647&#x27;</span></span><br><span class="line"></span><br><span class="line">Show the time on the west coast of the US (use tzselect(1) to find TZ)</span><br><span class="line">  $ TZ=<span class="string">&#x27;America/Los_Angeles&#x27;</span> <span class="built_in">date</span></span><br><span class="line"></span><br><span class="line">Show the <span class="built_in">local</span> time <span class="keyword">for</span> 9AM next Friday on the west coast of the US</span><br><span class="line">  $ <span class="built_in">date</span> --<span class="built_in">date</span>=<span class="string">&#x27;TZ=&quot;America/Los_Angeles&quot; 09:00 next Fri&#x27;</span></span><br><span class="line"></span><br><span class="line">GNU coreutils 在线帮助：&lt;https://www.gnu.org/software/coreutils/&gt;</span><br><span class="line">请向 &lt;http://translationproject.org/team/zh_CN.html&gt; 报告 <span class="built_in">date</span> 的翻译错误</span><br><span class="line">完整文档请见：&lt;https://www.gnu.org/software/coreutils/date&gt;</span><br><span class="line">或者在本地使用：info <span class="string">&#x27;(coreutils) date invocation&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>通常 –help 用在协助你查询“你曾经用过的指令所具备的选项与参数”而已，如果你要使用的是从来没有用过得指令，或者是你要查询的根本就不是指令，而是<code>文件的格式</code>时，那就得要通过 man page </p>
</blockquote>
<h3 id="man-page"><a href="#man-page" class="headerlink" title="man page"></a>man page</h3><p>man是<code>manual</code>（操作说明）的简写，man page的数据通常放在<code>/usr/share/man/</code>下（可以在<code>/etc/man_db.conf</code> 配置）</p>
<ul>
<li>常用按键操作</li>
</ul>
<table>
<thead>
<tr>
<th>按键</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>Enter</td>
<td>显示下一行</td>
</tr>
<tr>
<td>空格 &#x2F; Page Down</td>
<td>向下翻一页</td>
</tr>
<tr>
<td>Page Up</td>
<td>向上翻一页</td>
</tr>
<tr>
<td>Home</td>
<td>回到首页</td>
</tr>
<tr>
<td>End</td>
<td>去到尾页</td>
</tr>
<tr>
<td>&#x2F;string</td>
<td>向下搜索字符串string</td>
</tr>
<tr>
<td>?string</td>
<td>向上搜索字符串string</td>
</tr>
<tr>
<td>n</td>
<td>向下搜索</td>
</tr>
<tr>
<td>N</td>
<td>向上搜索</td>
</tr>
<tr>
<td>q</td>
<td>退出man page</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">test</span>@172-12-0-1 <span class="built_in">test</span>]$ man <span class="built_in">date</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 请注意上面这个括号内的数字</span></span><br><span class="line">DATE(1)                  			User Commands              				    DATE(1)</span><br><span class="line"><span class="comment"># 这个指令的完整全名，如下所示为date且说明简单用途为设置与显示日期/时间</span></span><br><span class="line">NAME</span><br><span class="line">       <span class="built_in">date</span> - <span class="built_in">print</span> or <span class="built_in">set</span> the system <span class="built_in">date</span> and time</span><br><span class="line"><span class="comment"># 这个指令的基本语法如下所示</span></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="built_in">date</span> [OPTION]... [+FORMAT]</span><br><span class="line">       <span class="built_in">date</span> [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]</span><br><span class="line"><span class="comment"># 详细说明刚刚语法谈到的选项与参数的用法</span></span><br><span class="line">DESCRIPTION</span><br><span class="line">       Display the current time <span class="keyword">in</span> the given FORMAT, or <span class="built_in">set</span> the system <span class="built_in">date</span>.</span><br><span class="line"></span><br><span class="line">       Mandatory arguments to long options are mandatory <span class="keyword">for</span> short options too.</span><br><span class="line"></span><br><span class="line">       -d, --<span class="built_in">date</span>=STRING</span><br><span class="line">              display time described by STRING, not <span class="string">&#x27;now&#x27;</span></span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">       --version</span><br><span class="line">              output version information and <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化输出的详细数据</span></span><br><span class="line">       FORMAT controls the output.  Interpreted sequences are:</span><br><span class="line"></span><br><span class="line">       %%     a literal %</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">       %Z     alphabetic time zone abbreviation (e.g., EDT)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">EXAMPLES</span><br><span class="line">       Convert seconds since the epoch (1970-01-01 UTC) to a <span class="built_in">date</span></span><br><span class="line"></span><br><span class="line">              $ <span class="built_in">date</span> --<span class="built_in">date</span>=<span class="string">&#x27;@2147483647&#x27;</span></span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># date 的格式说明</span></span><br><span class="line">DATE STRING</span><br><span class="line">       The --<span class="built_in">date</span>=STRING is a mostly free format human readable <span class="built_in">date</span> string such as <span class="string">&quot;Sun, 29 Feb 2004 16:21:42 -0800&quot;</span> or <span class="string">&quot;2004-02-29 16:21:42&quot;</span> or even <span class="string">&quot;next Thursday&quot;</span>.  A <span class="built_in">date</span> string may contain items indicating calendar  <span class="built_in">date</span>,  time  of</span><br><span class="line">       day, time zone, day of week, relative time, relative <span class="built_in">date</span>, and numbers.  An empty string indicates the beginning of the day.  The <span class="built_in">date</span> string format is more complex than is easily documented here but is fully described <span class="keyword">in</span> the info</span><br><span class="line">       documentation.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 与这个指令相关的环境参数说明</span></span><br><span class="line">ENVIRONMENT</span><br><span class="line">       TZ     Specifies the timezone, unless overridden by <span class="built_in">command</span> line parameters.  If neither is specified, the setting from /etc/localtime is used.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还可以从哪里查到与date相关的说明文档</span></span><br><span class="line">SEE ALSO</span><br><span class="line">       Full documentation at: &lt;https://www.gnu.org/software/coreutils/date&gt;</span><br><span class="line">       or available locally via: info <span class="string">&#x27;(coreutils) date invocation&#x27;</span></span><br><span class="line"></span><br><span class="line">GNU coreutils 8.30                       July 2018       				          DATE(1)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面第一行出现的<code>DATE(1)</code>是什么意思呢</p>
<p>使用 <code>man man</code> 可以查看更多信息</p>
<table>
<thead>
<tr>
<th>代号</th>
<th>代表内容</th>
<th>重要</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>使用者在shell环境中可以操作的指令或可可执行文件</td>
<td>Y</td>
</tr>
<tr>
<td>2</td>
<td>系统核心可调用的函数与工具等</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>一些常用的函数（function）与函数库（library），大部分为C的函数库（libc）</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>设备文件的说明，通常在&#x2F;dev下的文件</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>配置文件或者是某些文件的格式</td>
<td>Y</td>
</tr>
<tr>
<td>6</td>
<td>游戏（games）</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>惯例与协定等，例如Linux文件系统、网络协定、ASCII code等等的说明</td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>系统管理员可用的管理指令</td>
<td>Y</td>
</tr>
<tr>
<td>9</td>
<td>跟kernel有关的文件</td>
<td></td>
</tr>
</tbody></table>
</blockquote>
<h4 id="搜寻特定指令-文件的man-page说明文档"><a href="#搜寻特定指令-文件的man-page说明文档" class="headerlink" title="搜寻特定指令&#x2F;文件的man page说明文档"></a>搜寻特定指令&#x2F;文件的man page说明文档</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 -f 这个选项就可以取得更多与man相关的信息</span></span><br><span class="line">[<span class="built_in">test</span>@172-12-0-1 /]$ man -f info</span><br><span class="line">info (5)             - readable online documentation</span><br><span class="line">info (1)             - <span class="built_in">read</span> Info documents</span><br><span class="line"><span class="comment"># 等同于 whatis [指令或数据]，如果使用不了，可以切换root用户执行 mandb</span></span><br><span class="line">[<span class="built_in">test</span>@172-12-0-1 /]$ mandb</span><br><span class="line">[<span class="built_in">test</span>@172-12-0-1 /]$ whatis info</span><br><span class="line"></span><br><span class="line"><span class="comment"># man info会使用哪个说明文档，跟/etc/man_db.conf配置的顺序有关，通常会使用数字小的</span></span><br><span class="line"><span class="comment"># 也可以手动去指定</span></span><br><span class="line">[<span class="built_in">test</span>@172-12-0-1 /]$ man 1 info</span><br><span class="line">[<span class="built_in">test</span>@172-12-0-1 /]$ man 5 info</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出系统说明文档中包含某个字符串的文件</span></span><br><span class="line"><span class="comment"># man -k string</span></span><br><span class="line"><span class="comment"># 等同于 apropos [指令或数据]</span></span><br><span class="line">[<span class="built_in">test</span>@172-12-0-1 /]$ man -k info</span><br><span class="line">[<span class="built_in">test</span>@172-12-0-1 /]$ apropos info</span><br></pre></td></tr></table></figure>

<h3 id="info-page"><a href="#info-page" class="headerlink" title="info page"></a>info page</h3><ol>
<li><p>与 <code>man page</code> 一次性输出一堆信息不同，<code>info page</code> 是将文件数据拆成一个一个的段落，每个段落用自己的页面来撰写，并且在各个页面中还有类似网页的“超链接”来跳到各不同的页面中，每个独立的页面也被称为一个节点（node）</p>
</li>
<li><p>支持info指令的文件放置在<code>/usr/share/info/</code>目录中。</p>
</li>
<li><p>查询的指令说明要具有info page功能的话，得用info page的格式来写成线上求助文件才行，否则展示效果同man page</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>N</td>
<td>前往下一个Node处</td>
</tr>
<tr>
<td>P</td>
<td>前往上一个Node处</td>
</tr>
<tr>
<td>U</td>
<td>向上移动一层</td>
</tr>
<tr>
<td>Tab</td>
<td>在Node节点间移动（有 node 的地方，通常会以 * 显示）</td>
</tr>
<tr>
<td>空白键 &#x2F; Page Down</td>
<td>向下翻一页</td>
</tr>
<tr>
<td>Page Up</td>
<td>向上翻一页</td>
</tr>
<tr>
<td>Enter</td>
<td>光标在Node上时，可以进入该Node节点</td>
</tr>
<tr>
<td>b</td>
<td>移动光标到该 info 画面当中的第一个 node 处</td>
</tr>
<tr>
<td>e</td>
<td>移动光标到该 info 画面当中的最后一个 node 处</td>
</tr>
<tr>
<td>s  或  &#x2F;</td>
<td>在 info page 当中进行搜索</td>
</tr>
<tr>
<td>h 或 ?</td>
<td>显示求助菜单</td>
</tr>
<tr>
<td>q</td>
<td>退出</td>
</tr>
</tbody></table>
<h3 id="其他有用的文件（documents）"><a href="#其他有用的文件（documents）" class="headerlink" title="其他有用的文件（documents）"></a>其他有用的文件（documents）</h3><p>在<code>/usr/share/doc</code>目录下，数据主要是以套件（packages）为主的，例如 git 的相关信息在 &#x2F;usr&#x2F;share&#x2F;doc&#x2F;git</p>
<h2 id="关机"><a href="#关机" class="headerlink" title="关机"></a>关机</h2><p>在 Linux 下面，有很多人在主机上面工作，直接按下电源开关来关机时，则其他人的数据可能就此中断。若不正常关机，则可能造成文件系统的毁损（因为来不及将数据回写到文件中，所以有些服务的文件会有问题！），所以关机需要注意：</p>
<ul>
<li><p>观察系统的使用状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看谁在线</span></span><br><span class="line">[<span class="built_in">test</span>@172-12-0-1 /]$ <span class="built_in">who</span></span><br><span class="line"><span class="comment"># 查看网络连线状态</span></span><br><span class="line">[<span class="built_in">test</span>@172-12-0-1 /]$ netstat -a</span><br><span class="line"><span class="comment"># 查看执行程序</span></span><br><span class="line">[<span class="built_in">test</span>@172-12-0-1 /]$ ps -aux</span><br></pre></td></tr></table></figure>
</li>
<li><p>通知线上使用者关机的时刻，使用 <code>shutdown </code>指令</p>
</li>
</ul>
<p>几个与关机相关的命令</p>
<ul>
<li>将数据同步写入硬盘中的指令： sync<ul>
<li>在Linux系统中，为了加快数据的读取速度，所以在默认的情况中，某些已经载入内存中的数据将不会直接被写回硬盘，而是先暂存在内存当中</li>
<li>使用root账号执行，可以更新整个系统中的数据，否则只能更新单个用户的数据</li>
</ul>
</li>
<li>惯用的关机指令： shutdown</li>
<li>重新开机，关机： reboot &#x2F; halt &#x2F; poweroff<ul>
<li>这些指令在关机前进行了 sync 这个工具的调用</li>
<li>这些指令都是调用 systemctl 这个重要的管理命令</li>
</ul>
</li>
</ul>
<h1 id="三、Linux的文件权限与目录配置"><a href="#三、Linux的文件权限与目录配置" class="headerlink" title="三、Linux的文件权限与目录配置"></a>三、Linux的文件权限与目录配置</h1><p>Linux一般将文件可存取的身份分为三个类别，分别是 <code>owner/group/others</code>，且三种身份各有 <code>read/write/execute</code> 等权限</p>
<ul>
<li><p>owner（所有者）</p>
<ul>
<li><strong>定义</strong>：每个文件和目录都有一个所有者，通常是创建文件的用户。所有者对文件有特定的权限，可以是读取、写入或执行。</li>
<li><strong>权限表示</strong>：在文件权限的表示中，所有者的权限通常是权限字符串的第一个三位部分。例如，<code>-rwxr-xr--</code> 中的 <code>rwx</code> 表示所有者的权限。</li>
</ul>
</li>
<li><p>group（组）</p>
<ul>
<li><p><strong>定义</strong>：文件和目录的每个所有者都有一个关联的用户组。文件或目录的权限可以授予该组的所有成员。组权限使得同组的用户可以共享对文件的访问权。</p>
</li>
<li><p><strong>权限表示</strong>：在权限字符串中，组的权限是第二个三位部分。例如，<code>-rwxr-xr--</code> 中的 <code>r-x</code> 表示组用户的权限。</p>
</li>
</ul>
</li>
<li><p>others（其他用户）</p>
<ul>
<li><p><strong>定义</strong>：除文件所有者和文件所属组的用户之外的所有其他用户。这类用户的权限控制是为了保护文件不被不相关的用户访问。</p>
</li>
<li><p><strong>权限表示</strong>：在权限字符串中，其他用户的权限是第三个三位部分。例如，<code>-rwxr-xr--</code> 中的 <code>r--</code> 表示其他用户的权限。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>Linux使用者与群组记录的文件 </p>
<p>账号：&#x2F;etc&#x2F;passwd</p>
<p>密码：&#x2F;etc&#x2F;shadow</p>
<p>群组：&#x2F;etc&#x2F;group</p>
</blockquote>
<h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><p>使用 <code>ls -al</code> 可以查看文件权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@172-12-0-1 ~]# <span class="built_in">ls</span> -al</span><br><span class="line">总用量 148</span><br><span class="line">dr-xr-x---. 10 root root  4096 8月  12 10:51 .</span><br><span class="line">dr-xr-xr-x. 24 root root  4096 7月  30 17:11 ..</span><br><span class="line">-rw-------   1 root root 16635 8月  12 10:51 .bash_history</span><br><span class="line">-rw-r--r--   1 root root   234 7月  30 08:56 .bashrc</span><br><span class="line">drwxr-xr-x.  3 root root    17 7月  18 19:53 .cache</span><br><span class="line">drwx------   3 root root    25 7月  23 11:15 .config</span><br><span class="line">-rw-r--r--.  1 root root 47639 7月  16 11:45 install.sh</span><br><span class="line">drwxr-x---   4 root root    37 7月  29 18:00 .vim</span><br></pre></td></tr></table></figure>

<h3 id="ls-al-显示字段解释"><a href="#ls-al-显示字段解释" class="headerlink" title="ls -al 显示字段解释"></a><code>ls -al</code> 显示字段解释</h3><h4 id="文件类型和权限-第1个参数"><a href="#文件类型和权限-第1个参数" class="headerlink" title="文件类型和权限(第1个参数)"></a>文件类型和权限(第1个参数)</h4><ul>
<li><code>drwxr-xr-x</code> 文件的权限和类型<ul>
<li>第一个字符表示文件类型<ul>
<li><code>-</code>：普通文件</li>
<li><code>d</code>：目录</li>
<li><code>l</code>：符号链接（link file）</li>
<li><code>c</code>：字符设备文件</li>
<li><code>b</code>：块设备文件</li>
<li><code>p</code>：命名管道（FIFO）</li>
<li><code>s</code>：套接字</li>
</ul>
</li>
<li>接下来的九个字符表示权限，没有权限时用 <code>-</code> 代替<ul>
<li><code>r</code>：读取权限，数字4表示</li>
<li><code>w</code>：写入权限，数字2表示</li>
<li><code>x</code>：执行权限，数字1表示</li>
</ul>
</li>
<li>权限分为三个部分，每部分三个字符<ul>
<li>所有者的权限</li>
<li>所属组的权限</li>
<li>其他用户的权限</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="硬链接数量（第2个参数）"><a href="#硬链接数量（第2个参数）" class="headerlink" title="硬链接数量（第2个参数）"></a>硬链接数量（第2个参数）</h4><ul>
<li>1：硬链接的数量。对于文件来说，通常是 <code>1</code>。对于目录，这个数字表示目录内包含的子目录数量加上 <code>.</code> 和 <code>..</code></li>
</ul>
<h4 id="所有者（第3个参数）"><a href="#所有者（第3个参数）" class="headerlink" title="所有者（第3个参数）"></a>所有者（第3个参数）</h4><ul>
<li><code>root</code>：文件或目录的所有者用户名。</li>
</ul>
<h4 id="所属组（第4个参数）"><a href="#所属组（第4个参数）" class="headerlink" title="所属组（第4个参数）"></a>所属组（第4个参数）</h4><ul>
<li><code>root</code>：文件或目录的所属组名。</li>
</ul>
<h4 id="文件大小（第5个参数）"><a href="#文件大小（第5个参数）" class="headerlink" title="文件大小（第5个参数）"></a>文件大小（第5个参数）</h4><ul>
<li><code>4096</code>：文件的大小，以字节为单位。对于目录，这个数字通常表示目录的元数据大小，而不是目录中文件的总大小</li>
</ul>
<h4 id="文件修改时间（第6个参数）"><a href="#文件修改时间（第6个参数）" class="headerlink" title="文件修改时间（第6个参数）"></a>文件修改时间（第6个参数）</h4><ul>
<li>8月  12 10:51：文件最后一次修改的日期和时间。格式通常为“月 日 时间”</li>
</ul>
<h4 id="文件名（第7个参数）"><a href="#文件名（第7个参数）" class="headerlink" title="文件名（第7个参数）"></a>文件名（第7个参数）</h4><ul>
<li><code>.bashrc</code>：文件或目录的名称，前面带<code>.</code>的是隐藏文件</li>
</ul>
<h2 id="改变文件属性和权限"><a href="#改变文件属性和权限" class="headerlink" title="改变文件属性和权限"></a>改变文件属性和权限</h2><ul>
<li><p>chgrp ：改变文件所属群组（changegroup）</p>
<ul>
<li>要被改变的群组名称必须要在<code>/etc/group</code>文件内存在才行</li>
</ul>
</li>
<li><p>chown ：改变文件拥有者（change owner）</p>
<ul>
<li>使用者必须是已经存在系统中的帐号，在<code>/etc/passwd</code> 这个文件中有纪录的使用者名称才能改变</li>
<li>还可以顺便修改群组的名称, <code>chown user:group file</code></li>
</ul>
</li>
<li><p>chmod ：改变文件的权限, SUID, SGID, SBIT等等的特性</p>
<ul>
<li>八进制模式<ul>
<li>权限用三位八进制数字表示，每位数字的范围是 <code>0</code> 到 <code>7</code><ul>
<li>4：读取权限 (<code>r</code>)</li>
<li>2：写入权限 (<code>w</code>)</li>
<li><strong>1</strong>：执行权限 (<code>x</code>)</li>
</ul>
</li>
<li>每种身份（owner&#x2F;group&#x2F;others）各自的三个权限（r&#x2F;w&#x2F;x）分数是累加的，比如<code>775</code> 代表 <code>-rwxrwxr-x</code></li>
</ul>
</li>
<li>符号模式<ul>
<li>符号模式使用字符表示权限<ul>
<li><code>u</code>：所有者（user）</li>
<li><code>g</code>：组（group）</li>
<li><code>o</code>：其他用户（others）</li>
<li><code>a</code>：所有用户（all）</li>
</ul>
</li>
<li>操作符：<ul>
<li><code>+</code>：添加权限</li>
<li><code>-</code>：移除权限</li>
<li><code>=</code>：设置权限</li>
</ul>
</li>
<li><code>-rwxr-xr-x</code> 可以设置为<code>chmod u=rwx,go=rx .bashrc</code>，<strong>其中u&#x3D;rwx,go&#x3D;rx间没有空格</strong></li>
<li>如果只想要增加<code>.bashrc</code>这个文件每个人均可写入的权限，可以使用 <code>chmod a+w .bashrc</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="FHS文件系统"><a href="#FHS文件系统" class="headerlink" title="FHS文件系统"></a>FHS文件系统</h2><p><strong>FHS（Filesystem Hierarchy Standard）</strong> 是一个定义 Linux 系统文件和目录结构的标准。FHS 提供了一个一致的文件系统布局指南，使得 Linux 发行版具有良好的兼容性和一致性。它规范了系统中常见的目录及其用途，便于系统管理员和开发人员理解和管理文件系统</p>
<h3 id="主要目录和其含义"><a href="#主要目录和其含义" class="headerlink" title="主要目录和其含义"></a>主要目录和其含义</h3><table>
<thead>
<tr>
<th>目录</th>
<th>中文名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;</td>
<td>根目录</td>
<td>文件系统的顶层目录，所有其他目录都挂载在这里</td>
</tr>
<tr>
<td>&#x2F;bin</td>
<td>基本用户命令</td>
<td>包含系统启动和修复所需的基本命令，如 <code>ls</code>, <code>cp</code>, <code>mv</code> 等</td>
</tr>
<tr>
<td>&#x2F;boot</td>
<td>启动文件</td>
<td>存放系统启动所需的文件，如内核映像（<code>vmlinuz</code>）和引导加载程序配置文件（<code>grub</code>）</td>
</tr>
<tr>
<td>&#x2F;dev</td>
<td>设备文件</td>
<td>包含设备文件，这些文件表示系统中的各种设备（如硬盘、终端等），通常是以 <code>char</code> 和 <code>block</code> 设备文件的形式存在</td>
</tr>
<tr>
<td>&#x2F;etc</td>
<td>系统配置文件</td>
<td>包含系统级别的配置文件和目录，如 <code>passwd</code>, <code>fstab</code>, <code>network</code>, 和其他系统配置文件</td>
</tr>
<tr>
<td>&#x2F;home</td>
<td>用户主目录</td>
<td>各用户的个人目录，通常每个用户都有一个子目录（如 <code>/home/username</code>）</td>
</tr>
<tr>
<td>&#x2F;lib</td>
<td>共享库</td>
<td>存放系统和应用程序使用的共享库文件。常见的库文件用于支持 <code>/bin</code> 和 <code>/sbin</code> 中的二进制文件</td>
</tr>
<tr>
<td>&#x2F;media</td>
<td>可移动媒体</td>
<td>自动挂载可移动媒体（如 CD-ROM、USB 设备）的位置</td>
</tr>
<tr>
<td>&#x2F;mnt</td>
<td>临时挂载点</td>
<td>用于临时挂载文件系统，通常用于手动挂载</td>
</tr>
<tr>
<td>&#x2F;opt</td>
<td>附加应用程序</td>
<td>用于安装附加的应用程序软件包。每个软件包可以有自己的子目录</td>
</tr>
<tr>
<td>&#x2F;proc</td>
<td>虚拟文件系统</td>
<td>提供关于内核和进程的信息，目录内容是虚拟的，不占用磁盘空间。常用于获取系统信息，如 <code>/proc/cpuinfo</code> 和 <code>/proc/meminfo</code></td>
</tr>
<tr>
<td>&#x2F;root</td>
<td>根用户的主目录</td>
<td>根用户（超级用户）的个人目录，通常用于存放根用户的配置文件</td>
</tr>
<tr>
<td>&#x2F;run</td>
<td>运行时数据</td>
<td>存放系统启动后产生的运行时数据，如 PID 文件、套接字等</td>
</tr>
<tr>
<td>&#x2F;srv</td>
<td>服务数据</td>
<td>存放由系统提供的服务数据，如 HTTP 或 FTP 服务的数据文件</td>
</tr>
<tr>
<td>&#x2F;sys</td>
<td>系统文件</td>
<td>提供内核和硬件的信息，类似于 <code>/proc</code>，但用于访问内核的实时信息</td>
</tr>
<tr>
<td>&#x2F;tmp</td>
<td>临时文件</td>
<td>存放临时文件，通常这些文件在系统重启后会被删除</td>
</tr>
<tr>
<td>&#x2F;usr</td>
<td>用户程序</td>
<td><code>Unix Software Resource</code>的缩写，存放用户级程序和数据。通常包括 <code>/usr/bin</code>（用户命令）、<code>/usr/lib</code>（共享库）和 <code>/usr/share</code>（共享数据）</td>
</tr>
<tr>
<td>&#x2F;var</td>
<td>可变数据</td>
<td>存放系统运行时产生的文件，如日志文件（<code>/var/log</code>）、邮件（<code>/var/mail</code>）、缓存（<code>/var/cache</code>）</td>
</tr>
</tbody></table>
<blockquote>
<p> 更多内容参考官方文档：<a href="https://refspecs.linuxfoundation.org/FHS_3.0/fhs/index.html">Filesystem Hierarchy Standard (linuxfoundation.org)</a></p>
</blockquote>
<h1 id="四、Linux文件与目录管理"><a href="#四、Linux文件与目录管理" class="headerlink" title="四、Linux文件与目录管理"></a>四、Linux文件与目录管理</h1><h2 id="绝对路径与相对路径"><a href="#绝对路径与相对路径" class="headerlink" title="绝对路径与相对路径"></a>绝对路径与相对路径</h2><ul>
<li>绝对路径：路径的写法一定由根目录 <code>/</code> 写起，例如： &#x2F;usr&#x2F;share&#x2F;doc 这个目录</li>
<li>相对路径：路径的写法不是由 <code>/</code> 写起，相对路径指相对于目前工作目录的路径！例如由 &#x2F;usr&#x2F;share&#x2F;doc 要到 &#x2F;usr&#x2F;share&#x2F;man 下面时，可以写成： <code>cd ../man</code></li>
</ul>
<h2 id="目录的相关操作"><a href="#目录的相关操作" class="headerlink" title="目录的相关操作"></a>目录的相关操作</h2><p>在所有目录下面都会存在的两个目录，分别是<code>.</code>与<code>..</code>分别代表此层与上层目录的意思</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.         代表此层目录</span><br><span class="line">..        代表上一层目录</span><br><span class="line">-         代表前一个工作目录</span><br><span class="line">~         代表“目前使用者身份”所在的主文件夹</span><br><span class="line">~account  代表 account 这个使用者的主文件夹</span><br></pre></td></tr></table></figure>

<ul>
<li><p>cd：变换目录</p>
</li>
<li><p>pwd：显示目前的目录</p>
</li>
<li><p>mkdir：创建一个新的目录</p>
<ul>
<li>mkdir [-mp] 目录名称</li>
</ul>
<p>  -m ：设置文件的权限</p>
<p>  -p：直接将所需要的目录（包含上层目录）递归创建起来</p>
</li>
<li><p>rmdir：删除一个<strong>空</strong>的目录</p>
</li>
<li><p>ls：列出目录内容</p>
</li>
<li><p>mv：移动或重命名目录</p>
</li>
<li><p>cp：复制目录</p>
</li>
<li><p>du：查看目录大小，<code>du -sh directory_name</code></p>
</li>
<li><p>ln s：创建符号链接</p>
</li>
<li><p>rm：移除文件或目录</p>
</li>
<li><p>basename：显示文件名</p>
</li>
<li><p>dirname：显示目录名</p>
</li>
</ul>
<h2 id="可执行文件路径变量（环境变量）：-PATH"><a href="#可执行文件路径变量（环境变量）：-PATH" class="headerlink" title="可执行文件路径变量（环境变量）：$PATH"></a>可执行文件路径变量（环境变量）：$PATH</h2><p>执行一个指令的时候，比如 <code>ls</code>，系统会依照<code>PATH</code>的设置去每个PATH定义的目录下搜寻文件名为ls的可执行文件，如果在PATH定义的目录中含有多个文件名为<code>ls</code>的可执行文件，那么先搜寻到的同名指令先被执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ <span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line"><span class="comment"># 这个变量的内容由一堆目录所组成，每个目录中间用冒号（:）来隔开，每个目录是有顺序之分的</span></span><br><span class="line">/home/test/.local/bin:/home/test/bin:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin</span><br></pre></td></tr></table></figure>

<h2 id="文件内容查询"><a href="#文件内容查询" class="headerlink" title="文件内容查询"></a>文件内容查询</h2><ul>
<li><p>cat ：由第一行开始显示文件内容</p>
</li>
<li><p>tac ：从最后一行开始显示（ tac 是 cat 倒着写）</p>
</li>
<li><p>nl ：显示的时候输出行号</p>
</li>
<li><p>more： 一页一页的显示文件内容，</p>
<ul>
<li><code>空格</code>：向下翻页</li>
<li><code>Enter</code>：向下翻一行</li>
<li><code>:f</code>：显示文件名和目前行数</li>
<li><code>b</code>：向上翻页</li>
<li><code>/字符串</code>：搜索字符串</li>
<li><code>q</code>：退出</li>
</ul>
</li>
<li><p>less：与 more 类似，比 more 更强大</p>
<ul>
<li><code>空格</code>：向下翻页</li>
<li><code>b</code>：向上翻页</li>
<li><code>/字符串</code>：搜索字符串</li>
<li><code>pagedown</code>：向下翻动一页</li>
<li><code>pageup</code>：向上翻动一页</li>
<li><code>/字符串</code>：向下搜索字串串</li>
<li><code>?字符串</code>：向上搜索字符串</li>
<li><code>n</code>：重复前一个搜索</li>
<li><code>N</code>：反向的重复前一个搜索</li>
<li><code>g</code>：前进到这个数据的第一行去</li>
<li><code>G</code>：前进到这个数据的最后一行去（注意大小写）</li>
<li><code>q</code>：离开less程序</li>
</ul>
</li>
<li><p>head：只显示前几行，不加参数默认显示前10行</p>
<ul>
<li>打印指定行数：<code>head [-n 数字] filename</code></li>
<li>打印除了最后行数：<code>head -n -10 filename</code></li>
</ul>
</li>
<li><p>tail： 只显示后几行，不加参数默认显示后10行</p>
<ul>
<li><code>tail [-n 数字] filename</code>：输出最后几行</li>
<li><code>tail -f filename</code>：持续监测文件并输出</li>
<li><code>tail -n +100 filename</code>：不知道文件有几行，只想列出100行以后的数据</li>
</ul>
<blockquote>
<p><strong>显示文件中间几行</strong></p>
<p>显示文件 11 到 20 行：head -n 20 &#x2F;etc&#x2F;man_db.conf | tail -n 10</p>
<p>带行号显示11到20行：cat &#x2F;etc&#x2F;man_db.conf | head -n 20 | tail -n 10</p>
<blockquote>
<p><strong>|</strong> 是管道符，表示前面的指令所输出的信息，交由后续的指令继续使用，所以tail不需要加文件名</p>
</blockquote>
</blockquote>
</li>
<li><p>od： 读取非纯文本文件内容</p>
<ul>
<li><p><code>echo password | od -t oCc</code></p>
</li>
<li><p>**<code>-t</code>**：指定输出格式：</p>
<p>**<code>o</code>**：输出八进制格式</p>
<p>**<code>C</code>**：输出字符形式，并显示 ASCII 码</p>
<p>**<code>c</code>**：输出 ASCII 字符，并在遇到不可打印字符时显示 <code>.</code></p>
</li>
</ul>
</li>
</ul>
<h2 id="修改文件时间或创建新文件：touch"><a href="#修改文件时间或创建新文件：touch" class="headerlink" title="修改文件时间或创建新文件：touch"></a>修改文件时间或创建新文件：touch</h2><p>通过<code>ls</code>可以看到每个文件在linux下面都会记录很多时间参数，有三个主要的变动时间</p>
<ul>
<li>modification time （mtime）：当文件的<strong>内容（不包括文件的属性或权限）</strong>变更时，会更新这个时间</li>
<li>status time （ctime）：当文件的<strong>状态（权限与属性）</strong>改变时，会更新这个时间</li>
<li>access time （atime）：当文件内容<strong>被读取（例如<code>cat</code> ）</strong>时，就会更新这个读取时间（access）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ; 表示多重指令，可以依次执行</span></span><br><span class="line">[root@172-12-0-1 <span class="built_in">test</span>]# <span class="built_in">date</span>;\</span><br><span class="line"><span class="built_in">ls</span> -l /etc/man_db.conf;\</span><br><span class="line"><span class="built_in">ls</span> -l --time=atime /etc/man_db.conf;\</span><br><span class="line"><span class="built_in">ls</span> -l --time=ctime /etc/man_db.conf</span><br><span class="line"><span class="comment"># 当前时间</span></span><br><span class="line">2024年 08月 13日 星期二 11:59:19 CST</span><br><span class="line"><span class="comment"># ls默认展示mtime</span></span><br><span class="line">-rw-r--r--. 1 root root 5165 6月  30 2021 /etc/man_db.conf</span><br><span class="line"><span class="comment"># 读取时间</span></span><br><span class="line">-rw-r--r--. 1 root root 5165 8月  12 13:47 /etc/man_db.conf</span><br><span class="line"><span class="comment"># 系统按安装时间点</span></span><br><span class="line">-rw-r--r--. 1 root root 5165 7月  18 19:35 /etc/man_db.conf</span><br></pre></td></tr></table></figure>

<h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><ol>
<li>创建一个空文件</li>
<li>修改一个文件的<code>atime</code>和<code>mtime</code>，不能修改<code>ctime</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ <span class="built_in">touch</span> [-acdmt] filename</span><br><span class="line"><span class="comment"># 选项与参数：</span></span><br><span class="line">-a：仅修订 access time</span><br><span class="line">-c：仅修改文件的时间，若该文件不存在则不创建新文件</span><br><span class="line">-d：后面可以接欲修订的日期而不用目前的日期，也可以使用 --<span class="built_in">date</span>=<span class="string">&quot;日期或时间&quot;</span></span><br><span class="line">-m：仅修改 mtime</span><br><span class="line">-t：后面可以接欲修订的时间而不用目前的时间，格式为[YYYYMMDDhhmm]</span><br></pre></td></tr></table></figure>

<h2 id="文件与目录的默认权限与隐藏权限"><a href="#文件与目录的默认权限与隐藏权限" class="headerlink" title="文件与目录的默认权限与隐藏权限"></a>文件与目录的默认权限与隐藏权限</h2><p>除了基本<code>r, w, x</code>权限外，在Linux传统的<code>Ext2/Ext3/Ext4</code>文件系统下，还可以设置其他的系统隐藏属性，这部份可使用<code>chattr</code>来设置，以<code>lsattr</code>来查看，最重要的属性就是可以设置其不可修改的特性（文件所有者也不能修改），这个属性是相当重要的，尤其是在安全机制上面（security）。</p>
<p>比较可惜的是，在 <code>CentOS 7.x</code> 后利用 xfs 作为默认文件系统，xfs 没有支持所有的 <code>chattr</code> 的参数。</p>
<h3 id="文件默认权限：umask"><a href="#文件默认权限：umask" class="headerlink" title="文件默认权限：umask"></a>文件默认权限：umask</h3><p>umask：在创建新文件和目录时，系统会默认使用哪些权限；通过从默认权限中减去，来限制文件和目录的权限。关于默认 <code>umask</code> 的设置可以参考 <code>/etc/bashrc</code> 这个文件的内容</p>
<p><strong>默认权限</strong>：</p>
<ul>
<li>文件的默认权限是 666（即 <code>rw-rw-rw-</code>），表示所有用户都具有读写权限</li>
<li>目录的默认权限是 777（即 <code>rwxrwxrwx</code>），表示所有用户都具有读、写、执行权限</li>
</ul>
<p><strong>umask</strong>：</p>
<ul>
<li><strong>umask</strong> 是一个掩码，它从默认权限中减去指定的权限</li>
<li>例如，如果 umask 设置为 <code>022</code>，则新创建的文件和目录的权限会从默认权限中减去 <code>022</code>，即：<ul>
<li>文件的权限会是 <code>644</code>（即 <code>rw-r--r--</code>），去掉了组和其他用户的写权限</li>
<li>目录的权限会是 <code>755</code>（即 <code>rwxr-xr-x</code>），去掉了组和其他用户的写权限</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看当前 umask(0002)</span></span><br><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ <span class="built_in">umask</span></span><br><span class="line">0002</span><br><span class="line">[root@172-12-0-1 ~]# <span class="built_in">umask</span></span><br><span class="line">0022</span><br><span class="line"></span><br><span class="line"><span class="comment"># 符号类型显示(rwx)</span></span><br><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ <span class="built_in">umask</span> -S</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 umask 为 027</span></span><br><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ <span class="built_in">umask</span> 027</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新创建的文件权限为 640（666 - 027 = 640），目录权限为 750（777 - 027 = 750）</span></span><br><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ <span class="built_in">touch</span> myfile</span><br><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ <span class="built_in">mkdir</span> mydir</span><br><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ <span class="built_in">ls</span> -l myfile mydir</span><br></pre></td></tr></table></figure>

<h3 id="文件隐藏权限"><a href="#文件隐藏权限" class="headerlink" title="文件隐藏权限"></a>文件隐藏权限</h3><p><code>chattr</code> 是一个 Linux 命令，用于更改文件和目录的属性。这些属性提供了额外的控制和保护机制，能够影响文件或目录的行为，尤其是在系统维护和安全方面。 <code>chattr</code> 命令的属性主要用于防止文件被修改、删除或重命名等操作。</p>
<p><strong>常用选项</strong></p>
<ul>
<li>**<code>+</code>**：添加一个或多个属性。</li>
<li>**<code>-</code>**：删除一个或多个属性。</li>
<li>**<code>=</code>**：设置属性，替换现有属性。</li>
</ul>
<p><strong>常见属性</strong></p>
<ul>
<li>**<code>A</code>**：存取此文件（或目录）时，存取时间 atime 将不会被修改，可避免 I&#x2F;O 较慢的机器过度的存取磁盘。（目前建议使用文件系统挂载参数处理这个项目）</li>
<li>**<code>S</code>**：一般文件是非同步写入磁盘的，加上 这个属性后进行任何文件的修改，会同步写入磁盘中</li>
<li>**<code>a</code>**：附加属性。文件只能被追加内容，不能被修改或删除（适用于文件），只有root 才能设置该属性</li>
<li>**<code>c</code>**：压缩属性。启用文件系统的压缩功能（适用于大文件，具体取决于文件系统），读取的时候将会自动解压缩</li>
<li>**<code>d</code>**：当 dump 程序被执行的时候，可使该文件（或目录）不会被 dump 备份</li>
<li>**<code>i</code>**：不可变属性。文件无法被修改、删除、重命名，也不能被创建链接（适用于文件），只有root 才能设置该属性</li>
<li>**<code>s</code>**：安全删除属性。删除文件时，会确保文件数据被完全擦除（适用于文件）</li>
<li>**<code>u</code>**：在文件被删除后，保留文件数据的备份（适用于文件）</li>
</ul>
<p>xfx文件系统仅支持**<code>AadiS</code>**这几个选项参数</p>
<h4 id="查看文件属性"><a href="#查看文件属性" class="headerlink" title="查看文件属性"></a>查看文件属性</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ lsattr filename</span><br></pre></td></tr></table></figure>

<h4 id="修改文件属性"><a href="#修改文件属性" class="headerlink" title="修改文件属性"></a><strong>修改文件属性</strong></h4><p><strong>1. 添加属性</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将不可变属性添加到文件</span></span><br><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ <span class="built_in">sudo</span> chattr +i filename</span><br></pre></td></tr></table></figure>

<p><strong>2. 删除属性</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash复制代码# 删除不可变属性</span><br><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ <span class="built_in">sudo</span> chattr -i filename</span><br></pre></td></tr></table></figure>

<p><strong>3. 设置属性</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置附加属性</span></span><br><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ <span class="built_in">sudo</span> chattr +a filename</span><br></pre></td></tr></table></figure>

<p><strong>常见使用场景</strong></p>
<ul>
<li><strong>保护重要文件</strong>：使用不可变属性保护关键系统文件或配置文件，防止意外修改或删除。</li>
<li><strong>增强安全性</strong>：使用 <code>chattr</code> 命令可以增强文件系统的安全性，特别是在关键系统文件和配置文件的管理中。</li>
</ul>
<h2 id="文件特殊权限：-SUID-SGID-SBIT"><a href="#文件特殊权限：-SUID-SGID-SBIT" class="headerlink" title="文件特殊权限： SUID, SGID, SBIT"></a>文件特殊权限： SUID, SGID, SBIT</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@172-12-0-1 ~]# <span class="built_in">ls</span> -ld /tmp; <span class="built_in">ls</span> -l /usr/bin/passwd</span><br><span class="line">drwxrwxrwt. 11 root root 8192 8月  13 16:19 /tmp</span><br><span class="line">-rwsr-xr-x. 1 root root 33600 4月   7 2020 /usr/bin/passwd</span><br></pre></td></tr></table></figure>

<p>注意这里的<code>s</code>和<code>t</code>，后面要考的</p>
<ul>
<li><p>Set SID</p>
<p>当 <code>s</code> 这个标志出现在<strong>文件</strong>所有者的 x 权限上时，被称为 Set UID，简称为 SUID 的特殊权限</p>
<ul>
<li>SUID 权限仅对二进制程序（binary program）有效</li>
<li>执行者对于该程序需要具有 x 的可执行权限</li>
<li>本权限仅在执行该程序的过程中有效（run-time）</li>
<li>执行者将具有该程序拥有者（owner）的权限</li>
</ul>
<p>比如 <code>passwd</code>这个命令，普通用户具有 <code>x</code>权限，所以也可以执行，但是无法读取</p>
</li>
<li><p>Set GID</p>
<ul>
<li><p>当 <code>s</code> 标志在<code>group</code>的 x 权限时，称为 Set GID，简称为SGID</p>
<ul>
<li>SGID 可以针对<strong>文件或目录</strong>来设置</li>
<li>作用在文件上时<ol>
<li>SGID 对二进制程序有用</li>
<li>以文件所属组的权限执行，而不是执行者的组权限</li>
</ol>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /usr/bin/locate 会去搜索 /var/lib/mlocate/mlocate.db 这个文件的内容</span></span><br><span class="line"><span class="comment"># 使用 test这个帐号去执行locate 时，那 test将会取得slocate 群组的支持</span></span><br><span class="line">[root@172-12-0-1 /]# ll /usr/bin/locate /var/lib/mlocate/mlocate.db</span><br><span class="line">-rwx--s--x 1 root slocate   48552 5月  11 2019 /usr/bin/locate</span><br><span class="line">-rw-r----- 1 root slocate 4093713 8月  14 09:33 /var/lib/mlocate/mlocate.db</span><br></pre></td></tr></table></figure>

<ul>
<li>作用在目录上时<ol>
<li>新创建的文件和子目录会继承该目录的组，而不是创建者的组</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Sticky Bit</p>
<ul>
<li>SBIT 只针对目录有效<ul>
<li>当使用者对于此目录具有 <code>w, x</code> 权限，亦即具有写入的权限时</li>
<li>当使用者在该目录下创建文件或目录时，仅有自己与 root 才有权力删除该文件（即无法删除他人的文件）</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@172-12-0-1 /]# <span class="built_in">ls</span> -dl /tmp/</span><br><span class="line">drwxrwxrwt. 3 root root 85 8月  14 09:56 /tmp/</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="SUID-SGID-SBIT权限设置"><a href="#SUID-SGID-SBIT权限设置" class="headerlink" title="SUID&#x2F;SGID&#x2F;SBIT权限设置"></a>SUID&#x2F;SGID&#x2F;SBIT权限设置</h3><h4 id="权限数值表示"><a href="#权限数值表示" class="headerlink" title="权限数值表示"></a>权限数值表示</h4><ul>
<li><code>SUID</code>：4</li>
<li><code>SGID</code>：2</li>
<li><code>SBIT</code>：1</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>设置权限<code>-rwsr-xr-x</code></p>
<ul>
<li>数字模式，<code>chmod 4755 filename</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@172-12-0-1 /]# <span class="built_in">cd</span> /tmp</span><br><span class="line">[root@172-12-0-1 /tmp]# <span class="built_in">touch</span> <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 加入SUID 权限</span></span><br><span class="line">[root@172-12-0-1 /tmp]# <span class="built_in">chmod</span> 4755 <span class="built_in">test</span></span><br><span class="line">[root@172-12-0-1 /tmp]# ll <span class="built_in">test</span></span><br><span class="line">-rwsr-xr-x 1 root root  0 8月  14 10:07 <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 加入SUID/SGID 权限</span></span><br><span class="line">[root@172-12-0-1 /tmp]# <span class="built_in">chmod</span> 6755 <span class="built_in">test</span></span><br><span class="line">[root@172-12-0-1 /tmp]# ll <span class="built_in">test</span></span><br><span class="line">-rwsr-sr-x 1 root root  0 8月  14 10:07 <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 加入 SBIT 权限</span></span><br><span class="line">[root@172-12-0-1 /tmp]# <span class="built_in">chmod</span> 1755 <span class="built_in">test</span></span><br><span class="line">[root@172-12-0-1 /tmp]# ll <span class="built_in">test</span></span><br><span class="line">-rwxr-xr-t 1 root root 0 8月  14 10:07 <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 具有空的 SUID/SGID 权限</span></span><br><span class="line">[root@172-12-0-1 /tmp]# <span class="built_in">chmod</span> 7666 <span class="built_in">test</span></span><br><span class="line">[root@172-12-0-1 /tmp]# <span class="built_in">ls</span> -l <span class="built_in">test</span></span><br><span class="line">-rwSrwSrwT 1 root root  0 8月  14 10:07 <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>最后一个为什么会出现大写的 S 与 T 呢？</p>
<p>因为 s 与 t都是取代 x 这个权限的，设置 7666 权限时user、group、others都没有x的权限，所以，这个 S, T 代表的就是没权限执行（文件所有者都没权限执行，其他人肯定不能用了）</p>
</blockquote>
<ul>
<li>符号模式<ul>
<li>SUID ： u+s</li>
<li>SGID ： g+s</li>
<li>SBIT  ： o+t</li>
</ul>
</li>
</ul>
<h2 id="文件查找：-locate"><a href="#文件查找：-locate" class="headerlink" title="文件查找： locate"></a>文件查找： locate</h2><ul>
<li>安装</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装lcoate</span></span><br><span class="line">[root@172-12-0-1 ~]# yum install mlocate</span><br></pre></td></tr></table></figure>

<ul>
<li>更新数据库</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据 /etc/updatedb.conf 的设置去搜寻系统硬盘内的文件名，并更新 /var/lib/mlocate 内的数据库文件</span></span><br><span class="line">[root@172-12-0-1 ~]# updatedb</span><br></pre></td></tr></table></figure>

<ul>
<li>查找文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在 /var/lib/mlocate 中查找</span></span><br><span class="line">[root@172-12-0-1 ~]# locate filename</span><br></pre></td></tr></table></figure>

<h2 id="查看文件类型：-file"><a href="#查看文件类型：-file" class="headerlink" title="查看文件类型： file"></a>查看文件类型： file</h2><p>想要知道某个文件的基本数据，例如是属于 ASCII 或者是 data 文件、 binary，且其中有没有使用到动态函数库（share library）等，可以使用file命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ASCII 的纯文本文件</span></span><br><span class="line">[root@172-12-0-1 ~]# file ~/.bashrc </span><br><span class="line">/root/.bashrc: ASCII text</span><br><span class="line"><span class="comment"># 可执行文件的数据，包括这个文件的 suid 权限、相容于 Intel x86-64 等级的硬件平台，使用的是 Linux 核心 3.2.0 的动态函数库链接等</span></span><br><span class="line">[root@172-12-0-1 ~]# file /usr/bin/passwd</span><br><span class="line">/usr/bin/passwd: setuid ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, <span class="keyword">for</span> GNU/Linux 3.2.0, BuildID[sha1]=87e17c1d9b2e20d7e8aeab9115074375eec5e8e1, stripped</span><br><span class="line"><span class="comment"># data 文件</span></span><br><span class="line">[root@172-12-0-1 ~]# file /var/lib/mlocate/mlocate.db</span><br><span class="line">/var/lib/mlocate/mlocate.db: mlocate database, version 0, require visibility, root /</span><br></pre></td></tr></table></figure>

<h2 id="指令与文件的搜索"><a href="#指令与文件的搜索" class="headerlink" title="指令与文件的搜索"></a>指令与文件的搜索</h2><h3 id="指令文件名的搜索"><a href="#指令文件名的搜索" class="headerlink" title="指令文件名的搜索"></a>指令文件名的搜索</h3><ul>
<li>which：用于查找命令的可执行文件路径。它会输出在 <code>PATH</code> 环境变量中找到的第一个匹配命令的位置</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找 ifconfig 执行文件</span></span><br><span class="line">[root@172-12-0-1 ~]# <span class="built_in">which</span> ifconfig </span><br><span class="line">/usr/sbin/ifconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找 history 执行文件，发现找不到，是因为history是 bash 内置的指令，可以通过type搜索</span></span><br><span class="line">[root@172-12-0-1 ~]# <span class="built_in">which</span> <span class="built_in">history</span> </span><br><span class="line">/usr/bin/which: no <span class="built_in">history</span> <span class="keyword">in</span> (/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin)</span><br></pre></td></tr></table></figure>

<ul>
<li>type：提供更多的详细信息，包括命令的类型（内置命令、别名、函数、外部命令等）。它不仅显示命令的路径，还可以显示命令的类型和其他相关信息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@172-12-0-1 ~]# <span class="built_in">type</span> <span class="built_in">history</span> </span><br><span class="line"><span class="built_in">history</span> 是 shell 内建</span><br></pre></td></tr></table></figure>

<h3 id="文件文件名搜索"><a href="#文件文件名搜索" class="headerlink" title="文件文件名搜索"></a>文件文件名搜索</h3><ul>
<li>whereis：由一些特定的目录中寻找文件文件名，可以通过 <code>whereis -l</code>来查看搜索哪些目录</li>
<li>locate &#x2F; updatedb：[Ctrl点击跳转到locate](#文件查找： locate)</li>
<li>find：直接搜索硬盘，速度慢，但功能强大，使用 <code>man find</code>查看更多用法</li>
</ul>
<h1 id="五、Linux磁盘与文件系统管理"><a href="#五、Linux磁盘与文件系统管理" class="headerlink" title="五、Linux磁盘与文件系统管理"></a>五、Linux磁盘与文件系统管理</h1><p>Linux 最传统的磁盘文件系统（filesystem）使用的是 EXT2，文件系统创建在磁盘上边，前面已经有说过磁盘的基本组成了（<a href="#%E7%A1%AC%E7%9B%98%E5%92%8C%E5%82%A8%E5%AD%98%E8%AE%BE%E5%A4%87">跳转磁盘</a>），本章重点在于 inode, block 还有 superblock 等文件系统的基本部分。</p>
<blockquote>
<p>为什么磁盘分区完毕后还需要进行格式化（format），之后操作系统才能够使用这个文件系统？</p>
<p>这是因为每种操作系统所设置的文件属性&#x2F;权限并不相同，为了存放这些文件所需的数据，因此就需要将分区进行格式化，以成为操作系统能够利用的文件系统格式（filesystem）</p>
</blockquote>
<blockquote>
<p>传统的一个分区只能被格式化为一个文件系统，但由于新技术的应用，LVM与软件磁盘阵列（software raid）技术可以将一个分区格式化为多个文件系统，也能够将多个分区合成一个文件系统。所以目前我们在格式化时已经不再说成针对 <code>partition</code> 来格式化了，通常可以称呼一个可被挂载的数据为一个文件系统而不是一个分区。</p>
</blockquote>
<p>文件数据除了文件实际内容外，还有有非常多的属性，例如 Linux 操作系统的文件权限（rwx）与文件属性（拥有者、群组、时间参数等）。文件系统通常会将这两部份的数据分别存放在不同的区块，<strong>权限与属性</strong>放置到 <code>inode</code> 中，<strong>实际数据</strong>则放置到 <code>data block</code> 区块中。另外，还有一个超级区块（<code>superblock</code>）会记录整个文件系统的整体信息，包括 inode 与 block 的总量、使用量、剩余量等。</p>
<p>每个 <code>inode</code> 与 <code>block</code> 都有编号，这三个数据的意义可以简略说明如下：</p>
<ul>
<li>superblock：记录此 <code>filesystem</code> 的整体信息，包括<code>inode/block</code>的总量、使用量、剩余量，以及文件系统的格式与相关信息等</li>
<li>inode：记录文件的属性，一个文件占用一个inode，同时记录此文件的数据所在的 <code>block</code>号码</li>
<li>block：实际记录文件的内容，若文件太大时，会占用多个 block</li>
</ul>
<p>由inode可以找到此文件的数据存放的block块，这种数据存取方式称为<strong>索引式文件系统</strong>（indexed allocation）</p>
<blockquote>
<p>U盘的文件系统一般是FAT格式，FAT 这种格式的文件系统并没有 inode 存在，所以 FAT 没有办法将这个文件的所有 block 在一开始就读取出来。每个 block 号码都记录在前一个 block 当中（1-&gt;7-&gt;4-&gt;15），如果同一个文件数据写入的 block 分散的太厉害，则磁头将无法在磁盘转一圈就读到所有的数据，因此磁盘就会多转好几圈才能完整的读取到这个文件的内容。</p>
<p>所以需要隔三岔五的<strong>磁盘重组</strong>一下</p>
<p>磁盘重组（也称为磁盘整理或碎片整理）是一个用于优化存储设备性能的过程。在此过程中，文件系统会重新组织存储在磁盘上的文件，使得文件的各个部分尽可能地连续存储，以减少磁头移动的时间，从而提高磁盘读写效率。</p>
</blockquote>
<h2 id="Ext2文件系统-inode"><a href="#Ext2文件系统-inode" class="headerlink" title="Ext2文件系统(inode)"></a>Ext2文件系统(inode)</h2><p>文件系统一开始就将 inode 与 block 规划好了，除非重新格式化（或者利用 <code>resize2fs</code> 等指令变更文件系统大小），否则 inode 与 block 固定后就不再变动。但是如果我的文件系统高达数百GB时，将所有的 inode 与 block 放置在一起将是很不智的决定，因为 inode 与 block 的数量太庞大，不容易管理。</p>
<p>因此 Ext2 文件系统在格式化的时候基本上是区分为多个<strong>区块群组</strong>（<code>blockgroup</code>）的，每个区块群组都有<strong>独立</strong>的 inode&#x2F;block&#x2F;superblock 系统，如下图所示</p>
<img src="https://imgos.cn/2024/08/15/66bd629e6cf67.png" alt="图片描述" width="600" height="300">

<p>在整体的规划当中，文件系统最前面有一个开机扇区（boot sector），这个开机扇区可以安装开机管理程序，这是个非常重要的设计，我们能够将不同的开机管理程序安装到个别的文件系统最前端，而不用覆盖整颗磁盘唯一的 MBR，这样才能够制作出多重开机的环境。</p>
<h2 id="Data-Block（数据区块）"><a href="#Data-Block（数据区块）" class="headerlink" title="Data Block（数据区块）"></a>Data Block（数据区块）</h2><p>用来放置<strong>文件内容</strong>，在 Ext2 文件系统中所支持的 block 大小有 1K、2K及 4K 三种。在格式化时 block 的大小就固定了，且每个 block 都有编号，以方便 inode的记录。不过要注意的是，由于 block 大小的差异，会导致该文件系统能够支持的最大磁盘容量与最大单一文件大小并不相同</p>
<table>
<thead>
<tr>
<th>Block 大小</th>
<th>1KB</th>
<th>2KB</th>
<th>4KB</th>
</tr>
</thead>
<tbody><tr>
<td>最大单一文件限制</td>
<td>16GB</td>
<td>256GB</td>
<td>2TB</td>
</tr>
<tr>
<td>最大文件系统总容量</td>
<td>2TB</td>
<td>8TB</td>
<td>16TB</td>
</tr>
</tbody></table>
<blockquote>
<p>需要注意的是，虽然 Ext2 已经能够支持大于 2GB 以上的单一文件大小，不过某些应用程序依然使用旧的限制，也就是说，某些程序只能够识别到小于 2GB 以下的文件而已，这就跟文件系统无关了</p>
</blockquote>
<ul>
<li>Ext2 文件系统的 block 限制<ul>
<li>原则上，block 的大小与数量在格式化完就不能够再改变了（除非重新格式化）</li>
<li>每个 block 内最多只能够放置一个文件的数据<ul>
<li>如果文件大于 block 的大小，则一个文件会占用多个 block 数量</li>
<li>若文件小于 block ，则该 block 的剩余容量就不能够再被使用了（磁盘空间会浪费）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>基于以上的限制，如果block过大（4k），但是文件都非常小，可能会产生一些容量的浪费；如果block过小， 文件过大，可能导致不良的读写性能。</p>
<blockquote>
<p><strong>假设你的Ext2文件系统使用 4K block ，而该文件系统中有 10000 个小文件，每个文件大小均为 50Bytes，请问此时你的磁盘浪费多少容量？</strong></p>
<p>由于 Ext2 文件系统中一个 block仅能容纳一个文件，因此每个 block 会浪费 <code>4096 - 50 = 4046 （Byte）</code>，系统中总共有一万个小文件，所有文件大小为：<code>50 （Bytes） x 10000 = 488.3KBytes</code>，但此时浪费的容量为：<code>4046 （Bytes） x 10000 = 38.6MBytes</code></p>
<p>不到 1MB 的总文件大小却浪费将近 40MB 的容量，且文件越多将造成越多的磁盘容量浪费</p>
</blockquote>
<blockquote>
<p>既然大的 block 可能会产生较严重的磁盘容量浪费，那么是否可以将 block 大小定为1K 即可？</p>
<p>如果 block 较小的话，大型文件将会占用数量更多的 block ，而 inode 也要记录更多的 block 号码，此时将可能导致文件系统不良的读写性能</p>
</blockquote>
<h2 id="inode-table-（inode-表格）"><a href="#inode-table-（inode-表格）" class="headerlink" title="inode table （inode 表格）"></a>inode table （inode 表格）</h2><p>inode 的内容在记录文件的属性以及该文件实际数据是放置在哪几号 block 内</p>
<p>基本上，inode 记录的文件数据至少有下面这些：</p>
<ul>
<li>文件类型：文件、目录、符号链接等</li>
<li>文件权限：权限位（读、写、执行）以及文件的所有者和组的权限</li>
<li>硬链接计数：指示有多少硬链接指向该 <code>inode</code></li>
<li>文件所有者：文件的所有者的用户 ID</li>
<li>文件组：文件所属的组的组ID</li>
<li>文件大小；文件的字节数</li>
<li>时间戳：创建时间(ctime)、修改时间(mtime)、访问时间(atime)</li>
<li>数据块指针：指向文件数据块的指针或索引。这些指针存储了文件实际数据的位置</li>
<li><strong>i-node number</strong>：在文件系统中 <code>inode</code> 的唯一标识符</li>
</ul>
<p>inode 的数量与大小也是在<strong>格式化时就已经固定</strong>了，除此之外 inode 还有以下特色：</p>
<ul>
<li>每个 inode 大小均固定为 128 Bytes （新的 ext4 与 xfs 可设置到 256 Bytes）</li>
<li>每个文件都仅会占用一个 inode 而已<ul>
<li>文件系统能够创建的文件数量与 inode 的数量有关</li>
<li>系统读取文件时需要先找到 inode，并分析 inode 所记录的权限与使用者是否符合，若符合才开始读取 block 的内容</li>
</ul>
</li>
</ul>
<blockquote>
<p> inode 要记录的数据非常多，却只有 128Bytes 而已，而 inode 记录一个 block 号码要花掉 4Byte ，假设我一个文件有 400MB 且每个 block 为 4K 时，那么至少也要十万个 block 号码来记录，inode 哪有这么多空间来记录这些信息？</p>
<p>为此系统将 inode 记录 block 号码的区域定义为12个直接，一个间接, 一个二级间接与一个三级间接记录区</p>
</blockquote>
<p>文件数据块的指针。<code>i_block</code> 数组的前 12 个条目是直接块指针，指向文件数据的实际位置。接下来的 3 个条目分别是一级间接、二级间接和三级间接块指针。这些间接块指针用于支持较大的文件。</p>
<ul>
<li><strong>直接块指针</strong>：指向文件数据的直接位置</li>
<li><strong>一级间接块指针</strong>：指向一个块，其中包含更多的直接块指针</li>
<li><strong>二级间接块指针</strong>：指向一个块，其中包含一级间接块的指针</li>
<li><strong>三级间接块指针</strong>：指向一个块，其中包含二级间接块的指针</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ext2文件系统中的 inode 结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext2_inode</span> &#123;</span></span><br><span class="line">    __le16 i_mode;           <span class="comment">// 文件类型和权限</span></span><br><span class="line">    __le16 i_uid;            <span class="comment">// 用户 ID</span></span><br><span class="line">    __le32 i_size;           <span class="comment">// 文件大小（字节数）</span></span><br><span class="line">    __le32 i_atime;          <span class="comment">// 访问时间（从 1970 年 1 月 1 日开始的秒数）</span></span><br><span class="line">    __le32 i_ctime;          <span class="comment">// 创建时间（从 1970 年 1 月 1 日开始的秒数）</span></span><br><span class="line">    __le32 i_mtime;          <span class="comment">// 修改时间（从 1970 年 1 月 1 日开始的秒数）</span></span><br><span class="line">    __le32 i_dtime;          <span class="comment">// 删除时间（从 1970 年 1 月 1 日开始的秒数）</span></span><br><span class="line">    __le16 i_gid;            <span class="comment">// 组 ID</span></span><br><span class="line">    __le16 i_links_count;    <span class="comment">// 硬链接计数</span></span><br><span class="line">    __le32 i_blocks;         <span class="comment">// 文件数据块数量（以 512 字节为单位）</span></span><br><span class="line">    __le32 i_flags;          <span class="comment">// 文件属性标志（如是否为只读文件）</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            __le32 i_block[<span class="number">15</span>]; <span class="comment">// 数据块指针（包括直接、间接和双重间接指针）</span></span><br><span class="line">        &#125; linux2;</span><br><span class="line">    &#125; osd2;</span><br><span class="line">    __le32 i_reserved1;      <span class="comment">// 保留字段</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设有一个 ext2 文件系统中的 inode 结构如下</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext2_inode</span> <span class="title">inode</span>;</span></span><br><span class="line">inode.i_mode = <span class="number">0100644</span>;   <span class="comment">// 常规文件，所有者读写，组和其他用户只读</span></span><br><span class="line">inode.i_uid = <span class="number">1000</span>;       <span class="comment">// 用户 ID</span></span><br><span class="line">inode.i_size = <span class="number">4096</span>;      <span class="comment">// 文件大小（字节数）</span></span><br><span class="line">inode.i_atime = <span class="number">1616161616</span>; <span class="comment">// 访问时间（时间戳）</span></span><br><span class="line">inode.i_ctime = <span class="number">1616161616</span>; <span class="comment">// 创建时间（时间戳）</span></span><br><span class="line">inode.i_mtime = <span class="number">1616161616</span>; <span class="comment">// 修改时间（时间戳）</span></span><br><span class="line">inode.i_dtime = <span class="number">0</span>;        <span class="comment">// 删除时间（如果文件未删除，则为 0）</span></span><br><span class="line">inode.i_gid = <span class="number">1000</span>;       <span class="comment">// 组 ID</span></span><br><span class="line">inode.i_links_count = <span class="number">1</span>;  <span class="comment">// 硬链接计数</span></span><br><span class="line">inode.i_blocks = <span class="number">8</span>;       <span class="comment">// 占用的块数</span></span><br><span class="line">inode.i_flags = <span class="number">0</span>;        <span class="comment">// 文件属性标志</span></span><br><span class="line"><span class="comment">// 假设数据块大小为 512 字节</span></span><br><span class="line"><span class="comment">// 直接块指针</span></span><br><span class="line">inode.i_block[<span class="number">0</span>] = <span class="number">1234</span>;  <span class="comment">// 数据块指针</span></span><br><span class="line">inode.i_block[<span class="number">1</span>] = <span class="number">1235</span>;  <span class="comment">// 数据块指针</span></span><br><span class="line"><span class="comment">// 一级间接块指针</span></span><br><span class="line">inode.i_block[<span class="number">12</span>] = <span class="number">1236</span>; <span class="comment">// 指向包含更多数据块指针的块</span></span><br><span class="line"><span class="comment">// 二级间接块指针</span></span><br><span class="line">inode.i_block[<span class="number">13</span>] = <span class="number">1237</span>; <span class="comment">// 指向包含一级间接块指针的块</span></span><br><span class="line"><span class="comment">// 三级间接块指针</span></span><br><span class="line">inode.i_block[<span class="number">14</span>] = <span class="number">1238</span>; <span class="comment">// 指向包含二级间接块指针的块</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样子 inode 能够指定多少个 block 呢？</p>
<p>以较小的 1K block 来说明好了，可以指定的情况如下：</p>
<p>12 个直接指向： 12 * 1K&#x3D;12K，由于是直接指向，所以总共可记录 12 笔记录</p>
<p>间接： 256 * 1K&#x3D;256K，每笔 block 号码的记录会花去 4Bytes， 1K 的大小能够记录256 笔记录</p>
<p>双间接： 256 * 256 * 1K&#x3D;256 <sup>2</sup> K ，一层 block 会指定 256 个第二层，每个第二层可以指定256 个号码</p>
<p>三间接： 256 * 256 * 256 * 1K&#x3D;256<sup>3</sup> K，第一层 block 会指定 256 个第二层，每个第二层可以指定 256 个第三层，每个第三层可以指定 256 个号码</p>
<p>总额： 12 + 256 + 256<sup>2</sup> + 256<sup>3</sup>（K） &#x3D; 16GB </p>
<p>当文件系统将 block 格式化为 1K 大小时，能够容纳的最大文件为 16GB， 跟前面表格[跳转](#Data Block（数据区块）)结果差不多。但这个方法不能用在 2K 及 4K block 大小的计算中，因为大于 2K 的 block 将会受到 Ext2 文件系统本身的限制，所以计算的结果会不太符合。</p>
</blockquote>
<h2 id="Superblock（超级区块）"><a href="#Superblock（超级区块）" class="headerlink" title="Superblock（超级区块）"></a>Superblock（超级区块）</h2><p>Superblock 是记录整个 <code>filesystem</code> 相关信息的地方，没有 Superblock ，就没有这个filesystem 了</p>
<p>记录的信息主要有：</p>
<ul>
<li><p>block 与 inode 的总量</p>
</li>
<li><p>未使用与已使用的 inode &#x2F; block 数量</p>
</li>
<li><p>block 与 inode 的大小（block 为 1, 2, 4K，inode 为 128Bytes 或 256Bytes）</p>
</li>
<li><p>filesystem 的挂载时间、最近一次写入数据的时间、最近一次检验磁盘（fsck）的时间等文件系统的相关信息</p>
</li>
<li><p>一个 <code>valid bit</code> 数值，若此文件系统已被挂载，则 valid bit 为 0 ，若未被挂载，则 valid bit为 1 。</p>
</li>
</ul>
<p>Superblock 非常重要，因为文件系统的基本信息都写在这里，superblock 的大小一般为 1024Bytes（<code>dumpe2fs</code>指令），此外，每个 <code>block group</code> 都可能含有 superblock ！事实上除了第一个 <code>block group</code> 含有 superblock，后续的 block group 不一定含有 superblock ，而若含有 superblock 则该 superblock主要是做为第一个 block group 内 superblock 的<strong>备份</strong>，这样做是为了 <code>superblock</code> 的救援。</p>
<h2 id="Filesystem-Description-（文件系统描述说明）"><a href="#Filesystem-Description-（文件系统描述说明）" class="headerlink" title="Filesystem Description （文件系统描述说明）"></a>Filesystem Description （文件系统描述说明）</h2><p>这个区段可以描述每个 <code>block group</code> 的开始与结束的 block 号码，以及说明每个区段（superblock, bitmap, inodemap, data block）分别介于哪一个 block 号码之间。<code>dumpe2fs指令观察</code></p>
<h2 id="block-bitmap-（区块对照表）"><a href="#block-bitmap-（区块对照表）" class="headerlink" title="block bitmap （区块对照表）"></a>block bitmap （区块对照表）</h2><p>从 block bitmap 当中可以知道哪些 block 是空的，系统就能够快速的找到可使用的空间来处置文件。同样的，如果删除某些文件时，那么那些文件原本占用的 block 号码就要释放，此时在 block bitmap 当中对应到该 block 号码的标志就要修改为<code>未使用中</code>，这就是bitmap 的功能。</p>
<h2 id="inode-bitmap-（inode-对照表）"><a href="#inode-bitmap-（inode-对照表）" class="headerlink" title="inode bitmap （inode 对照表）"></a>inode bitmap （inode 对照表）</h2><p>这个与 block bitmap 是类似的功能，只是 block bitmap 记录的是使用与未使用的 block号码，而 inode bitmap 是记录使用与未使用的 inode 号码</p>
<blockquote>
<p>  dumpe2fs：查询 Ext 家族 superblock 信息的指令</p>
<p>blkid：显示目前系统有被格式化的设备</p>
</blockquote>
<h2 id="文件系统与目录树的关系"><a href="#文件系统与目录树的关系" class="headerlink" title="文件系统与目录树的关系"></a>文件系统与目录树的关系</h2><p>在 Linux 系统下，每个文件（不管是一般文件还是目录文件）都会占用一个 <code>inode</code> ，且可依据文件内容的大小来分配多个 <code>block</code> 给该文件使用。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>在 Linux 下的文件系统创建一个目录时，文件系统会分配一个 inode 与至少一块 block给该目录。其中，inode 记录该目录的相关权限与属性，并记录分配到的那块 block 号码；而 block 则记录在这个目录下的文件名与该文件名占用的 inode 号码数据。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看文件的inode</span></span><br><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ <span class="built_in">ls</span> -i -al</span><br><span class="line">总用量 52</span><br><span class="line"> 33566006 drwx------   5 <span class="built_in">test</span> <span class="built_in">test</span>     183 8月  10 14:56 .</span><br><span class="line">      138 drwxr-xr-x.  4 root root      29 7月  31 10:16 ..</span><br><span class="line"> 35194599 -rw-------   1 <span class="built_in">test</span> docker 16454 8月  14 10:49 .bash_history</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># block的大小都是 1024 的倍数，因为每个 block 的数量都是 1K, 2K, 4K</span></span><br><span class="line">[<span class="built_in">test</span>@172-12-0-1 ~]$ ll -d / /boot /usr/sbin /proc /sys</span><br><span class="line">dr-xr-xr-x.  24 root root  4096 7月  30 17:11 /</span><br><span class="line">dr-xr-xr-x.   6 root root  4096 7月  18 19:54 /boot</span><br><span class="line">dr-xr-xr-x  236 root root     0 8月   2 16:03 /proc  <span class="comment">#  /proc不占磁盘容量</span></span><br><span class="line">dr-xr-xr-x   13 root root     0 8月   2 16:03 /sys</span><br><span class="line">dr-xr-xr-x.   2 root root 12288 8月   2 15:25 /usr/sbin</span><br></pre></td></tr></table></figure>

<p>由上面的结果可以发现目录并不是只占用一个 block 而已，在目录下面的文件数如果太多而导致一个 block 无法容纳下所有的文件名与 inode 对照表时，Linux 会给予该目录多一个 block 来继续记录相关的数据。</p>
<blockquote>
<p>在 Linux 下的 ext2 创建一个一般文件时， ext2 会分配一个 inode 与相对于该文件大小的 block 数量给该文件。例如：假设我的一个 block 为 4 KBytes ，我要创建一个 100KBytes 的文件，系统将分配一个 inode 与 25 个 block 来储存该文件，但 inode 仅有 12 个直接指向，因此还要多一个 block 来作为区块号码的记录。</p>
</blockquote>
<h3 id="目录树读取"><a href="#目录树读取" class="headerlink" title="目录树读取"></a>目录树读取</h3><p>inode 本身并不记录文件名，文件名的记录是在<strong>目录的 block</strong> 当中（前面提到**<code>新增/删除/更改文件名</code>与目录的 <code>w</code> 权限有关**），因此要读取某个文件时，就务必会经过目录的 inode 与 block ，然后才能够找到那个待读取文件的 inode 号码，最终才会读到正确的文件的 block 内的数据。</p>
<p>由于目录树是由根目录开始读起，因此系统通过挂载的信息可以找到挂载点的 inode 号码，此时就能够得到根目录的 inode 内容，并依据该 inode 读取根目录的 block 内的文件名数据，再一层一层的往下读到正确的文件名。</p>
<h2 id="EXT2-EXT3-EXT4-文件的存取与日志式文件系统的功能"><a href="#EXT2-EXT3-EXT4-文件的存取与日志式文件系统的功能" class="headerlink" title="EXT2&#x2F;EXT3&#x2F;EXT4 文件的存取与日志式文件系统的功能"></a>EXT2&#x2F;EXT3&#x2F;EXT4 文件的存取与日志式文件系统的功能</h2><p>新建一个文件或目录时，就需要 block bitmap 及 inode bitmap 的帮忙了</p>
<p>假设我们想要新增一个文件，此时文件系统的行为是：</p>
<ol>
<li>先确定使用者对于新增文件的目录是否具有 <code>w 与 x</code> 的权限，若有的话才能新增</li>
<li>根据 inode bitmap 找到没有使用的 inode 号码，并将新文件的权限&#x2F;属性写入</li>
<li>根据 block bitmap 找到没有使用中的 block 号码，并将实际的数据写入 block 中，且更新 inode 的 block 指向数据</li>
<li>将刚刚写入的 inode 与 block 数据同步更新 inode bitmap 与 block bitmap，并更新superblock 的内容</li>
</ol>
<p>一般来说，我们将 inode table 与 data block 称为<strong>数据存放区域</strong>，至于其他例如 superblock、block bitmap 与 inode bitmap 等区段被称为 <strong><code>metadata</code></strong> （中介数据），因为 superblock,inode bitmap 及 block bitmap 的数据是经常变动的，每次新增、移除、编辑时都可能会影响到这三个部分的数据，因此才被称为中介数据。</p>
<h3 id="数据的不一致（Inconsistent）状态"><a href="#数据的不一致（Inconsistent）状态" class="headerlink" title="数据的不一致（Inconsistent）状态"></a>数据的不一致（Inconsistent）状态</h3><p>一般情况下，上述的新增动作当然可以顺利的完成。但是如果你的文件在写入文件系统时，因为不知名原因导致<strong>系统中断</strong>（例如突然的停电啊、系统核心发生错误等发生时），导致写入的数据仅有 inode table 及 data block 而已，最后一个同步更新中介数据的步骤并没有做完，此时就会发生 metadata 的内容与实际数据存放区产生<strong>不一致</strong>（Inconsistent）的情况了。</p>
<p>在早期的 Ext2 文件系统中，如果发生这个问题，那么系统在重新开机的时候，就会借由 Superblock 当中记录的 valid bit （是否有挂载）与 filesystemstate （clean 与否）等状态来判断是否强制进行数据一致性的检查（<code>e2fsck</code>指令）</p>
<p>不过，这个检查要针对 metadata 区域与实际数据存放区来进行比对，得要搜索整个 filesystem，这样的检查真的很费时，这也就造成后来所谓日志式文件系统的兴起了。</p>
<h3 id="日志式文件系统（Journaling-filesystem）"><a href="#日志式文件系统（Journaling-filesystem）" class="headerlink" title="日志式文件系统（Journaling filesystem）"></a>日志式文件系统（Journaling filesystem）</h3><p>为了避免上述提到的文件系统不一致的情况发生，前辈们想到一个方式：如果在我们的 filesystem 当中规划出一个区块，该区块专门记录写入或修订文件时的步骤，就可以简化一致性检查的步骤了，也就是说：</p>
<ol>
<li>预备：当系统要写入一个文件时，会先在日志记录区块中记录某个文件准备要写入的信息</li>
<li>实际写入：开始写入文件的权限与数据，开始更新 metadata 的数据</li>
<li>结束：完成数据与 metadata 的更新后，在日志记录区块当中完成该文件的纪录</li>
</ol>
<p>在这样的程序中，万一数据的纪录过程当中发生了问题，我们的系统只要去检查日志记录区块，就可以知道哪个文件发生了问题，针对该问题来做一致性的检查即可，而不必针对整块 filesystem 去检查，这样就可以做到快速修复 filesystem。</p>
<h2 id="Linux-文件系统的运行"><a href="#Linux-文件系统的运行" class="headerlink" title="Linux 文件系统的运行"></a>Linux 文件系统的运行</h2><p>知道了目录树与文件系统的关系以及所有的数据要载入到内存后 CPU 才能对该数据进行处理。如果你频繁编辑一个大文件，在编辑的过程中又频繁的要系统来写入到磁盘中，由于磁盘写入的速度要比内存慢很多，时间都耗在等待磁盘的写入&#x2F;读取上。</p>
<p>为了解决这个问题，Linux 通过一个称为<strong>非同步处理（asynchronously）</strong>的方式：当系统载入一个文件到内存后，如果该文件没有被改动过，则在内存区段的文件数据会被标记为干净（<strong>clean</strong>）的。但如果内存中的文件数据被更改过了，此时该内存中的数据会被标记为脏的（<strong>Dirty</strong>）。此时所有的动作都还在<strong>内存</strong>中执行，并没有写入到磁盘中，系统会不定时的将内存中设置为<code>Dirty</code>的数据写回磁盘，以保持磁盘与内存数据的一致性。也可以使用 <code>sync</code>指令来手动写入磁盘。</p>
<p>内存的速度要比磁盘快的多，如果能够将常用的文件放置到内存当中，就能增加系统性能。</p>
<p>因此 Linux 系统上面文件系统与内存有非常大的关系：</p>
<ul>
<li>系统会将常用的文件数据放置到<strong>内存的缓冲区</strong>，以加速文件系统的读&#x2F;写</li>
<li>可以手动使用 sync 来强迫内存中设置为 Dirty 的文件回写到磁盘中</li>
<li>若正常关机时，关机指令会主动调用 sync 来将内存的数据回写入磁盘内</li>
<li>但若不正常关机（如跳电、死机或其他不明原因），由于数据尚未回写到磁盘内，因此重新开机后可能会花很多时间在进行磁盘检验，甚至可能导致文件系统的损毁（非磁盘损毁）</li>
</ul>
<h2 id="挂载点的意义（mount-point）"><a href="#挂载点的意义（mount-point）" class="headerlink" title="挂载点的意义（mount point）"></a>挂载点的意义（mount point）</h2><p>每个 <code>filesystem</code> 都有独立的 inode &#x2F; block &#x2F; superblock 等信息，这个文件系统要能够链接到目录树才能被使用。<strong>将文件系统与目录树结合的动作</strong>称为挂载。<strong>挂载点一定是目录</strong>，该目录为进入该文件系统的入口。因此并不是任何文件系统都能使用，必须要<strong>挂载</strong>到目录树的某个目录后，才能够使用该文件系统</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@172-12-0-1 ~]# <span class="built_in">ls</span> -lid / /boot /home</span><br><span class="line">128 dr-xr-xr-x. 24 root root 4096 7月  30 17:11 /</span><br><span class="line">128 dr-xr-xr-x.  6 root root 4096 7月  18 19:54 /boot</span><br><span class="line">138 drwxr-xr-x.  4 root root   29 7月  31 10:16 /home</span><br></pre></td></tr></table></figure>

<p>由于 XFS filesystem 最顶层目录的 inode 一般为 128 号，可以发现 &#x2F;、&#x2F;boot、&#x2F;home 为三个不同的 filesystem（每一行的文件属性并不相同，且三个目录的挂载点也均不相同）</p>
<p>从使用文件系统的观点来看，同一个 filesystem 的某个 inode 只会对应到一个文件内容而已（一个文件占用一个 inode ），因此可以通过判断 inode 号码来确认不同文件名是否为相同的文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@172-12-0-1 /]# <span class="built_in">ls</span> -ild /  /.  /..</span><br><span class="line">128 dr-xr-xr-x. 24 root root 4096 7月  30 17:11 /</span><br><span class="line">128 dr-xr-xr-x. 24 root root 4096 7月  30 17:11 /.</span><br><span class="line">128 dr-xr-xr-x. 24 root root 4096 7月  30 17:11 /..</span><br></pre></td></tr></table></figure>

<p>上面的信息中由于挂载点均为 &#x2F; ，因此三个文件均在同一个 filesystem 内，而这三个文件的 inode 号码均为 128 号，因此这三个文件名都指向同一个 inode 号码，所以这三个文件是完全一样的。</p>
<h2 id="其他-Linux-支持的文件系统与-VFS"><a href="#其他-Linux-支持的文件系统与-VFS" class="headerlink" title="其他 Linux 支持的文件系统与 VFS"></a>其他 Linux 支持的文件系统与 VFS</h2><p>常见的支持文件系统有：</p>
<ul>
<li><p>传统文件系统：ext2 &#x2F; minix &#x2F; MS-DOS &#x2F; FAT（用 vfat 模块）&#x2F; iso9660 （光盘）等</p>
</li>
<li><p>日志式文件系统： ext3 &#x2F;ext4 &#x2F; ReiserFS &#x2F; Windows’ NTFS &#x2F; IBM’s JFS &#x2F; SGI’s XFS &#x2F;ZFS</p>
</li>
<li><p>网络文件系统： NFS &#x2F; SMBFS</p>
</li>
<li><p>查看你的 Linux 支持的文件系统有哪些</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@172-12-0-1 /]# <span class="built_in">ls</span> -l /lib/modules/$(<span class="built_in">uname</span> -r)/kernel/fs</span><br><span class="line">总用量 20</span><br><span class="line">-rw-r--r--. 1 root root 7792 12月 22 2021 binfmt_misc.ko.xz</span><br><span class="line">drwxr-xr-x. 2 root root   30 7月  18 19:35 cachefiles</span><br><span class="line">drwxr-xr-x. 2 root root   24 7月  18 19:35 ceph</span><br><span class="line">drwxr-xr-x. 2 root root   24 7月  18 19:35 cifs</span><br><span class="line">drwxr-xr-x. 2 root root   26 7月  18 19:35 cramfs</span><br><span class="line">drwxr-xr-x. 2 root root   23 7月  18 19:35 dlm</span><br><span class="line">drwxr-xr-x. 2 root root   24 7月  18 19:35 ext4</span><br><span class="line">drwxr-xr-x. 2 root root   60 7月  18 19:35 fat</span><br><span class="line">drwxr-xr-x. 2 root root   27 7月  18 19:35 fscache</span><br><span class="line">drwxr-xr-x. 2 root root   46 7月  18 19:35 fuse</span><br><span class="line">drwxr-xr-x. 2 root root   24 7月  18 19:35 gfs2</span><br><span class="line">drwxr-xr-x. 2 root root   25 7月  18 19:35 isofs</span><br><span class="line">drwxr-xr-x. 2 root root   24 7月  18 19:35 jbd2</span><br><span class="line">drwxr-xr-x. 2 root root   25 7月  18 19:35 lockd</span><br><span class="line">-rw-r--r--. 1 root root 4900 12月 22 2021 mbcache.ko.xz</span><br><span class="line">drwxr-xr-x. 5 root root  120 7月  18 19:35 nfs</span><br><span class="line">drwxr-xr-x. 2 root root   46 7月  18 19:35 nfs_common</span><br><span class="line">drwxr-xr-x. 2 root root   24 7月  18 19:35 nfsd</span><br><span class="line">drwxr-xr-x. 2 root root 4096 7月  18 19:35 nls</span><br><span class="line">drwxr-xr-x. 2 root root   27 7月  18 19:35 overlayfs</span><br><span class="line">drwxr-xr-x. 2 root root   27 7月  18 19:35 pstore</span><br><span class="line">drwxr-xr-x. 2 root root   28 7月  18 19:35 squashfs</span><br><span class="line">drwxr-xr-x. 2 root root   23 7月  18 19:35 udf</span><br><span class="line">drwxr-xr-x. 2 root root   23 7月  18 19:35 xfs</span><br></pre></td></tr></table></figure>

<ul>
<li>系统目前已载入到内存中支持的文件系统</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@172-12-0-1 /]# <span class="built_in">cat</span> /proc/filesystems</span><br><span class="line">nodev	sysfs</span><br><span class="line">nodev	tmpfs</span><br><span class="line">nodev	bdev</span><br><span class="line">nodev	proc</span><br><span class="line">nodev	cgroup</span><br><span class="line">nodev	cgroup2</span><br><span class="line">nodev	cpuset</span><br><span class="line">nodev	devtmpfs</span><br><span class="line">nodev	configfs</span><br><span class="line">nodev	debugfs</span><br><span class="line">nodev	tracefs</span><br><span class="line">nodev	securityfs</span><br><span class="line">nodev	sockfs</span><br><span class="line">nodev	bpf</span><br><span class="line">nodev	pipefs</span><br><span class="line">nodev	ramfs</span><br><span class="line">nodev	hugetlbfs</span><br><span class="line">nodev	devpts</span><br><span class="line">nodev	autofs</span><br><span class="line">nodev	pstore</span><br><span class="line">nodev	mqueue</span><br><span class="line">	fuseblk</span><br><span class="line">nodev	fuse</span><br><span class="line">nodev	fusectl</span><br><span class="line">	xfs</span><br><span class="line">nodev	overlay</span><br></pre></td></tr></table></figure>

<h3 id="Linux-VFS-（Virtual-Filesystem-Switch）"><a href="#Linux-VFS-（Virtual-Filesystem-Switch）" class="headerlink" title="Linux VFS （Virtual Filesystem Switch）"></a>Linux VFS （Virtual Filesystem Switch）</h3><p><strong>Linux 的核心是如何管理这些文件系统呢？</strong></p>
<p>整个 Linux 的 filesystem 都是 VFS 在进行管理，使用者并不需要知道每个 partition 上头的 filesystem 是什么，VFS 会主动做好读取的动作</p>
<blockquote>
<p> 假设你的 &#x2F; 使用的是 &#x2F;dev&#x2F;hda1 ，用 ext3 ，而 &#x2F;home 使用 &#x2F;dev&#x2F;hda2 ，用 reiserfs ，那么你取用 &#x2F;home&#x2F;dmtsai&#x2F;.bashrc 时，不需要指定要用的什么文件系统的模块来读取！这个就是 VFS 的功能！</p>
</blockquote>
<p>通过这个 VFS 的功能来管理所有的 filesystem，省去我们需要自行设置读取文件系统的定义。</p>
<h3 id="XFS-文件系统简介"><a href="#XFS-文件系统简介" class="headerlink" title="XFS 文件系统简介"></a>XFS 文件系统简介</h3><p>CentOS 7 开始，默认的文件系统已经由原本的 EXT4 变成了 XFS 文件系统了，这是因为</p>
<ul>
<li>EXT 家族当前较伤脑筋的地方：支持度最广，但格式化超慢</li>
</ul>
<p>Ext 文件系统对于文件格式化的处理方面，采用的是<strong>预先规划</strong>出所有的 inode&#x2F;block&#x2F;metadata 等数据，未来系统可以直接取用，不需要再进行动态配置的作法。这个作法在早期磁盘容量还不大的时候没啥问题，但时至今日，磁盘容量越来越大，连传统的 MBR 都已经被 GPT 所取代，现在都已经说到 PB 或 EB 以上容量了！当你的 TB 以上等级的传统 ext 家族文件系统在格式化的时候，光是系统要预先分配 inode 与 block 就要消耗好多时间。</p>
<blockquote>
<p>由于虚拟化的应用越来越广泛，而作为虚拟化磁盘来源的巨型文件（单一文件好几个GB 以上）也就越来越常见了。这种巨型文件在处理上需要考虑到性能问题，否则虚拟磁盘的效率就会不太好看。因此，从 CentOS 7.x 开始，文件系统已经由默认的 Ext4 变成了xfs 这一个较适合大容量磁盘与巨型文件性能较佳的文件系统了</p>
</blockquote>
<h4 id="XFS-文件系统的配置"><a href="#XFS-文件系统的配置" class="headerlink" title="XFS 文件系统的配置"></a>XFS 文件系统的配置</h4><p>xfs 是一个<strong>日志式文件系统</strong>，而 CentOS 7.x 拿它当默认的文件系统，最早之前，这个 xfs 就是<strong>用于大容量磁盘以及高性能文件系统</strong>，相当适合现在的系统环境。此外，几乎所有 Ext4 文件系统有的功能， xfs 都可以具备！</p>
<p>xfs 文件系统在数据的分布上，主要规划为三个部份，一个数据区（data section）、一个文件系统活动登录区（log section）以及一个实时运行区（realtime section）。这三个区域的数据内容如下：</p>
<ul>
<li><p>数据区（data section）</p>
<p>基本上，数据区就跟ext 家族一样，包括 <code>inode/data block/superblock</code> 等数据，都放置在这个区块。这个数据区与 ext 家族的 block group 类似，也是分为多个储存区群组（allocation groups）来分别放置文件系统所需要的数据。</p>
<p>每个储存区群组都包含了</p>
<ul>
<li>整个文件系统的 superblock</li>
<li>剩余空间的管理机制</li>
<li>inode的分配与追踪</li>
</ul>
<p>此外，<strong>inode与 block</strong> 都是系统需要<strong>用到时才动态配置产生</strong>，所以格式化动作快。</p>
<p>与 ext 家族不同的是， xfs 的 block 与 inode 有<strong>多种不同的容量可供设置</strong>，block 容量可在 512Bytes ~ 64K 之间调整，不过，Linux 由于<strong>内存管理和分页机制</strong>的关系（<em>Linux 系统使用分页机制来管理内存，物理内存被分成固定大小的页（pages），页大小通常为 4 KB（即 4096 字节）</em>），大多数 block 设置为 4K， <strong>与页大小对齐</strong>，以提高性能和效率。</p>
<blockquote>
<p>设置块大小</p>
<p>mkfs.xfs -b size&#x3D;4096 &#x2F;dev&#x2F;sdX</p>
</blockquote>
<p>至于 inode 容量可设置 256Bytes 到 2M。一般保留 256Bytes 的默认值就够用了</p>
<blockquote>
<p>设置inode大小</p>
<p>mkfs.xfs -i size&#x3D;256 &#x2F;dev&#x2F;sdX</p>
</blockquote>
</li>
<li><p>文件系统活动登录区（log section）</p>
<p>这个区域主要被用来<strong>记录文件系统的变化</strong>，直到该变化完整的写入到数据区后，才会被终结。</p>
<p>如果文件系统因为某些缘故（例如最常见的停电）而损毁时，系统会拿这个登录区块来进行检验，看看系统挂掉之前，文件系统正在运行哪些动作，快速的修复文件系统。</p>
<p>在这个区域中，磁盘活动是相当频繁的，你可以指定外部的SSD 磁盘来作为 xfs 文件系统的日志区块，这样当系统需要进行任何活动时，就可以更快速的进行工作。</p>
</li>
<li><p>实时运行区（realtime section）</p>
<p>当有文件要被创建时，xfs 会在这个区段里面找一个到数个 extent 区块，将文件放置在这个区块内，等到分配完毕后，再写入到数据区的 inode 与 block 去。</p>
<p>这个 <strong><code>extent</code></strong> 区块的大小 (4K - 1G)要在格式化的时候就先指定。一般磁盘默认为 64K 容量，最好不要乱动，因为可能会影响到实体磁盘的性能。</p>
</li>
<li><p>XFS 文件系统的描述数据观察</p>
<p>可以使用 <code>xfs_info</code> 指令观察</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 找出 /boot 这个挂载点下面的文件系统的 superblock 纪录</span></span><br><span class="line">[root@172-12-0-1 ~]# <span class="built_in">df</span> -T /boot</span><br><span class="line">文件系统       类型   1K-块   已用   可用 已用% 挂载点</span><br><span class="line">/dev/nvme0n1p1 xfs  1038336 214876 823460   21% /boot</span><br><span class="line"><span class="comment"># 可以看出是xfs文件系统</span></span><br><span class="line">[root@172-12-0-1 ~]# xfs_info /dev/nvme0n1p1</span><br><span class="line"><span class="comment"># isize 是inode 的容量，agcount 是储存区群组（allocation group）的个数，agsize 是每个储存区群组具有 65536 个 block，配合第 12 行的 block 设置为 4K，因此整个文件系统的容量应该就是 65536 * 4 * 4 = 1048576k = 1G 这么大</span></span><br><span class="line">meta-data=/dev/nvme0n1p1         isize=512    agcount=4, agsize=65536 blks</span><br><span class="line"><span class="comment"># sectsz 是逻辑扇区</span></span><br><span class="line">         =                       sectsz=512   attr=2, projid32bit=1</span><br><span class="line">         =                       crc=1        finobt=1, sparse=1, rmapbt=0</span><br><span class="line">         =                       reflink=1</span><br><span class="line"><span class="comment"># bsize 是block 的容量，整个文件系统有262144个block</span></span><br><span class="line">data     =                       bsize=4096   blocks=262144, imaxpct=25</span><br><span class="line"><span class="comment"># sunit和swidth 与磁盘阵列的 stripe 相关性较高，这里没有使用磁盘阵列</span></span><br><span class="line">         =                       sunit=0      swidth=0 blks</span><br><span class="line">naming   =version 2              bsize=4096   ascii-ci=0, ftype=1</span><br><span class="line"><span class="comment"># internal 表示登录区位置在文件系统内， 2560 * 4K = 10M容量</span></span><br><span class="line"><span class="built_in">log</span>      =internal <span class="built_in">log</span>           bsize=4096   blocks=2560, version=2</span><br><span class="line">         =                       sectsz=512   sunit=0 blks, lazy-count=1</span><br><span class="line"><span class="comment"># 实时运行区， extent 容量为 4K，不过目前并没有使用</span></span><br><span class="line">realtime =none                   extsz=4096   blocks=0, rtextents=0</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="文件系统的简单操作"><a href="#文件系统的简单操作" class="headerlink" title="文件系统的简单操作"></a>文件系统的简单操作</h2><h3 id="磁盘与目录的容量"><a href="#磁盘与目录的容量" class="headerlink" title="磁盘与目录的容量"></a>磁盘与目录的容量</h3><p>磁盘的整体数据在 superblock 区块中，但是每个文件的容量是在 inode当中记录的</p>
<ul>
<li>df：列出文件系统的整体磁盘使用量</li>
<li>du：评估文件系统的磁盘使用量（常用在推估目录所占容量）</li>
</ul>
<h4 id="df"><a href="#df" class="headerlink" title="df"></a>df</h4><ul>
<li>以易读的方式显示容量</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@172-12-0-1 ~]# <span class="built_in">df</span> -h</span><br><span class="line">文件系统             容量  已用  可用 已用% 挂载点</span><br><span class="line">devtmpfs             3.8G     0  3.8G    0% /dev</span><br><span class="line"><span class="comment"># /dev/shm 利用内存虚拟出来的磁盘空间，通常是总实体内存的一半，存取速度快，但是数据在关机后会丢失</span></span><br><span class="line">tmpfs                3.8G     0  3.8G    0% /dev/shm</span><br><span class="line">tmpfs                3.8G  9.1M  3.8G    1% /run</span><br><span class="line">tmpfs                3.8G     0  3.8G    0% /sys/fs/cgroup</span><br><span class="line">/dev/mapper/cl-root   35G   12G   24G   34% /</span><br><span class="line">/dev/nvme0n1p1      1014M  210M  805M   21% /boot</span><br><span class="line">tmpfs                775M     0  775M    0% /run/user/0</span><br><span class="line">overlay               35G   12G   24G   34% /var/lib/docker/overlay2/fbc51c4c7f4544effda9d2328bb3d841f0035c6678e211e968f18f31cf14ffb4/merged</span><br></pre></td></tr></table></figure>

<ul>
<li>将 &#x2F;etc 下面的可用的磁盘容量以易读的容量格式显示</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@172-12-0-1 ~]# <span class="built_in">df</span> -h /etc</span><br><span class="line">文件系统             容量  已用  可用 已用% 挂载点</span><br><span class="line">/dev/mapper/cl-root   35G   12G   24G   34% /</span><br></pre></td></tr></table></figure>

<ul>
<li>将目前各个 partition 当中可用的 inode 数量列出</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@172-12-0-1 ~]# <span class="built_in">df</span> -ih</span><br><span class="line">文件系统            Inode 已用(I) 可用(I) 已用(I)% 挂载点</span><br><span class="line">devtmpfs             964K     400    963K       1% /dev</span><br><span class="line">tmpfs                968K       1    968K       1% /dev/shm</span><br><span class="line">tmpfs                968K     736    968K       1% /run</span><br><span class="line">tmpfs                968K      17    968K       1% /sys/fs/cgroup</span><br><span class="line">/dev/mapper/cl-root   18M    143K     18M       1% /</span><br><span class="line">/dev/nvme0n1p1       512K     311    512K       1% /boot</span><br><span class="line">tmpfs                968K       6    968K       1% /run/user/0</span><br><span class="line">overlay               18M    143K     18M       1% /var/lib/docker/overlay2/fbc51c4c7f4544effda9d2328bb3d841f0035c6678e211e968f18f31cf14ffb4/merged</span><br></pre></td></tr></table></figure>

<p>由于 <code>df</code> 读取的数据几乎都是针对整个文件系统，因此读取的范围主要是在 <code>Superblock</code> 内的信息，所以这个指令显示结果的速度非常的快速，在显示的结果中需要特别留意根目录的剩余容量，因为所有的数据都是由根目录衍生出来的。</p>
<h4 id="du"><a href="#du" class="headerlink" title="du"></a>du</h4><ul>
<li>检查根目录下面每个目录所占用的容量</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@172-12-0-1 ~]# <span class="built_in">du</span> -smh /*</span><br><span class="line">0	/bin</span><br><span class="line">171M	/boot</span><br><span class="line">0	/dev</span><br><span class="line">25M	/etc</span><br><span class="line">321M	/git</span><br><span class="line">1.5G	/home</span><br><span class="line">0	/lib</span><br><span class="line">0	/lib64</span><br><span class="line">0	/media</span><br><span class="line">92M	/minikube-linux-amd64</span><br><span class="line">0	/mnt</span><br><span class="line">100M	/myblog</span><br><span class="line">24M	/node_modules</span><br><span class="line">0	/opt</span><br><span class="line">20K	/package-lock.json</span><br><span class="line">4.0K	/patch</span><br><span class="line"><span class="comment"># 因为/proc 是内存内的程序，程序执行结束就会消失，因此会有些目录找不到</span></span><br><span class="line"><span class="built_in">du</span>: 无法访问<span class="string">&#x27;/proc/1370017/task/1370017/fd/4&#x27;</span>: 没有那个文件或目录</span><br><span class="line"><span class="built_in">du</span>: 无法访问<span class="string">&#x27;/proc/1370017/task/1370017/fdinfo/4&#x27;</span>: 没有那个文件或目录</span><br><span class="line"><span class="built_in">du</span>: 无法访问<span class="string">&#x27;/proc/1370017/fd/4&#x27;</span>: 没有那个文件或目录</span><br><span class="line"><span class="built_in">du</span>: 无法访问<span class="string">&#x27;/proc/1370017/fdinfo/4&#x27;</span>: 没有那个文件或目录</span><br><span class="line">0	/proc</span><br><span class="line">185M	/root</span><br><span class="line">9.1M	/run</span><br><span class="line">0	/sbin</span><br><span class="line">0	/srv</span><br><span class="line">0	/sys</span><br><span class="line">40K	/test</span><br><span class="line">0	/tmp</span><br><span class="line">2.7G	/usr</span><br><span class="line">6.0G	/var</span><br><span class="line">1.4G	/www</span><br></pre></td></tr></table></figure>

<p>与 df 不一样的是，<code>du</code> 指令会直接到文件系统去搜索所有的文件数据，速度较慢。</p>
<blockquote>
<p>想要列出某目录下的全部数据，可以加上 -S 的选项，减少次目录的加总</p>
</blockquote>
<h2 id="实体链接与符号链接：-ln"><a href="#实体链接与符号链接：-ln" class="headerlink" title="实体链接与符号链接： ln"></a>实体链接与符号链接： ln</h2><p>在 Linux 下面的链接文件有两种:</p>
<ol>
<li>符号链接（Symbolic Link）：一个特殊类型的文件，它指向另一个<strong>文件或目录</strong>的路径。可以理解为Windows中的快捷方式<ul>
<li>创建：<code>ln -s /path/to/original /path/to/symlink</code></li>
<li>特点：<ul>
<li>可以跨文件系统创建</li>
<li>删除源文件后，符号链接会变成无效链接（悬空链接）</li>
<li>使用<code>ls -l</code>查看符号链接时，显示形式为<code>lrwxrwxrwx</code>，并显示链接目标</li>
<li>修改链接文件时，源文件也会变更</li>
</ul>
</li>
</ul>
</li>
<li>硬链接（hard link）：一个文件系统中的<strong>文件</strong>指针，指向相同的 inode 号，即指向实际的数据块。硬链接和原文件共享相同的 inode 和数据块（<code>类似Java中的对象引用</code>）<ul>
<li>创建：<code>ln /path/to/original /path/to/hardlink</code></li>
<li>特点;<ul>
<li>不能跨文件系统创建</li>
<li>删除原文件时，硬链接仍然有效，因为它们指向相同的 inode</li>
<li>使用<code>ls -l</code>查看硬链接时，显示形式为<code>-rw-r--r--</code>，没有链接信息</li>
<li>不能link目录</li>
<li>修改链接文件其实就是在修改源文件</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="磁盘的分区、格式化、检验与挂载"><a href="#磁盘的分区、格式化、检验与挂载" class="headerlink" title="磁盘的分区、格式化、检验与挂载"></a>磁盘的分区、格式化、检验与挂载</h2><p>我们想要在系统里面新增一颗磁盘时，有哪些动作需要做呢：</p>
<ol>
<li>对磁盘进行分区，以创建可用的 partition </li>
<li>对分区进行格式化（format），以创建系统可用的 filesystem</li>
<li>对刚刚创建好的 filesystem 进行检验（可选）</li>
<li>在 Linux 系统上，需要创建挂载点（目录），并将它挂载上来</li>
</ol>
<h3 id="观察磁盘分区状态"><a href="#观察磁盘分区状态" class="headerlink" title="观察磁盘分区状态"></a>观察磁盘分区状态</h3><h4 id="lsblk-（list-block-device）列出系统上的所有磁盘列表"><a href="#lsblk-（list-block-device）列出系统上的所有磁盘列表" class="headerlink" title="lsblk （list block device）列出系统上的所有磁盘列表"></a>lsblk （list block device）列出系统上的所有磁盘列表</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@172-12-0-1 /]# lsblk</span><br><span class="line"><span class="comment">#NAME :设备文件名，会省略/dev等前导目录</span></span><br><span class="line"><span class="comment"># MAJ:MIN :主要：次要设备代码</span></span><br><span class="line"><span class="comment"># RM :是否为可卸载设备，如U盘</span></span><br><span class="line"><span class="comment"># RO :是否为只读设备</span></span><br><span class="line">NAME        MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sr0          11:0    1  789M  0 rom  </span><br><span class="line">nvme0n1     259:0    0   40G  0 disk </span><br><span class="line">├─nvme0n1p1 259:1    0    1G  0 part /boot</span><br><span class="line">└─nvme0n1p2 259:2    0   39G  0 part </span><br><span class="line">  ├─cl-root 253:0    0   35G  0 lvm  /</span><br><span class="line">  └─cl-swap 253:1    0    4G  0 lvm</span><br></pre></td></tr></table></figure>

<h4 id="blkid-列出设备的-UUID-等参数"><a href="#blkid-列出设备的-UUID-等参数" class="headerlink" title="blkid 列出设备的 UUID 等参数"></a>blkid 列出设备的 UUID 等参数</h4><blockquote>
<p>lsblk 也可以使用 -f 来列出文件系统与设备的 UUID 数据</p>
</blockquote>
<p>UUID 是全域单一识别码（universally unique identifier），Linux 会将系统内所有的设备都给予一个识别码，作为挂载或者使用这个设备&#x2F;文件系统</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@172-12-0-1 /]# blkid</span><br><span class="line">/dev/nvme0n1p1: UUID=<span class="string">&quot;1042e93c-e0b7-419f-9253-d38b759bce52&quot;</span> BLOCK_SIZE=<span class="string">&quot;512&quot;</span> TYPE=<span class="string">&quot;xfs&quot;</span> PARTUUID=<span class="string">&quot;ad2a4d81-01&quot;</span></span><br><span class="line">/dev/nvme0n1p2: UUID=<span class="string">&quot;SJB3Rh-mEln-qIDL-Z3Zt-Hr2M-0NGa-NxGZWd&quot;</span> TYPE=<span class="string">&quot;LVM2_member&quot;</span> PARTUUID=<span class="string">&quot;ad2a4d81-02&quot;</span></span><br><span class="line">/dev/sr0: BLOCK_SIZE=<span class="string">&quot;2048&quot;</span> UUID=<span class="string">&quot;2021-11-13-00-32-00-00&quot;</span> LABEL=<span class="string">&quot;CentOS-8-5-2111-x86_64-dvd&quot;</span> TYPE=<span class="string">&quot;iso9660&quot;</span> PTUUID=<span class="string">&quot;45f5f6ac&quot;</span> PTTYPE=<span class="string">&quot;dos&quot;</span></span><br><span class="line">/dev/mapper/cl-root: UUID=<span class="string">&quot;3d1bfc52-aa9d-459d-89fa-1142cc63fc9c&quot;</span> BLOCK_SIZE=<span class="string">&quot;512&quot;</span> TYPE=<span class="string">&quot;xfs&quot;</span></span><br><span class="line">/dev/mapper/cl-swap: UUID=<span class="string">&quot;46dd982b-9cf4-4626-8675-c9a8773c5962&quot;</span> TYPE=<span class="string">&quot;swap&quot;</span></span><br><span class="line">/dev/nvme0n1: PTUUID=<span class="string">&quot;ad2a4d81&quot;</span> PTTYPE=<span class="string">&quot;dos&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="parted-列出磁盘的分区表类型与分区信息"><a href="#parted-列出磁盘的分区表类型与分区信息" class="headerlink" title="parted 列出磁盘的分区表类型与分区信息"></a>parted 列出磁盘的分区表类型与分区信息</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@172-12-0-1 /]# parted /dev/mapper/cl-root <span class="built_in">print</span></span><br><span class="line">Model: Linux device-mapper (linear) (dm)	<span class="comment"># 磁盘的模块名称（厂商）</span></span><br><span class="line">Disk /dev/mapper/cl-root: 37.6GB	<span class="comment"># 磁盘总容量</span></span><br><span class="line">Sector size (logical/physical): 512B/512B	<span class="comment"># 磁盘的每个逻辑/物理扇区容量</span></span><br><span class="line">Partition Table: loop	<span class="comment"># 分区表的格式（MBR/GPT），这里是虚拟机的缘故</span></span><br><span class="line">Disk Flags: </span><br><span class="line"></span><br><span class="line">Number  Start  End     Size    File system  标志		<span class="comment"># 分区数据</span></span><br><span class="line"> 1      0.00B  37.6GB  37.6GB  xfs</span><br></pre></td></tr></table></figure>

<h3 id="磁盘分区：-gdisk-fdisk"><a href="#磁盘分区：-gdisk-fdisk" class="headerlink" title="磁盘分区： gdisk&#x2F;fdisk"></a>磁盘分区： gdisk&#x2F;fdisk</h3><p>MBR 分区表请使用 fdisk 分区， GPT 分区表请使用 gdisk 分区</p>
<h4 id="gdisk"><a href="#gdisk" class="headerlink" title="gdisk"></a>gdisk</h4><blockquote>
<p> 具体分区操作可以直接按照界面提示来，</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@172-12-0-1 /]# gdisk /dev/vda  <span class="comment">#设备名称不要加上数字</span></span><br><span class="line">Command （? <span class="keyword">for</span> <span class="built_in">help</span>）: ?</span><br><span class="line">b       back up GPT data to a file</span><br><span class="line">c       change a partition<span class="string">&#x27;s name</span></span><br><span class="line"><span class="string">d       delete a partition           # 删除一个分区</span></span><br><span class="line"><span class="string">i       show detailed information on a partition</span></span><br><span class="line"><span class="string">l       list known partition types</span></span><br><span class="line"><span class="string">n       add a new partition          # 增加一个分区</span></span><br><span class="line"><span class="string">o       create a new empty GUID partition table （GPT）</span></span><br><span class="line"><span class="string">p       print the partition table    # 印出分区表（常用）</span></span><br><span class="line"><span class="string">q       quit without saving changes  # 不储存分区就直接离开 gdisk</span></span><br><span class="line"><span class="string">r       recovery and transformation options （experts only）</span></span><br><span class="line"><span class="string">s       sort partitions</span></span><br><span class="line"><span class="string">t       change a partition&#x27;</span>s <span class="built_in">type</span> code</span><br><span class="line">v       verify disk</span><br><span class="line">w       write table to disk and <span class="built_in">exit</span> <span class="comment"># 储存分区操作后离开 gdisk</span></span><br><span class="line">x       extra functionality （experts only）</span><br><span class="line">?       <span class="built_in">print</span> this menu</span><br><span class="line">Command （? <span class="keyword">for</span> <span class="built_in">help</span>）:</span><br></pre></td></tr></table></figure>

<ul>
<li>示例</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@172-12-0-1 /]# gdisk /dev/vda</span><br><span class="line">Command （? <span class="keyword">for</span> <span class="built_in">help</span>）: p</span><br><span class="line">Number  Start （sector）    End （sector）  Size       Code  Name   </span><br><span class="line">1            2048            6143   	 2.0 MiB     EF02    </span><br><span class="line">2            6144         2103295   	1024.0 MiB   0700   </span><br><span class="line">3         2103296        65026047   	 30.0 GiB    8E00</span><br><span class="line"><span class="comment"># 找出最后一个 sector 的号码</span></span><br><span class="line">Command （? <span class="keyword">for</span> <span class="built_in">help</span>）: ?  <span class="comment"># 查一下增加分区的指令为何</span></span><br><span class="line">Command （? <span class="keyword">for</span> <span class="built_in">help</span>）: n  <span class="comment"># 开始新增的行为</span></span><br><span class="line">Partition number （4-128, default 4）: 4  <span class="comment"># 默认就是 4 号，直接 enter 即可</span></span><br><span class="line">First sector （34-83886046, default = 65026048） or &#123;+-&#125;size&#123;KMGTP&#125;: 65026048  <span class="comment"># 默认是上个分区的最后一个扇区 + 1，直接enter</span></span><br><span class="line">Last sector （65026048-83886046, default = 83886046） or &#123;+-&#125;size&#123;KMGTP&#125;: +1G</span><br><span class="line"><span class="comment"># 不需要自己去计算扇区号码，通过 +容量的这个方式，就可以让 gdisk 算出最接近你需要的容量的扇区号码</span></span><br><span class="line"></span><br><span class="line">Current <span class="built_in">type</span> is <span class="string">&#x27;Linux filesystem&#x27;</span></span><br><span class="line">Hex code or GUID （L to show codes, Enter = 8300）: <span class="comment"># 使用默认值即可～直接 enter</span></span><br><span class="line"><span class="comment"># 这里让你选择未来这个分区预计使用的文件系统！默认都是 Linux 文件系统的 8300（可以使用-l查看）</span></span><br></pre></td></tr></table></figure>

<p>输入<code>w</code>保存后，由于Linux正在使用这颗磁盘，担心系统出问题，所以分区表不会进行更新，可以重启或者通过 <code>partprobe </code>指令来处理</p>
<h5 id="partprobe-更新-Linux-核心的分区表信息"><a href="#partprobe-更新-Linux-核心的分区表信息" class="headerlink" title="partprobe 更新 Linux 核心的分区表信息"></a>partprobe 更新 Linux 核心的分区表信息</h5><p><code>partprobe -s</code></p>
<h4 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h4><p>跟gdisk差不多</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@172-12-0-1 /]# fdisk /dev/sda</span><br><span class="line">Command （m <span class="keyword">for</span> <span class="built_in">help</span>）: m   <span class="comment"># 输入 m 后，就会看到下面这些指令介绍</span></span><br><span class="line">Command action   </span><br><span class="line">a   toggle a bootable flag   </span><br><span class="line">b   edit bsd disklabel   </span><br><span class="line">c   toggle the dos compatibility flag   </span><br><span class="line">d   delete a partition   <span class="comment">#删除一个partition   </span></span><br><span class="line">l   list known partition types   </span><br><span class="line">m   <span class="built_in">print</span> this menu   </span><br><span class="line">n   add a new partition  <span class="comment"># 新增一个partition   </span></span><br><span class="line">o   create a new empty DOS partition table   </span><br><span class="line">p   <span class="built_in">print</span> the partition table     <span class="comment"># 在屏幕上显示分区表   </span></span><br><span class="line">q   quit without saving changes   <span class="comment"># 不储存离开fdisk程序   </span></span><br><span class="line">s   create a new empty Sun disklabel   </span><br><span class="line">t   change a partition<span class="string">&#x27;s system id   </span></span><br><span class="line"><span class="string">u   change display/entry units   </span></span><br><span class="line"><span class="string">v   verify the partition table   </span></span><br><span class="line"><span class="string">w   write table to disk and exit  # 将刚刚的动作写入分区表   </span></span><br><span class="line"><span class="string">x   extra functionality （experts only）</span></span><br></pre></td></tr></table></figure>

<h3 id="磁盘格式化（创建文件系统）"><a href="#磁盘格式化（创建文件系统）" class="headerlink" title="磁盘格式化（创建文件系统）"></a>磁盘格式化（创建文件系统）</h3><p>格式化的指令<code>makefilesystem, mkfs</code>，这是个综合的指令，它会去调用正确的<strong>文件系统格式化工具</strong>软件。<strong>格式化</strong>应该称为创建文件系统（make filesystem）才对！</p>
<p>创建 xfs 文件系统，使用 <code>mkfs.xfs</code> 指令，<code>mkfs.xfs /dev/vda4</code></p>
<p>创建ext4文件系统，使用<code>mkfs.ext4</code>指令，<code>mkfs.ext4 /dev/vda5</code></p>
<ul>
<li>查看支持哪些mkfs指令</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@172-12-0-1 ~]# mkfs[Tab][Tab]</span><br><span class="line">mkfs         mkfs.cramfs  mkfs.ext2    mkfs.ext3    mkfs.ext4    mkfs.minix   mkfs.xfs</span><br></pre></td></tr></table></figure>

<h3 id="文件系统检验"><a href="#文件系统检验" class="headerlink" title="文件系统检验"></a>文件系统检验</h3><h4 id="xfs-repair-处理-XFS-文件系统"><a href="#xfs-repair-处理-XFS-文件系统" class="headerlink" title="xfs_repair 处理 XFS 文件系统"></a>xfs_repair 处理 XFS 文件系统</h4><p>当有 xfs 文件系统错乱才需要使用这个指令 <code>xfs_repair [-fnd] 设备名称</code>，修复时需要先卸载设备，如果时根目录有问题，就要进入<strong>单人维护或救援模式</strong>，然后通过 <code>-d</code> 这个选项来处理</p>
<h4 id="fsck-ext4-处理-EXT4-文件系统"><a href="#fsck-ext4-处理-EXT4-文件系统" class="headerlink" title="fsck.ext4 处理 EXT4 文件系统"></a>fsck.ext4 处理 EXT4 文件系统</h4><p>fsck 是个<strong>综合指令</strong>，针对 ext4 建议直接使用 fsck.ext4 来检测，<code>fsck.ext4 [-pf] [-b superblock] 设备名称</code></p>
<blockquote>
<p>通常只有 root 且文件系统有问题的时候才使用这个指令，在正常状况下使用，可能会造成对系统的危害！</p>
<p>通常使用这个指令的场合都是在系统出现极大的问题，导致你在 Linux 开机的时候得进入单人单机模式下进行维护的行为时，才必须使用此一指令</p>
</blockquote>
<h3 id="文件系统挂载与卸载"><a href="#文件系统挂载与卸载" class="headerlink" title="文件系统挂载与卸载"></a>文件系统挂载与卸载</h3><h4 id="文件挂载：mount"><a href="#文件挂载：mount" class="headerlink" title="文件挂载：mount"></a>文件挂载：mount</h4><p>前面提到挂载点是目录，而这个目录是进入磁盘分区（文件系统）的入口</p>
<p>不过要进行挂载前最好先确定几件事：</p>
<ol>
<li>单一文件系统不应该被重复挂载在不同的挂载点（目录）中</li>
<li>单一目录不应该重复挂载多个文件系统</li>
<li>要作为挂载点的目录，理论上应该都是空目录</li>
</ol>
<p><strong>注意：如果挂载的目录里面不是空的，那么挂载了文件系统之后，原目录下的东西就会暂时消失，等到新分区被卸载之后才会出现</strong></p>
<blockquote>
<p> 举个例子，假设你的 &#x2F;home 原本与根目录（&#x2F;）在同一个文件系统中，下面原本就有 &#x2F;home&#x2F;test 与 &#x2F;home&#x2F;vbird 两个目录。然后你想要加入新的磁盘，并且直接挂载 &#x2F;home 下面，那么当你挂载上新的分区时，则 &#x2F;home 目录显示的是新分区内的数据，至于原先的 test 与 vbird 这两个目录就会暂时的被<strong>隐藏</strong>掉了。等到新分区被卸载之后，则 &#x2F;home 原本的内容就会再次出现！</p>
</blockquote>
<p>而要将文件系统挂载到我们的 Linux 系统上，就要使用 <code>mount</code> 这个指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@172-12-0-1 ~]# mount -a</span><br><span class="line">[root@172-12-0-1 ~]# mount [-l]</span><br><span class="line">[root@172-12-0-1 ~]# mount [-t 文件系统] LABEL=<span class="string">&#x27;&#x27;</span>  挂载点</span><br><span class="line">[root@172-12-0-1 ~]# mount [-t 文件系统] UUID=<span class="string">&#x27;&#x27;</span>   挂载点</span><br><span class="line">[root@172-12-0-1 ~]# mount [-t 文件系统] 设备文件名挂载点</span><br><span class="line">选项与参数：</span><br><span class="line">-a  ：依照配置文件 [/etc/fstab](../Text/index.html#fstab) 的数据将所有未挂载的磁盘都挂载上来</span><br><span class="line">-l  ：单纯的输入 mount 会显示目前挂载的信息。加上 -l 可增列 Label 名称</span><br><span class="line">-t  ：可以加上文件系统种类来指定欲挂载的类型。常见的 Linux 支持类型有：xfs, ext3, ext4</span><br><span class="line">-n  ：在默认的情况下，系统会将实际挂载的情况实时写入 /etc/mtab 中，以利其他程序的运行。但在某些情况下（例如单人维护模式）为了避免问题会刻意不写入。此时就得要使用 -n 选项</span><br><span class="line">-o  ：后面可以接一些挂载时额外加上的参数！比方说帐号、密码、读写权限等：</span><br><span class="line">	async, <span class="built_in">sync</span>:   此文件系统是否使用同步写入（<span class="built_in">sync</span>）或非同步（默认）（async）的内存机制</span><br><span class="line">	atime,noatime: 是否修订文件的读取时间（atime）。为了性能，某些时刻可使用 noatime</span><br><span class="line">    ro, rw:        挂载文件系统成为只读（ro）或可读写（rw）</span><br><span class="line">    auto, noauto:  允许此 filesystem 被以 mount -a 自动挂载（auto）</span><br><span class="line">    dev, nodev:    是否允许此 filesystem 上，可创建设备文件？ dev 为可允许</span><br><span class="line">    suid, nosuid:  是否允许此 filesystem 含有 suid/sgid 的文件格式？</span><br><span class="line">    <span class="built_in">exec</span>, noexec:  是否允许此 filesystem 上拥有可执行 binary 文件？</span><br><span class="line">    user, nouser:  是否允许此 filesystem 让任何使用者执行 mount ？一般来说，                     					 mount 仅有 root 可以进行，但下达 user 参数，则可让一般 user 也能够对此 						   partition 进行 mount 。</span><br><span class="line">    defaults:      默认值为：rw, suid, dev, <span class="built_in">exec</span>, auto, nouser, and async</span><br><span class="line">    remount:       重新挂载，这在系统出错，或重新更新参数时，很有用！</span><br></pre></td></tr></table></figure>

<p>CentOS 7 以后不需要加上 <code>-t</code> 这个选项，系统会自动的分析最恰当的文件系统来尝试挂载你需要的设备，这也是使用 <code>blkid</code> 就能够正确显示文件系统的原因！</p>
<blockquote>
<p>CentOS 是怎么找出文件系统类型的呢？</p>
<p>由于文件系统几乎都有 <code>superblock</code> ，Linux 可以通过分析 <code>superblock</code> 搭配 Linux 自己的驱动程序去测试挂载，如果成功，就使用该类型的文件系统挂载！</p>
</blockquote>
<blockquote>
<p>那么系统有没有指定哪些类型的<code>filesystem</code> 才需要进行上述的挂载测试呢？</p>
<p>主要是参考下面这两个文件</p>
<ul>
<li>&#x2F;etc&#x2F;filesystems：<strong>系统指定的测试挂载文件系统类型的优先顺序</strong></li>
<li>&#x2F;proc&#x2F;filesystems：<strong>Linux系统已经载入的文件系统类型</strong></li>
</ul>
</blockquote>
<blockquote>
<p>那我怎么知道我的 Linux 有没有相关文件系统类型的驱动程序呢？</p>
<p>Linux 支持的文件系统之驱动程序都写在如下的目录中</p>
<ul>
<li>&#x2F;lib&#x2F;modules&#x2F;$（uname -r）&#x2F;kernel&#x2F;fs&#x2F;</li>
</ul>
</blockquote>
<p>将某个目录挂载到其他目录，也可以使用 symbolic link 来链接，不过在某些不支持符号链接的程序运行中，还是得要通过这样的方法才行，<code>mount --bind /var /data/var</code></p>
<h4 id="卸载-umount"><a href="#卸载-umount" class="headerlink" title="卸载:umount"></a>卸载:umount</h4><p>将设备文件卸载，<code>umount 设备或挂载点</code></p>
<h3 id="磁盘-文件系统参数修订"><a href="#磁盘-文件系统参数修订" class="headerlink" title="磁盘&#x2F;文件系统参数修订"></a>磁盘&#x2F;文件系统参数修订</h3><p>有时你可能只是希望修改一下目前文件系统的一些<strong>相关信息</strong>（例如Label name ， journal 的参数），这个时候，就得需要下面这些相关的指令功能：</p>
<ul>
<li><p>mknod</p>
<p>在 Linux 下面所有的设备都以文件表示，通过文件的 major 与 minor 数值来表示，<code>mknod 设备文件名 [bcp] [Major] [Minor]</code></p>
</li>
<li><p>xfs_admin 修改 XFS 文件系统的 UUID 与 Label name</p>
<p>如果格式化的时候忘记加上标头名称，后来想要再次加入时，不需要重复格式化！直接使用这个 xfs_admin 即可。这个指令直接拿来处理 LABEL name 以及 UUID 即可</p>
</li>
<li></li>
</ul>
<p>九、文件与文件系统的压缩、打包与备份</p>
<p>十、Vim程序编辑器</p>
<p>十一、认识与学习BASH</p>
<p>十二、正则表达式与文件格式化处理</p>
<p>十三、学习Shell Scripts</p>
<p>十四、Linux账号管理与ACL权限设置</p>
<p>十五、磁盘配额（Quota）与进阶文件系统管理</p>
<p>十六、例行组工作调度（crontab）</p>
<p>十七、程序管理与SELinux初探</p>
<p>十八、认识系统服务（daemons）</p>
<p>十九、认识与分析登录文件</p>
<p>二十、开机流程、模块管理与Loader</p>
<p>二十一、基础系统设置与备份策略</p>
<p>二十二、软件安装：源代码与TarBall</p>
<p>二十三、软件安装：RPM、SRPM与YUM</p>
<p>二十四、X WINDOW设置介绍</p>
<p>二十五、Linux核心编译与管理</p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
