<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JAVA面试八股文基础篇 | DrJuly</title><meta name="author" content="DrJuly2333"><meta name="copyright" content="DrJuly2333"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[TOC]  基本数据和引用类型的区别在 Java 中，基本数据类型和引用类型是两种不同的类型系统，它们在存储方式、内存管理、操作行为等方面存在明显的差异。 1. 基本数据类型基本数据类型是 Java 中最简单的类型，它们直接存储值，不涉及对象和引用。Java 语言定义了 8 种基本数据类型：  整数类型：byte、short、int、long 浮点类型：float、double 字符类型：cha">
<meta property="og:type" content="article">
<meta property="og:title" content="JAVA面试八股文基础篇">
<meta property="og:url" content="http://example.com/2024/09/15/JAVA%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/index.html">
<meta property="og:site_name" content="DrJuly">
<meta property="og:description" content="[TOC]  基本数据和引用类型的区别在 Java 中，基本数据类型和引用类型是两种不同的类型系统，它们在存储方式、内存管理、操作行为等方面存在明显的差异。 1. 基本数据类型基本数据类型是 Java 中最简单的类型，它们直接存储值，不涉及对象和引用。Java 语言定义了 8 种基本数据类型：  整数类型：byte、short、int、long 浮点类型：float、double 字符类型：cha">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/avatar.png">
<meta property="article:published_time" content="2024-09-16T01:52:32.000Z">
<meta property="article:modified_time" content="2024-09-15T14:28:38.000Z">
<meta property="article:author" content="DrJuly2333">
<meta property="article:tag" content="JAVA">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/avatar.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/09/15/JAVA%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?95d98ba73784092d75263482b3e4ecc4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JAVA面试八股文基础篇',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-15 10:28:38'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="DrJuly"><span class="site-name">DrJuly</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JAVA面试八股文基础篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-09-16T01:52:32.000Z" title="Created 2024-09-15 21:52:32">2024-09-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-09-15T14:28:38.000Z" title="Updated 2024-09-15 10:28:38">2024-09-15</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">38.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>124mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JAVA面试八股文基础篇"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>[TOC] </p>
<h2 id="基本数据和引用类型的区别"><a href="#基本数据和引用类型的区别" class="headerlink" title="基本数据和引用类型的区别"></a>基本数据和引用类型的区别</h2><p>在 Java 中，基本数据类型和引用类型是两种不同的类型系统，它们在存储方式、内存管理、操作行为等方面存在明显的差异。</p>
<h3 id="1-基本数据类型"><a href="#1-基本数据类型" class="headerlink" title="1. 基本数据类型"></a>1. 基本数据类型</h3><p><strong>基本数据类型</strong>是 Java 中最简单的类型，它们直接存储值，不涉及对象和引用。Java 语言定义了 8 种基本数据类型：</p>
<ul>
<li><strong>整数类型</strong>：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li>
<li><strong>浮点类型</strong>：<code>float</code>、<code>double</code></li>
<li><strong>字符类型</strong>：<code>char</code></li>
<li><strong>布尔类型</strong>：<code>boolean</code></li>
</ul>
<h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ol>
<li><p><strong>存储位置</strong>：基本数据类型的变量存储在<strong>栈内存</strong>中，直接存储具体的值。</p>
</li>
<li><p><strong>存储方式</strong>：每个基本数据类型占用固定的内存空间，在声明时系统会自动分配空间，它们的值存储在分配给变量的内存空间中。</p>
</li>
<li><p><strong>传递方式</strong>：在方法调用或赋值时，基本数据类型的传递是<strong>值传递</strong>。即将变量的值拷贝一份传递给方法或赋值给另一个变量。原始变量的值不会受到修改的影响。</p>
</li>
<li><p><strong>默认值</strong>：基本数据类型在未赋值的情况下，会有默认值。</p>
</li>
<li><p><strong>不具有方法</strong>：基本数据类型没有与之相关的内置方法。</p>
</li>
</ol>
<h3 id="2-引用类型"><a href="#2-引用类型" class="headerlink" title="2. 引用类型"></a>2. 引用类型</h3><p><strong>引用类型</strong>是指那些存储对象地址的变量，而不是对象本身。它们包含类、数组、接口和枚举等类型。</p>
<h4 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h4><ol>
<li><strong>存储位置</strong>：引用类型的变量本身（存储对象的地址）存储在<strong>栈内存</strong>中，但对象的数据存储在<strong>堆内存</strong>中。例如：<code>Person person = new Person();</code>，<code>person</code> 变量存储在栈中，它保存的是对象在堆内存中的地址，而真正的 <code>Person</code> 对象在堆内存中存储。</li>
<li><strong>存储方式</strong>：引用类型变量存储的是一个指向堆内存中对象的引用（即地址）。多个引用类型变量可以指向同一个对象。<strong>声明时只是分配了引用空间，必须通过实例化开辟数据空间之后才可以赋值</strong>。</li>
<li><strong>传递方式</strong>：引用类型在方法调用或赋值时是<strong>值传递</strong>，即传递的是对象在堆内存中的地址。因此，改变方法中传递引用类型的值会影响原始对象。</li>
<li><strong>默认值</strong>：引用类型的默认值是 <code>null</code>，即默认情况下变量没有指向任何对象。</li>
<li><strong>具有方法</strong>：引用类型的对象可以调用与之相关的<strong>方法</strong>，引用类型也可以通过继承、实现接口等方式进行扩展。</li>
</ol>
<hr>
<h2 id="Java是值传递还是引用传递"><a href="#Java是值传递还是引用传递" class="headerlink" title="Java是值传递还是引用传递"></a>Java是值传递还是引用传递</h2><p>在 Java 中，<strong>所有方法参数的传递</strong>都是<strong>值传递</strong>。但是，这里的<code>值传递</code>可能会引起一些混淆，尤其是在处理引用类型时。</p>
<h3 id="1-基本数据类型的值传递"><a href="#1-基本数据类型的值传递" class="headerlink" title="1. 基本数据类型的值传递"></a>1. 基本数据类型的值传递</h3><p>对于<strong>基本数据类型</strong>，Java 直接传递变量的拷贝值，因此在方法中对参数的修改<strong>不会影响</strong>方法外部的原始变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        changeValue(a);<br>        System.out.println(a);  <span class="hljs-comment">// 输出 10，原始值没有变化</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">changeValue</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        value = <span class="hljs-number">20</span>;  <span class="hljs-comment">// value 是 a 的副本，这里只是修改了局部变量 value 的值，不影响外部的变量 a</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-引用类型的值传递"><a href="#2-引用类型的值传递" class="headerlink" title="2. 引用类型的值传递"></a>2. 引用类型的值传递</h3><p>对于<strong>引用类型</strong>，Java 仍然是<strong>值传递</strong>，但传递的<code>值</code>是<strong>对象引用地址的拷贝</strong>。因此，在方法内部改变引用指向的对象的属性，外部也会受影响。但如果在方法内部改变引用本身指向一个新的对象，外部引用不会受到影响。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;John&quot;</span>);<br>        changeName(person);<br>        System.out.println(person.getName());  <span class="hljs-comment">// 输出 &quot;Doe&quot;，因为改变了对象的属性</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">changeName</span><span class="hljs-params">(Person p)</span> &#123;<br>        p.setName(<span class="hljs-string">&quot;Doe&quot;</span>);  <span class="hljs-comment">// 修改了对象的属性，外部的 person 引用指向的对象也受影响</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-修改引用本身不会影响外部引用"><a href="#3-修改引用本身不会影响外部引用" class="headerlink" title="3. 修改引用本身不会影响外部引用"></a>3. 修改引用本身不会影响外部引用</h3><p>如果你尝试在方法中改变引用本身的指向，这不会影响外部的引用变量。因为传递给方法的仍然是引用的副本，而不是原始引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;John&quot;</span>);<br>        changeReference(person);<br>        System.out.println(person.getName());  <span class="hljs-comment">// 输出 &quot;John&quot;，引用本身没有改变</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">changeReference</span><span class="hljs-params">(Person p)</span> &#123;<br>        p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Doe&quot;</span>);  <span class="hljs-comment">// 这里只是让 p 引用指向一个新的对象，不影响外部的 person</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，<code>p</code> 被重新指向了一个新的 <code>Person</code> 对象，但 <code>person</code> 仍然指向原来的 <code>Person</code> 对象，因此外部的 <code>person</code> 没有变化。</p>
<blockquote>
<p> 因此，Java 仅支持<strong>值传递</strong>，无论是基本数据类型还是引用类型。</p>
</blockquote>
<hr>
<h2 id="为什么String要设计成不可变的"><a href="#为什么String要设计成不可变的" class="headerlink" title="为什么String要设计成不可变的"></a>为什么String要设计成不可变的</h2><p>在 Java 中，<code>String</code> 被设计为<strong>不可变（immutable）</strong>的，即<strong>只读字符串</strong>。这意味着一旦创建了一个 <code>String</code> 对象，它的值就不能再被改变。这种设计有几个关键的原因，涉及到安全性、性能优化、线程安全性等方面。</p>
<h3 id="1-String-的不可变性设计"><a href="#1-String-的不可变性设计" class="headerlink" title="1. String 的不可变性设计"></a>1. <code>String</code> 的不可变性设计</h3><p><code>String</code> 类在 Java 中被声明为 <code>final</code>，这意味着无法继承 <code>String</code> 类。同时，<code>String</code> 内部使用一个 <code>final</code> 的字符数组来存储字符串内容。由于 <code>final</code> 关键字的存在，字符数组的引用无法被修改，并且通过该引用也无法更改字符串内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span>[] value;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>char[] value</code> 是存储字符串内容的核心，<code>final</code> 修饰符确保了该数组的引用不能被改变。</li>
</ul>
<h3 id="2-为什么-String-是不可变的？"><a href="#2-为什么-String-是不可变的？" class="headerlink" title="2. 为什么 String 是不可变的？"></a>2. 为什么 <code>String</code> 是不可变的？</h3><h4 id="1-安全性："><a href="#1-安全性：" class="headerlink" title="1. 安全性："></a>1. <strong>安全性</strong>：</h4><ul>
<li><strong>避免潜在的安全问题</strong>：如果 <code>String</code> 是可变的，在涉及到敏感信息（如密码、URL、网络连接等）的场景中，如果字符串在多处被修改或引用，可能会引发安全漏洞。不可变的 <code>String</code> 确保一旦创建，其内容无法被更改，使其更加安全。</li>
</ul>
<h4 id="2-线程安全："><a href="#2-线程安全：" class="headerlink" title="2. 线程安全："></a>2. <strong>线程安全</strong>：</h4><ul>
<li><strong>线程安全</strong>：不可变对象本质上是线程安全的，多个线程可以同时共享一个 <code>String</code> 对象，而不需要担心数据不一致的问题，因为字符串的内容永远不会被改变。由于 <code>String</code> 是不可变的，它天然是线程安全的，不需要额外的同步机制。</li>
</ul>
<h4 id="3-性能优化："><a href="#3-性能优化：" class="headerlink" title="3. 性能优化："></a>3. <strong>性能优化</strong>：</h4><ul>
<li><p><strong>字符串池机制（String Pool）</strong>：Java 中有一个特殊的优化称为<strong>字符串常量池</strong>（String Pool）。当你创建一个字符串字面量时，Java 会首先检查常量池中是否已经存在相同内容的字符串。如果存在，则直接返回这个字符串的引用，而不是重新创建一个新的对象。这种机制极大地节省了内存和 CPU 资源。</p>
<blockquote>
<p> 如果 <code>String</code> 是可变的，字符串常量池将无法实现，因为对共享字符串的修改会影响到所有引用这个字符串的代码。</p>
</blockquote>
</li>
</ul>
<h4 id="4-哈希值缓存："><a href="#4-哈希值缓存：" class="headerlink" title="4. 哈希值缓存："></a>4. <strong>哈希值缓存</strong>：</h4><ul>
<li><p><strong>哈希值缓存</strong>：<code>String</code> 的 <code>hashCode()</code> 方法经常被调用，尤其是在 <code>HashMap</code> 等基于哈希的集合中。如果 <code>String</code> 是可变的，每次修改字符串内容后都需要重新计算哈希值，性能会受到影响。而由于 <code>String</code> 不可变，其哈希值可以在第一次计算后被缓存（<code>hash</code> 字段），从而提升了性能。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> hash;<br>    <span class="hljs-keyword">if</span> (h == <span class="hljs-number">0</span> &amp;&amp; value.length &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">char</span> val[] = value;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; value.length; i++) &#123;<br>            h = <span class="hljs-number">31</span> * h + val[i];<br>        &#125;<br>        hash = h;<br>    &#125;<br>    <span class="hljs-keyword">return</span> h;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>在 <code>String</code> 中，<code>hashCode</code> 只需要在首次计算时完成，之后会直接使用缓存的值。</p>
</blockquote>
</li>
</ul>
<h4 id="5-设计简单性："><a href="#5-设计简单性：" class="headerlink" title="5. 设计简单性："></a>5. <strong>设计简单性</strong>：</h4><ul>
<li><strong>易于理解与使用</strong>：不可变对象在逻辑上更容易理解，不可变的设计减少了潜在的 bug。开发者不需要担心某个代码段在无意中修改了 <code>String</code>，从而导致难以跟踪的错误。</li>
</ul>
<h3 id="3-字符串的修改如何实现？"><a href="#3-字符串的修改如何实现？" class="headerlink" title="3. 字符串的修改如何实现？"></a>3. 字符串的修改如何实现？</h3><p>虽然 <code>String</code> 是不可变的，但 Java 提供了两种可变的字符串类：<code>StringBuilder</code> 和 <code>StringBuffer</code>。如果你需要频繁修改字符串内容，可以使用这两者。</p>
<ul>
<li><code>StringBuilder</code>：适用于单线程环境下的字符串拼接、修改，效率较高。</li>
<li><code>StringBuffer</code>：适用于多线程环境，它是线程安全的，但相对 <code>StringBuilder</code> 来说性能略低，因为其使用了同步机制。</li>
</ul>
<p>这两者通过<strong>动态扩展字符数组</strong>来实现可变字符串，避免了频繁创建新的 <code>String</code> 对象。</p>
<hr>
<h2 id="String的-拼接操作底层实现"><a href="#String的-拼接操作底层实现" class="headerlink" title="String的 + 拼接操作底层实现"></a>String的 + 拼接操作底层实现</h2><p>在 Java 中，<code>String</code> 的 <code>+</code> 操作符用于拼接字符串。但底层实现并不是直接对 <code>String</code> 对象进行修改。由于 <code>String</code> 是不可变的，每次使用 <code>+</code> 进行拼接时，实际上是在创建一个新的 <code>String</code> 对象。具体的底层实现可以分为以下几种情况：</p>
<h3 id="1-编译器优化（常量折叠）"><a href="#1-编译器优化（常量折叠）" class="headerlink" title="1. 编译器优化（常量折叠）"></a>1. 编译器优化（常量折叠）</h3><p>当两个或多个字符串常量（字面量）通过 <code>+</code> 拼接时，Java 编译器会在<strong>编译阶段</strong>对它们进行优化，即直接将它们拼接成一个新的常量字符串，而不会等到运行时进行处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span> + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-string">&quot;World!&quot;</span>;<br></code></pre></td></tr></table></figure>

<p>在编译时，这段代码会被优化为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello World!&quot;</span>;<br></code></pre></td></tr></table></figure>

<h3 id="2-使用-StringBuilder（运行时拼接）"><a href="#2-使用-StringBuilder（运行时拼接）" class="headerlink" title="2. 使用 StringBuilder（运行时拼接）"></a>2. 使用 <code>StringBuilder</code>（运行时拼接）</h3><p>当 <code>+</code> 操作符用于拼接<strong>变量</strong>时，Java 会在编译时将这些操作转换为使用 <code>StringBuilder</code> 进行拼接，从而提高性能，避免频繁创建 <code>String</code> 对象。</p>
<h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;World&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> str1 + <span class="hljs-string">&quot; &quot;</span> + str2;<br></code></pre></td></tr></table></figure>

<h4 id="编译后的字节码等效于："><a href="#编译后的字节码等效于：" class="headerlink" title="编译后的字节码等效于："></a>编译后的字节码等效于：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>sb.append(str1);<br>sb.append(<span class="hljs-string">&quot; &quot;</span>);<br>sb.append(str2);<br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> sb.toString();<br></code></pre></td></tr></table></figure>

<p>在这个过程中：</p>
<ol>
<li>创建一个 <code>StringBuilder</code> 对象。</li>
<li>调用 <code>StringBuilder.append()</code> 方法依次拼接各个字符串。</li>
<li>使用 <code>StringBuilder.toString()</code> 方法生成最终的 <code>String</code> 对象。</li>
</ol>
<p>这种机制避免了频繁创建临时的 <code>String</code> 对象，因为 <code>StringBuilder</code> 是可变的，可以动态地修改内容，从而减少内存开销和提升性能。</p>
<h3 id="3-StringBuilder-vs-StringBuffer"><a href="#3-StringBuilder-vs-StringBuffer" class="headerlink" title="3. StringBuilder vs StringBuffer"></a>3. <code>StringBuilder</code> vs <code>StringBuffer</code></h3><p><code>+</code> 操作默认使用的是 <code>StringBuilder</code>，它是<strong>非线程安全</strong>的，因此效率相对更高。如果在多线程环境下使用字符串拼接，需要手动使用<strong>线程安全</strong>的 <code>StringBuffer</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>sb.append(str1);<br>sb.append(<span class="hljs-string">&quot; &quot;</span>);<br>sb.append(str2);<br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> sb.toString();<br></code></pre></td></tr></table></figure>

<h3 id="4-多次使用-拼接的性能问题"><a href="#4-多次使用-拼接的性能问题" class="headerlink" title="4. 多次使用 + 拼接的性能问题"></a>4. 多次使用 <code>+</code> 拼接的性能问题</h3><p>由于 <code>String</code> 是不可变的，每次使用 <code>+</code> 拼接字符串时都会创建一个新的 <code>String</code> 对象。如果在循环中频繁使用 <code>+</code> 进行拼接，可能会导致性能问题。</p>
<hr>
<h2 id="ArrayList动态扩容过程"><a href="#ArrayList动态扩容过程" class="headerlink" title="ArrayList动态扩容过程"></a>ArrayList动态扩容过程</h2><p><code>ArrayList</code> 是 Java 中常用的动态数组实现，它的大小是可以动态扩容的。<code>ArrayList</code> 扩容的过程是在元素数量超过当前数组容量时自动进行的。扩容的机制确保了 <code>ArrayList</code> 的动态性，但也涉及到性能问题（例如数组拷贝）。下面是 <code>ArrayList</code> 动态扩容的具体过程。</p>
<h3 id="1-ArrayList-底层结构"><a href="#1-ArrayList-底层结构" class="headerlink" title="1. ArrayList 底层结构"></a><strong>1. ArrayList 底层结构</strong></h3><p><code>ArrayList</code> 的底层是一个 <strong>Object[] 数组</strong>，初始容量可以通过构造函数设置。如果没有指定初始容量，则默认容量为 <strong>10</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-keyword">transient</span> Object[] elementData; <span class="hljs-comment">// 存储元素的数组</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size; <span class="hljs-comment">// 当前 ArrayList 中的元素数量</span><br></code></pre></td></tr></table></figure>

<h3 id="2-添加元素和动态扩容"><a href="#2-添加元素和动态扩容" class="headerlink" title="2. 添加元素和动态扩容"></a><strong>2. 添加元素和动态扩容</strong></h3><p>当你向 <code>ArrayList</code> 添加元素时，<code>ArrayList</code> 会检查当前数组容量是否足够存储新元素。如果数组已满，就会触发 <strong>动态扩容</strong>。动态扩容的关键方法是 <code>ensureCapacityInternal()</code>，它确保 <code>ArrayList</code> 有足够的空间来添加新元素。</p>
<h4 id="add-方法的简化版："><a href="#add-方法的简化版：" class="headerlink" title="add() 方法的简化版："></a><strong>add() 方法的简化版：</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>); <span class="hljs-comment">// 确保容量足够</span><br>    elementData[size++] = e; <span class="hljs-comment">// 将新元素添加到数组中</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>ensureCapacityInternal(size + 1)</code>：这个方法用于检查 <code>ArrayList</code> 是否有足够的空间。如果容量不足，调用扩容机制。</li>
</ul>
<h4 id="ensureCapacityInternal-方法："><a href="#ensureCapacityInternal-方法：" class="headerlink" title="ensureCapacityInternal() 方法："></a><strong>ensureCapacityInternal() 方法：</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);<br>    &#125;<br>    ensureExplicitCapacity(minCapacity);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>minCapacity</code> 是 <code>ArrayList</code> 需要的最小容量。</li>
<li>如果 <code>ArrayList</code> 的底层数组为空（刚初始化），则需要设置为默认容量 <code>DEFAULT_CAPACITY</code>，或者保证最小需要的容量。</li>
</ul>
<h4 id="ensureExplicitCapacity-方法："><a href="#ensureExplicitCapacity-方法：" class="headerlink" title="ensureExplicitCapacity() 方法："></a><strong>ensureExplicitCapacity() 方法：</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    modCount++;<br>    <span class="hljs-comment">// 如果需要的容量大于当前数组的容量，则扩容</span><br>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>        grow(minCapacity);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>modCount++</code> 是用来记录结构修改的次数，用于迭代器的快速失败机制。</li>
<li>如果 <code>minCapacity</code> 大于当前数组的长度（即当前容量不够），就会调用 <code>grow()</code> 方法进行扩容。</li>
</ul>
<h3 id="3-动态扩容的核心方法：grow"><a href="#3-动态扩容的核心方法：grow" class="headerlink" title="3. 动态扩容的核心方法：grow()"></a><strong>3. 动态扩容的核心方法：grow()</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-comment">// 当前数组的容量</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>    <span class="hljs-comment">// 新容量为旧容量的 1.5 倍</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 如果新容量仍然小于需要的最小容量，则将新容量设为最小容量</span><br>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>        newCapacity = minCapacity;<br>    <span class="hljs-comment">// 如果新容量超过了允许的最大值，则设置为最大值</span><br>    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>        newCapacity = hugeCapacity(minCapacity);<br>    <span class="hljs-comment">// 将原数组内容复制到新数组中</span><br>    elementData = Arrays.copyOf(elementData, newCapacity);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="hugeCapacity-方法："><a href="#hugeCapacity-方法：" class="headerlink" title="hugeCapacity() 方法："></a><strong>hugeCapacity() 方法</strong>：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hugeCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 溢出</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutOfMemoryError</span>();<br>    <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>当需要的最小容量超过 <code>MAX_ARRAY_SIZE</code> 时，<code>hugeCapacity()</code> 负责处理分配超大数组的情况。如果超过最大值，将分配 <code>Integer.MAX_VALUE</code>。</li>
</ul>
<h4 id="核心逻辑："><a href="#核心逻辑：" class="headerlink" title="核心逻辑："></a><strong>核心逻辑：</strong></h4><ol>
<li><p><strong>扩容策略</strong>：</p>
<ul>
<li>新容量 &#x3D; 旧容量 + 旧容量的一半（即 <code>oldCapacity * 1.5</code>）。</li>
<li>这个策略避免了频繁扩容的性能开销，并且使 <code>ArrayList</code> 有更好的空间使用效率。</li>
</ul>
</li>
<li><p><strong>容量不足时强制扩容</strong>：</p>
<ul>
<li>如果扩容后的新容量仍然小于所需的最小容量，则直接将新容量设为最小容量。</li>
</ul>
</li>
<li><p><strong>超大容量的处理</strong>：</p>
<ul>
<li>当 <code>ArrayList</code> 的容量超过了 <code>MAX_ARRAY_SIZE</code>（约 <code>Integer.MAX_VALUE - 8</code>），则调用 <code>hugeCapacity()</code>，确保 <code>ArrayList</code> 不会分配超过 JVM 最大的数组长度。</li>
</ul>
</li>
<li><p><strong>数组复制</strong>：</p>
<ul>
<li><code>Arrays.copyOf()</code> 方法用来创建新数组并将旧数组中的元素拷贝到新数组中。数组拷贝的性能开销是 <code>ArrayList</code> 扩容的主要性能代价之一。</li>
</ul>
</li>
</ol>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a><strong>4. 总结</strong></h3><p><code>ArrayList</code> 的动态扩容过程是通过 <strong>1.5 倍</strong>的扩容策略来实现的。每次扩容时，旧数组中的元素会被拷贝到一个更大的新数组中。具体流程如下：</p>
<ol>
<li><strong>检查是否需要扩容</strong>：在添加新元素时，<code>ArrayList</code> 检查当前容量是否足够。</li>
<li><strong>扩容策略</strong>：如果容量不足，新容量设为旧容量的 1.5 倍（也可能是更大的值，取决于所需的最小容量）。</li>
<li><strong>数组拷贝</strong>：创建新的更大数组，并将旧数组中的内容拷贝到新数组中。</li>
</ol>
<p><strong>注意</strong>：动态扩容虽然保证了 <code>ArrayList</code> 的灵活性，但每次扩容都涉及数组的拷贝操作，因此频繁的扩容会影响性能。为了解决这个问题，在预估元素数量时，建议通过构造函数提前设置 <code>ArrayList</code> 的初始容量。</p>
<hr>
<h2 id="HashMap的底层原理"><a href="#HashMap的底层原理" class="headerlink" title="HashMap的底层原理"></a>HashMap的底层原理</h2><p><code>HashMap</code> 是 Java 中最常用的集合之一，它基于哈希表（Hash Table）实现，提供了键值对的存储方式。</p>
<h3 id="1-底层数据结构"><a href="#1-底层数据结构" class="headerlink" title="1. 底层数据结构"></a>1. 底层数据结构</h3><p><code>HashMap</code>的底层结构是<strong>数组 + 链表 + 红黑树</strong>的组合。它主要包含以下几个部分：</p>
<ul>
<li><strong>数组</strong>：用于存储 <code>HashMap</code> 的数据。数组的每个元素称为<code>桶</code>（bucket），一个桶可以存储多个键值对。</li>
<li><strong>链表</strong>：当多个键的哈希值相同，发生<strong>哈希冲突</strong>时，这些键值对会被存储在同一个桶内，以链表的形式链接起来。</li>
<li><strong>红黑树</strong>：当链表长度超过一定阈值时（默认阈值为 8），链表会被转换为红黑树，以提高查找效率。</li>
</ul>
<h3 id="2-HashMap-的核心字段"><a href="#2-HashMap-的核心字段" class="headerlink" title="2. HashMap 的核心字段"></a>2. <code>HashMap</code> 的核心字段</h3><p>在 <code>HashMap</code> 中，有几个核心的字段与底层实现密切相关：</p>
<ul>
<li><code>Node&lt;K, V&gt;[] table</code>：哈希桶数组，存储键值对。<code>Node</code> 是 <code>HashMap</code> 的内部类，表示每个键值对。</li>
<li><code>loadFactor</code>：负载因子，决定了 <code>HashMap</code> 的扩容阈值。默认值为 <code>0.75</code>。</li>
<li><code>threshold</code>：扩容阈值，当哈希表中的元素数量超过 <code>threshold</code> 时，<code>HashMap</code> 会自动扩容。</li>
<li><code>size</code>：当前 <code>HashMap</code> 中存储的键值对数量。</li>
</ul>
<h3 id="3-Node-节点结构"><a href="#3-Node-节点结构" class="headerlink" title="3. Node 节点结构"></a>3. <code>Node</code> 节点结构</h3><p><code>HashMap</code> 的每个键值对由 <code>Node</code> 对象来表示。<code>Node</code> 类的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;    <span class="hljs-comment">// 哈希值，用于快速定位键值对的位置</span><br>    <span class="hljs-keyword">final</span> K key;       <span class="hljs-comment">// 键</span><br>    V value;           <span class="hljs-comment">// 值</span><br>    Node&lt;K,V&gt; next;    <span class="hljs-comment">// 链表的下一个节点（用于解决哈希冲突）</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>hash</code>：通过键的 <code>hashCode()</code> 方法计算得出，用于将键值对分布到哈希表中的不同位置。</li>
<li><code>key</code>：存储的键。</li>
<li><code>value</code>：存储的值。</li>
<li><code>next</code>：指向下一个节点，形成链表结构，用于处理哈希冲突。</li>
</ul>
<h3 id="4-HashMap-的工作流程"><a href="#4-HashMap-的工作流程" class="headerlink" title="4. HashMap 的工作流程"></a>4. <code>HashMap</code> 的工作流程</h3><h4 id="1-插入数据-put"><a href="#1-插入数据-put" class="headerlink" title="1. 插入数据 (put)"></a>1. <strong>插入数据 (<code>put</code>)</strong></h4><p>当你向 <code>HashMap</code> 中插入一个键值对时，<code>HashMap</code> 会通过以下步骤进行处理：</p>
<ol>
<li><p><strong>计算哈希值</strong>：首先，使用键的 <code>hashCode()</code> 方法计算键的哈希值，并对哈希值进行处理（如扰动函数）以尽量保证哈希值分布的均匀性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个操作通过位移和异或运算使得哈希值更加均匀分布。</p>
</li>
<li><p><strong>定位数组索引</strong>：使用哈希值对数组长度取模（<code>index = hash % table.length</code>）来确定应该将键值对放在哪个桶（bucket）中。</p>
</li>
<li><p><strong>检查哈希冲突</strong>：在确定的桶中，检查是否已经存在相同哈希值的节点：</p>
<ul>
<li>如果桶中没有节点，直接插入新的键值对。</li>
</ul>
</li>
</ol>
<ul>
<li>如果桶中有节点（即发生哈希冲突），则遍历链表或红黑树，检查是否存在相同的键。如果找到相同的键，则更新值；如果没有相同的键，则将新节点插入链表或树中。</li>
</ul>
<ol start="4">
<li><p><strong>链表转红黑树</strong>：如果链表长度超过 8，<code>HashMap</code> 会将链表转换为红黑树，以提高查找和插入效率。</p>
<blockquote>
<p> 如果链表长度低于 6（删除操作），红黑树会重新转为链表，以节省内存。</p>
</blockquote>
</li>
</ol>
<h4 id="2-查找数据-get"><a href="#2-查找数据-get" class="headerlink" title="2. 查找数据 (get)"></a>2. <strong>查找数据 (<code>get</code>)</strong></h4><p>当你使用 <code>get()</code> 方法查找键对应的值时，<code>HashMap</code> 会通过以下步骤进行：</p>
<ol>
<li><p><strong>计算哈希值</strong>：和插入时一样，使用键的 <code>hashCode()</code> 方法计算哈希值，并扰动哈希值。</p>
</li>
<li><p><strong>定位数组索引</strong>：通过哈希值对数组长度取模，找到对应的桶。</p>
</li>
<li><p><strong>遍历链表或树</strong>：在桶中查找匹配的键：</p>
<ul>
<li>如果桶是链表，遍历链表中的节点，比较键的 <code>hash</code> 和 <code>equals()</code>。</li>
<li>如果桶是红黑树，在树中查找对应的键。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：如果找到匹配的键，返回对应的值；否则返回 <code>null</code>。</p>
</li>
</ol>
<h4 id="3-扩容机制"><a href="#3-扩容机制" class="headerlink" title="3. 扩容机制"></a>3. <strong>扩容机制</strong></h4><p>当 <code>HashMap</code> 中的元素数量超过扩容阈值（即 <code>size &gt; threshold</code>，通常为 <code>capacity * loadFactor</code>），<code>HashMap</code> 会进行<strong>扩容</strong>。扩容的步骤包括：</p>
<ol>
<li><p><strong>扩大数组</strong>：将当前数组容量扩大为原来的 2 倍。</p>
</li>
<li><p><strong>重新哈希</strong>：将所有已有的键值对重新哈希并分配到新的数组位置。这是因为数组的大小变了，原先计算的哈希值索引也可能会发生变化。</p>
</li>
</ol>
<p>扩容的目的是为了减少哈希冲突，确保 <code>HashMap</code> 的性能保持在较高的水平。</p>
<h3 id="5-HashMap-的哈希冲突解决"><a href="#5-HashMap-的哈希冲突解决" class="headerlink" title="5. HashMap 的哈希冲突解决"></a>5. <code>HashMap</code> 的哈希冲突解决</h3><p>哈希冲突是指两个不同的键通过哈希函数计算得到了相同的哈希值。在 <code>HashMap</code> 中，哈希冲突通过以下两种方式解决：</p>
<ul>
<li><strong>链表法</strong>：最初，多个具有相同哈希值的节点被存储在同一个桶中，形成一个链表。</li>
<li><strong>红黑树法</strong>：当链表长度超过一定阈值（默认是 8），链表会被转换为红黑树，以提高查找效率。</li>
</ul>
<h3 id="6-线程安全性"><a href="#6-线程安全性" class="headerlink" title="6. 线程安全性"></a>6. 线程安全性</h3><p><code>HashMap</code> 不是线程安全的。如果多个线程同时访问 <code>HashMap</code>，并且其中至少有一个线程在对它进行结构性修改，可能会导致数据不一致或死循环。因此，在多线程环境下建议使用 <code>ConcurrentHashMap</code> 或其他线程安全的集合类。</p>
<hr>
<h2 id="HashMap-的长度为什么是-2-的-N-次方"><a href="#HashMap-的长度为什么是-2-的-N-次方" class="headerlink" title="HashMap 的长度为什么是 2 的 N 次方"></a>HashMap 的长度为什么是 2 的 N 次方</h2><p>为了提高哈希表的性能，尤其是在 <strong>哈希冲突</strong>的处理和哈希码计算方面</p>
<ul>
<li><p>提高哈希分布均匀性</p>
<p><code>HashMap</code> 的底层数据结构是一个数组，哈希表中的每个键值对都通过 <strong>哈希函数</strong>计算键的哈希值，将其映射到数组的某个索引位置。计算数组索引时，<code>HashMap</code> 采用以下公式：<code>index = (hashCode &amp; (n - 1))</code>其中，<code>n</code> 是数组的长度，<code>hashCode</code> 是键对象的哈希值。</p>
<p>当 <code>n</code> 是 2 的幂次时，<code>n-1</code> 的二进制表示形式是全 1 的数，比如当 <code>n = 16</code> 时，<code>n-1 = 15</code>，即二进制为 <code>1111</code>。这意味着对 <code>n-1</code> 进行按位与操作时，<strong>只保留哈希值的低位部分</strong>，从而更均匀地将哈希值映射到数组的有效索引范围内。这样的计算方式简单且高效，同时保证了哈希值能够均匀地分布在数组中，减少了哈希冲突。</p>
</li>
<li><p>位运算提高性能</p>
<p><code>HashMap</code> 通过 <code>(hashCode &amp; (n - 1))</code> 来计算数组的索引。与其他模运算（如 <code>%</code>）相比，<strong>按位与运算</strong>要更加高效。因为模运算涉及到除法，而除法操作相对较慢，而按位与运算仅需一次简单的位操作，非常高效。</p>
<p>通过将数组长度设置为 2 的 N 次方，<code>HashMap</code> 可以避免使用模运算，而是使用位运算来计算索引，显著提高了性能。</p>
</li>
<li><p>减少哈希冲突</p>
<p>哈希冲突是指两个不同的键通过哈希函数计算后映射到同一个数组索引。哈希冲突会导致多个键值对存储在同一个桶中（链表或红黑树），从而降低查找效率。</p>
<p>如果数组的大小不是 2 的 N 次方，哈希值在映射时可能只考虑哈希值的高位，导致低位未被利用，最终无法均匀分布在数组中，增加了哈希冲突的概率。而当数组的大小是 2 的 N 次方时，<code>HashMap</code> 可以通过位与运算均匀地分配哈希值，充分利用哈希码的每一位，减少哈希冲突</p>
</li>
<li><p>扩容时的高效再散列</p>
<p><code>HashMap</code> 在插入数据时，当元素数量超过一定阈值时，会进行扩容操作。<code>HashMap</code> 的扩容倍数通常是 <strong>当前容量的两倍</strong>，也就是将数组的大小扩展到下一个 2 的 N 次方。扩容后，需要对现有的键值对进行重新计算哈希码和重新分配索引。</p>
<p>由于新数组的大小也是 2 的 N 次方，<code>HashMap</code> 只需要通过检查原有哈希值的高位来判断键值对是否需要重新分配到新的位置。具体来说，只需要判断 <code>(hash &amp; oldCapacity)</code> 是 0 还是 1，即可确定元素是保留在原位置还是移动到新位置。</p>
</li>
</ul>
<hr>
<h2 id="HashMap-中的-key-可以使用任何类作为-key-吗"><a href="#HashMap-中的-key-可以使用任何类作为-key-吗" class="headerlink" title="HashMap 中的 key 可以使用任何类作为 key 吗"></a>HashMap 中的 key 可以使用任何类作为 key 吗</h2><p>在 Java 中，你可以使用任何类的对象作为 <code>HashMap</code> 的键（<code>key</code>），但为了确保 <code>HashMap</code> 能够正常工作，<strong>key 的类</strong>必须满足以下几个条件：</p>
<h3 id="1-必须重写-equals-方法"><a href="#1-必须重写-equals-方法" class="headerlink" title="1. 必须重写 equals() 方法"></a><strong>1. 必须重写 <code>equals()</code> 方法</strong></h3><p><code>HashMap</code> 依赖 <code>key</code> 的 <code>equals()</code> 方法来判断两个键是否相等。<strong>键相等时才能确定对应的值</strong>。如果类没有正确重写 <code>equals()</code> 方法，那么即使两个对象的内容相同，<code>HashMap</code> 也可能会认为它们不相等，从而导致相同键被重复插入。</p>
<ul>
<li><code>equals()</code> 方法定义了对象的“相等”规则，<code>HashMap</code> 用它来检查两个键是否相同。</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">MyClass</span> <span class="hljs-variable">myClass</span> <span class="hljs-operator">=</span> (MyClass) o;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.id == myClass.id;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-必须重写-hashCode-方法"><a href="#2-必须重写-hashCode-方法" class="headerlink" title="2. 必须重写 hashCode() 方法"></a><strong>2. 必须重写 <code>hashCode()</code> 方法</strong></h3><p><code>HashMap</code> 通过键的 <code>hashCode()</code> 值来定位存储位置，所以 <code>key</code> 类必须正确实现 <code>hashCode()</code> 方法。如果 <code>equals()</code> 和 <code>hashCode()</code> 的逻辑不一致，可能会导致相同的键被存储在 <code>HashMap</code> 中的不同位置，造成数据不一致。</p>
<ul>
<li><code>hashCode()</code> 方法定义了对象的“散列值”，<code>HashMap</code> 用它来决定键在散列表中的存储位置。</li>
</ul>
<p>一般来说，<strong>如果两个对象是相等的（<code>equals()</code> 返回 <code>true</code>），它们的 <code>hashCode()</code> 也必须相同</strong>。因此，当重写 <code>equals()</code> 时，也需要重写 <code>hashCode()</code> 方法。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> Objects.hash(id);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-不可变性"><a href="#3-不可变性" class="headerlink" title="3. 不可变性"></a><strong>3. 不可变性</strong></h3><p>键一旦被放入 <code>HashMap</code> 后，其值应该保持<strong>不可变</strong>。因为如果键的内容改变了，<code>hashCode()</code> 和 <code>equals()</code> 可能会发生变化，导致 <code>HashMap</code> 无法再正确找到该键对应的值，可能会出现<strong>找不到对应值</strong>或者<strong>散列冲突</strong>的情况。</p>
<ul>
<li><strong>不可变对象</strong>是作为 <code>HashMap</code> 键的最佳选择。典型的不可变类有 <code>String</code>、<code>Integer</code>、<code>Long</code> 等，它们的状态一旦创建，就不能改变。使用这些类作为键是最安全的。</li>
</ul>
<hr>
<h3 id="常见用于-HashMap-的类"><a href="#常见用于-HashMap-的类" class="headerlink" title="常见用于 HashMap 的类"></a><strong>常见用于 HashMap 的类</strong></h3><ul>
<li><code>String</code>：常见的不可变类，广泛用作 <code>HashMap</code> 的键，因为其不可变性使其适合作为键。</li>
<li><strong><code>Integer</code>、<code>Long</code>、<code>Double</code> 等包装类</strong>：这些类也是不可变的，适合用作键。</li>
<li><strong>自定义类</strong>：可以使用自定义类作为键，但确保正确重写了 <code>equals()</code> 和 <code>hashCode()</code> 方法。</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>你可以使用任何类作为 <code>HashMap</code> 的键，但为了确保 <code>HashMap</code> 正常工作，建议：</p>
<ol>
<li>正确重写 <code>equals()</code> 和 <code>hashCode()</code> 方法。</li>
<li>使用不可变对象作为键。</li>
<li>在多线程环境中考虑使用 <code>ConcurrentHashMap</code> 来替代 <code>HashMap</code>。</li>
</ol>
<hr>
<h2 id="HashMap和ConcurrentHashMap的区别"><a href="#HashMap和ConcurrentHashMap的区别" class="headerlink" title="HashMap和ConcurrentHashMap的区别"></a>HashMap和ConcurrentHashMap的区别</h2><p><code>HashMap</code> 和 <code>ConcurrentHashMap</code> 都是 Java 中常用的集合类，主要用于存储键值对，但它们在数据结构和底层实现上存在较大的差异，尤其是在并发场景下的处理方式。</p>
<h3 id="1-HashMap-数据结构与底层原理"><a href="#1-HashMap-数据结构与底层原理" class="headerlink" title="1. HashMap 数据结构与底层原理"></a>1. <code>HashMap</code> 数据结构与底层原理</h3><h4 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a><strong>数据结构</strong>：</h4><ul>
<li><code>HashMap</code> 的底层是<strong>数组 + 链表 + 红黑树</strong>。<ul>
<li>当哈希冲突较少时，键值对存储在一个数组中，每个数组的元素是一个链表的头节点。</li>
<li>当链表长度超过一定阈值（8）时，链表会转换为红黑树，以提高查找效率。</li>
</ul>
</li>
</ul>
<h4 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a><strong>工作原理</strong>：</h4><ol>
<li><p><strong>存储过程</strong>：</p>
<ul>
<li><code>HashMap</code> 使用键的 <code>hashCode()</code> 生成哈希值，然后通过哈希值对数组长度取模（<code>index = (n-1) &amp; hash</code>）确定元素的存储位置。</li>
<li>如果位置没有冲突，直接存储。如果发生冲突，会将冲突的键值对以链表的形式存储在同一数组元素中。</li>
</ul>
</li>
</ol>
<ul>
<li>如果链表过长（大于8），链表会转化为红黑树，减少查找时间从 O(n) 变为 O(log n)。</li>
</ul>
<ol start="2">
<li><strong>扩容</strong>：</li>
</ol>
<ul>
<li><code>HashMap</code> 默认容量是16，当哈希表的元素数量超过容量乘以负载因子（默认0.75）时，会触发扩容（2倍数组大小）。在扩容时，所有元素需要重新计算存储位置并移动到新的数组中。</li>
</ul>
<ol start="3">
<li><p><strong>线程安全性</strong>：</p>
<ul>
<li><p><code>HashMap</code> 不是线程安全的。如果多个线程同时修改 <code>HashMap</code> 的内容，可能会导致数据不一致，例如 <strong>死链问题</strong></p>
<blockquote>
<p> JDK 7 中 <code>HashMap</code> 的头插法在多线程扩容时会导致链表反转，再加上没有同步机制保护，容易造成链表指针混乱，形成环形链表，最终导致死循环。JDK 8 通过采用尾插法和引入红黑树解决了这些问题，使 <code>HashMap</code> 的线程安全性和性能得到了显著提升。</p>
</blockquote>
<blockquote>
<h4 id="JDK7-扩容过程死循环的形成过程"><a href="#JDK7-扩容过程死循环的形成过程" class="headerlink" title="JDK7 扩容过程死循环的形成过程"></a>JDK7 扩容过程死循环的形成过程</h4><ol>
<li><p><strong>链表反转（头插法）</strong>：由于 <code>HashMap</code> 使用头插法，插入过程中链表是反转的。例如，最开始插入 A、B、C 三个元素，链表的顺序是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">C -&gt; B -&gt; A<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>扩容时的并发问题</strong>：扩容时，<code>HashMap</code> 会重新计算每个元素的哈希值，并将它们重新放置到新的桶中。如果在扩容过程中，两个线程同时对同一个桶中的链表进行重排操作，就可能导致链表结构混乱。例如：</p>
<ul>
<li>假设线程 1 在扩容过程中把链表中的节点从旧数组迁移到新数组，而线程 2 也同时执行同样的操作。</li>
<li>线程 1 可能已经将节点 <code>A</code> 放入新的位置，但线程 2 没有意识到，仍然操作旧链表中的节点，可能会将 <code>A</code> 的 <code>next</code> 指针错误地指向 <code>B</code>，形成环形链表。</li>
</ul>
</li>
<li><p><strong>形成环形链表</strong>：由于多线程操作导致的链表操作不一致，链表中的某些节点的 <code>next</code> 指针可能错误地指向自己或前面的节点，形成循环。例如，节点 <code>A</code> 的 <code>next</code> 指针错误地指向了 <code>C</code>，导致链表变成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">C -&gt; B -&gt; A -&gt; C -&gt; B -&gt; A -&gt; ... （死循环）<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>遍历时进入死循环</strong>：在之后的遍历操作中，如果链表形成了环，遍历时会在循环中永远走不出来，从而导致程序陷入死循环。</p>
</li>
</ol>
</blockquote>
</li>
</ul>
</li>
</ol>
<h3 id="2-ConcurrentHashMap-数据结构与底层原理"><a href="#2-ConcurrentHashMap-数据结构与底层原理" class="headerlink" title="2. ConcurrentHashMap 数据结构与底层原理"></a>2. <code>ConcurrentHashMap</code> 数据结构与底层原理</h3><h4 id="数据结构：-1"><a href="#数据结构：-1" class="headerlink" title="数据结构："></a><strong>数据结构</strong>：</h4><ul>
<li><code>ConcurrentHashMap</code> 的底层结构是<strong>分段锁机制（JDK 1.7）和 CAS（JDK 1.8 后）</strong>。<ul>
<li>JDK 1.7 中，<code>ConcurrentHashMap</code> 使用了<strong>分段锁（Segment）+ HashEntry</strong>，即将整个哈希表分成多个段，每个段可以独立加锁，从而减少锁的粒度，提高并发效率。</li>
<li>JDK 1.8 之后，<code>ConcurrentHashMap</code> 的底层实现与 <code>HashMap</code> 类似，采用了<strong>数组 + 链表 + 红黑树</strong>的结构，但摒弃了分段锁，改为通过 <strong>CAS + synchronized</strong> 来保证并发安全。</li>
</ul>
</li>
</ul>
<h4 id="工作原理：-1"><a href="#工作原理：-1" class="headerlink" title="工作原理："></a><strong>工作原理</strong>：</h4><ol>
<li><p><strong>存储过程</strong>：</p>
<ul>
<li><code>ConcurrentHashMap</code> 使用 <code>hashCode()</code> 和 <code>spread()</code> 方法来计算哈希值，并定位到数组中的某个桶（bucket）。</li>
<li>JDK 1.8 之后的实现不再使用分段锁，而是采用了 CAS 和 <code>synchronized</code> 来控制并发修改。</li>
<li>对于插入操作，<code>ConcurrentHashMap</code> 使用 <code>CAS</code> 来确保线程安全。如果插入位置冲突，会通过 <code>synchronized</code> 对链表或红黑树进行操作。即只锁住冲突链表的头节点，从而减少锁的粒度。</li>
</ul>
</li>
<li><p><strong>扩容</strong>：</p>
<ul>
<li><code>ConcurrentHashMap</code> 也会进行扩容，类似 <code>HashMap</code>。当负载因子超过阈值时，它会创建一个更大的数组，并重新分配元素的位置。</li>
<li>扩容时，<code>ConcurrentHashMap</code> 通过<strong>分布式扩容</strong>的方式进行，即每个线程只负责处理一部分的数据迁移，避免了集中锁的性能开销。</li>
</ul>
</li>
<li><p><strong>线程安全性</strong>：</p>
<ul>
<li><code>ConcurrentHashMap</code> 是线程安全的，在多线程环境下，通过 <code>CAS</code> 和 <code>synchronized</code> 来保证数据的一致性和并发性。</li>
<li>它的设计使得在读操作时无需加锁（高并发环境下读取效率极高），只有在写操作（插入、删除）时会局部加锁或使用 CAS，尽可能减少锁的竞争。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="Fail-Fast机制原理"><a href="#Fail-Fast机制原理" class="headerlink" title="Fail-Fast机制原理"></a>Fail-Fast机制原理</h2><p><code>Fail-Fast</code> 机制是一种<strong>快速失败</strong>的机制，通常出现在对集合（如 <code>ArrayList</code>、<code>HashMap</code>、<code>HashSet</code> 等）进行迭代时。如果在迭代过程中，集合结构被修改（例如添加、删除或修改元素），迭代器会抛出 <code>ConcurrentModificationException</code> 异常。<code>Fail-Fast</code> 机制的目的在于尽早检测到并发修改问题，避免潜在的不一致性和错误结果。</p>
<h3 id="Fail-Fast-机制的工作原理"><a href="#Fail-Fast-机制的工作原理" class="headerlink" title="Fail-Fast 机制的工作原理"></a><strong>Fail-Fast 机制的工作原理</strong></h3><ol>
<li><p><strong>modCount 字段</strong></p>
<ul>
<li><code>modCount</code> 是集合类中的一个内部字段，用来记录集合的<strong>结构修改次数</strong>，每次对集合进行结构性修改时，都会增加 <code>modCount</code> 的值。</li>
<li><strong>结构修改</strong>是指对集合的大小或内容产生影响的操作，例如 <code>add()</code>、<code>remove()</code> 等。</li>
</ul>
</li>
<li><p><strong>迭代器的工作</strong></p>
<ul>
<li>当调用 <code>iterator()</code> 方法时，会创建一个新的迭代器对象，并将集合的当前 <code>modCount</code> 值存储到迭代器的一个字段中，通常称为 <code>expectedModCount</code>。</li>
<li>在遍历集合时，每次 <code>next()</code> 或 <code>hasNext()</code> 方法被调用时，迭代器都会检查 <code>modCount</code> 是否等于 <code>expectedModCount</code>。</li>
</ul>
</li>
<li><p><strong>一致性检查</strong></p>
<ul>
<li>如果 <code>modCount</code> 和 <code>expectedModCount</code> 不相等，意味着在迭代过程中集合被修改过（例如其他线程对集合进行了修改，或者直接在集合上调用了修改操作），此时迭代器会抛出 <code>ConcurrentModificationException</code> 异常。</li>
<li>这种机制确保了在<strong>非同步的环境下</strong>，当多个线程或多个操作同时访问集合时，能够及时检测到潜在的并发修改问题。</li>
</ul>
</li>
</ol>
<h4 id="Fail-Fast-机制示例"><a href="#Fail-Fast-机制示例" class="headerlink" title="Fail-Fast 机制示例"></a><strong>Fail-Fast 机制示例</strong></h4><p>以下是一个典型的 <code>Fail-Fast</code> 机制的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FailFastExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;A&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;B&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;C&quot;</span>);<br><br>        <span class="hljs-comment">// 获取迭代器</span><br>        Iterator&lt;String&gt; iterator = list.iterator();<br><br>        <span class="hljs-comment">// 迭代过程中直接修改集合结构</span><br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> iterator.next();<br>            <span class="hljs-keyword">if</span> (value.equals(<span class="hljs-string">&quot;B&quot;</span>)) &#123;<br>                list.remove(value); <span class="hljs-comment">// 修改集合结构</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Exception in thread &quot;main&quot; java.util.ConcurrentModificationException<br></code></pre></td></tr></table></figure>

<p>在这个示例中，<code>ArrayList</code> 在使用迭代器进行遍历时，由于在遍历过程中修改了集合（调用了 <code>list.remove()</code>），触发了 <code>Fail-Fast</code> 机制，导致抛出了 <code>ConcurrentModificationException</code>。</p>
<h3 id="Fail-Fast-机制抛出-ConcurrentModificationException-的原因"><a href="#Fail-Fast-机制抛出-ConcurrentModificationException-的原因" class="headerlink" title="Fail-Fast 机制抛出 ConcurrentModificationException 的原因"></a><strong>Fail-Fast 机制抛出 <code>ConcurrentModificationException</code> 的原因</strong></h3><ul>
<li><strong>迭代器的安全性</strong>：为了确保在遍历集合时，集合的结构没有被修改，避免可能导致的不一致性或错误计算。</li>
<li><strong>非线程安全集合</strong>：Java 中的集合类如 <code>ArrayList</code>、<code>HashMap</code> 等并不是线程安全的。<code>Fail-Fast</code> 机制并不是为了解决线程安全问题，而是为了在发生结构修改时立即通知开发者。</li>
</ul>
<h3 id="Fail-Fast-机制的局限性"><a href="#Fail-Fast-机制的局限性" class="headerlink" title="Fail-Fast 机制的局限性"></a><strong>Fail-Fast 机制的局限性</strong></h3><ul>
<li><strong>非绝对的</strong>：<code>Fail-Fast</code> 机制是<strong>快速失败</strong>，但并不能保证所有的并发修改都会被检测到。它是在集合的迭代过程中检查 <code>modCount</code> 是否变化，如果迭代器没有被使用，或者并发修改发生得非常巧妙，可能不会立即抛出 <code>ConcurrentModificationException</code>。</li>
<li><strong>无法处理多线程并发问题</strong>：<code>Fail-Fast</code> 并不能真正处理并发修改问题。在多线程环境中，应该使用同步集合或者并发集合（如 <code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code>）来避免问题。</li>
</ul>
<h3 id="如何避免-Fail-Fast"><a href="#如何避免-Fail-Fast" class="headerlink" title="如何避免 Fail-Fast"></a><strong>如何避免 <code>Fail-Fast</code></strong></h3><ol>
<li><p><strong>使用并发集合</strong>：</p>
<ul>
<li>如果在多线程环境下，需要对集合进行安全的并发操作，可以使用 Java 提供的并发集合类，例如：<ul>
<li><code>ConcurrentHashMap</code></li>
<li><code>CopyOnWriteArrayList</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>这些集合是<strong>线程安全</strong>的，并不会抛出 <code>ConcurrentModificationException</code>。</li>
</ul>
<ol start="2">
<li><p><strong>在单线程中遍历时避免修改集合</strong>：</p>
<ul>
<li><p>在遍历过程中不要直接修改集合，可以使用迭代器的 <code>remove()</code> 方法来移除元素，这是安全的，因为 <code>Iterator.remove()</code> 方法会更新 <code>modCount</code>，不会导致异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Iterator&lt;String&gt; iterator = list.iterator();<br><span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> iterator.next();<br>    <span class="hljs-keyword">if</span> (value.equals(<span class="hljs-string">&quot;B&quot;</span>)) &#123;<br>        iterator.remove(); <span class="hljs-comment">// 使用迭代器的 remove() 方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>在多线程环境下，使用同步机制</strong>：</p>
<ul>
<li>使用 <code>Collections.synchronizedList()</code> 或 <code>Collections.synchronizedMap()</code> 方法来将集合包装成线程安全的集合。</li>
<li>使用 <code>synchronized</code> 关键字来控制对集合的并发访问。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><code>Fail-Fast</code> 机制通过 <code>modCount</code> 来监控集合的结构变化，并在迭代时快速失败，抛出 <code>ConcurrentModificationException</code>。</li>
<li>它用于检测迭代过程中的结构修改，但并不适用于解决并发问题。</li>
<li>在多线程环境中，推荐使用并发集合类如 <code>ConcurrentHashMap</code> 来避免 <code>Fail-Fast</code> 的问题。</li>
</ul>
<hr>
<h2 id="泛型常用特点"><a href="#泛型常用特点" class="headerlink" title="泛型常用特点"></a>泛型常用特点</h2><p>Java 中的泛型提供了编译时的类型检查和代码的重用性，广泛用于集合类和方法定义。以下是泛型的一些常用特点：</p>
<h3 id="1-类型安全"><a href="#1-类型安全" class="headerlink" title="1. 类型安全"></a>1. <strong>类型安全</strong></h3><ul>
<li>泛型允许在编译时检查类型，而不是在运行时检查。这可以避免类型转换时的 <code>ClassCastException</code>，提高代码的类型安全性。</li>
<li>例如，在使用集合时，泛型可以确保集合中只能包含特定类型的元素：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;Hello&quot;</span>);<br><span class="hljs-comment">// list.add(123); // 编译时会报错</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-类型参数的限制（上界与下界）"><a href="#2-类型参数的限制（上界与下界）" class="headerlink" title="2. 类型参数的限制（上界与下界）"></a>2. <strong>类型参数的限制（上界与下界）</strong></h3><ul>
<li><p><strong>上界通配符</strong>：使用 <code>? extends T</code>，表示类型参数必须是 <code>T</code> 或 <code>T</code> 的子类。通常用于<strong>读取</strong>操作，确保能从泛型对象中安全读取数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printList</span><span class="hljs-params">(List&lt;? extends Number&gt; list)</span> &#123;<br>    <span class="hljs-keyword">for</span> (Number n : list) &#123;<br>        System.out.println(n);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p> 这个方法可以接受 <code>List&lt;Integer&gt;</code>、<code>List&lt;Double&gt;</code> 等 <code>Number</code> 的子类。</p>
</li>
<li><p><strong>下界通配符</strong>：使用 <code>? super T</code>，表示类型参数必须是 <code>T</code> 或 <code>T</code> 的父类。通常用于<strong>写入</strong>操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addNumber</span><span class="hljs-params">(List&lt;? <span class="hljs-built_in">super</span> Integer&gt; list)</span> &#123;<br>    list.add(<span class="hljs-number">123</span>); <span class="hljs-comment">// 可以添加 Integer 或其父类</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个方法可以接受 <code>List&lt;Integer&gt;</code>、<code>List&lt;Number&gt;</code> 等。</p>
</li>
</ul>
<h3 id="3-泛型类"><a href="#3-泛型类" class="headerlink" title="3. 泛型类"></a>3. <strong>泛型类</strong></h3><ul>
<li>可以定义类时带有类型参数，允许在创建对象时指定类型：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Box</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T value;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValue</span><span class="hljs-params">(T value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br>&#125;<br><br>Box&lt;String&gt; box = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Box</span>&lt;&gt;();<br>box.setValue(<span class="hljs-string">&quot;Hello&quot;</span>);<br>System.out.println(box.getValue());<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-泛型方法"><a href="#4-泛型方法" class="headerlink" title="4. 泛型方法"></a>4. <strong>泛型方法</strong></h3><ul>
<li>泛型不仅可以应用于类，还可以用于方法。泛型方法可以在方法签名中声明类型参数，使方法更加灵活：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">printArray</span><span class="hljs-params">(T[] array)</span> &#123;<br>    <span class="hljs-keyword">for</span> (T element : array) &#123;<br>        System.out.println(element);<br>    &#125;<br>&#125;<br><br>String[] strArray = &#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>&#125;;<br>Integer[] intArray = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>printArray(strArray);<br>printArray(intArray);<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-类型擦除"><a href="#5-类型擦除" class="headerlink" title="5. 类型擦除"></a>5. <strong>类型擦除</strong></h3><ul>
<li><p>Java 的泛型是通过<strong>类型擦除</strong>实现的，编译后，所有泛型信息都会被擦除，转而使用 <code>Object</code> 或者具体的边界类型替代。</p>
<p>例如，<code>List&lt;String&gt;</code> 和 <code>List&lt;Integer&gt;</code> 在编译后都会被擦除成 <code>List</code>，这就是为什么 Java 泛型不支持基本类型的原因（如 <code>List&lt;int&gt;</code> 是非法的）。</p>
</li>
<li><p><strong>运行时不会有泛型类型的检查</strong>，所以不能在运行时获取泛型类型信息，也不能创建泛型类型的实例。</p>
</li>
</ul>
<h3 id="6-不能用于基本数据类型"><a href="#6-不能用于基本数据类型" class="headerlink" title="6. 不能用于基本数据类型"></a>6. <strong>不能用于基本数据类型</strong></h3><ul>
<li>泛型只能用于对象类型，不能直接用于基本数据类型。例如，<code>List&lt;int&gt;</code> 是非法的，需要使用包装类 <code>Integer</code> 代替基本类型：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-number">10</span>); <span class="hljs-comment">// 自动装箱</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-泛型不能用于静态字段或静态方法"><a href="#7-泛型不能用于静态字段或静态方法" class="headerlink" title="7. 泛型不能用于静态字段或静态方法"></a>7. <strong>泛型不能用于静态字段或静态方法</strong></h3><ul>
<li><p>泛型类中的类型参数不能用于静态字段，因为静态字段属于类级别，而泛型参数是实例级别的。</p>
<p>但可以通过声明方法自身为泛型方法来使用类型参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">// Illegal: 静态字段不能使用实例泛型 T</span><br>    <span class="hljs-comment">// private static T value;</span><br><br>    <span class="hljs-comment">// 泛型静态方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;U&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(U value)</span> &#123;<br>        System.out.println(value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="8-泛型数组的限制"><a href="#8-泛型数组的限制" class="headerlink" title="8. 泛型数组的限制"></a>8. <strong>泛型数组的限制</strong></h3><ul>
<li><p>不能直接创建泛型数组，因为在运行时泛型类型被擦除，无法保证数组的类型安全。例如，以下代码是非法的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt;[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>&lt;String&gt;[<span class="hljs-number">10</span>]; <span class="hljs-comment">// 编译错误</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>但可以通过类型擦除后的类型数组来间接实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;?&gt;[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">List</span>&lt;?&gt;[<span class="hljs-number">10</span>]; <span class="hljs-comment">// 使用通配符</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="9-通配符"><a href="#9-通配符" class="headerlink" title="9. 通配符 ?"></a>9. <strong>通配符 <code>?</code></strong></h3><ul>
<li>泛型中的通配符 <code>?</code> 代表未知类型，通常用于提高代码的灵活性。<ul>
<li><code>List&lt;?&gt;</code> 可以接受任何类型的 <code>List</code>，如 <code>List&lt;String&gt;</code>、<code>List&lt;Integer&gt;</code>。</li>
</ul>
</li>
<li>如果只需要读取数据而不需要写入数据，可以使用通配符来表示各种类型的兼容性。</li>
</ul>
<h3 id="10-多重限定"><a href="#10-多重限定" class="headerlink" title="10. 多重限定"></a>10. <strong>多重限定</strong></h3><ul>
<li>泛型可以有多个上界限制，用 <code>&amp;</code> 符号连接：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span> &amp; Comparable&lt;T&gt;&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(T value)</span> &#123;<br>    <span class="hljs-comment">// value 必须是 Number 的子类，并且实现了 Comparable 接口</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="11-协变和逆变"><a href="#11-协变和逆变" class="headerlink" title="11. 协变和逆变"></a>11. <strong>协变和逆变</strong></h3><ul>
<li><strong>协变</strong>：<code>&lt;? extends T&gt;</code> 表示可以接受 <code>T</code> 或 <code>T</code> 的子类，用于保证只读操作时的安全性。</li>
<li><strong>逆变</strong>：<code>&lt;? super T&gt;</code> 表示可以接受 <code>T</code> 或 <code>T</code> 的父类，用于保证写入操作时的安全性。</li>
</ul>
<hr>
<h2 id="深拷贝和浅拷贝的区别"><a href="#深拷贝和浅拷贝的区别" class="headerlink" title="深拷贝和浅拷贝的区别"></a>深拷贝和浅拷贝的区别</h2><p><strong>深拷贝</strong>（Deep Copy）和<strong>浅拷贝</strong>（Shallow Copy）是两种对象复制方式，它们的区别主要体现在对象的引用和内存的分配上</p>
<h3 id="1-浅拷贝（Shallow-Copy）"><a href="#1-浅拷贝（Shallow-Copy）" class="headerlink" title="1. 浅拷贝（Shallow Copy）"></a>1. <strong>浅拷贝（Shallow Copy）</strong></h3><p>浅拷贝仅仅复制对象的<strong>第一层属性</strong>，对于对象的<strong>引用类型</strong>属性，它不会递归复制引用对象，而是<strong>直接复制对象的引用</strong>。这意味着原对象和副本共享相同的引用类型属性。</p>
<ul>
<li><p><strong>特点</strong>：</p>
<ul>
<li>基本类型（如 <code>int</code>, <code>double</code>）的值会被复制。</li>
<li>引用类型（如对象、数组）的引用地址会被复制，原对象和副本对象共享相同的引用。</li>
</ul>
</li>
<li><p>修改引用类型的内容会影响到原对象和副本对象。</p>
<ul>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java">     <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>         String name;<br>    	Address address;<br>     <br>         <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, Address address)</span> &#123;<br>             <span class="hljs-built_in">this</span>.name = name;<br>             <span class="hljs-built_in">this</span>.address = address;<br>    &#125;<br>     <br>         <span class="hljs-meta">@Override</span><br>         <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>             <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.clone(); <span class="hljs-comment">// 浅拷贝</span><br>         &#125;<br>&#125;<br>     <br>     <span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> &#123;<br>    	String city;<br>     <br>         <span class="hljs-keyword">public</span> <span class="hljs-title function_">Address</span><span class="hljs-params">(String city)</span> &#123;<br>             <span class="hljs-built_in">this</span>.city = city;<br>         &#125;<br>&#125;<br>     <br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>         <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>             <span class="hljs-type">Address</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>(<span class="hljs-string">&quot;New York&quot;</span>);<br>             <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;John&quot;</span>, address);<br>        		<span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> (Person) p1.clone(); <span class="hljs-comment">// 浅拷贝</span><br>     <br>             System.out.println(p1.address.city); <span class="hljs-comment">// 输出 &quot;New York&quot;</span><br>        		System.out.println(p2.address.city); <span class="hljs-comment">// 输出 &quot;New York&quot;</span><br>     <br>             p2.address.city = <span class="hljs-string">&quot;Los Angeles&quot;</span>;<br>             System.out.println(p1.address.city); <span class="hljs-comment">// 输出 &quot;Los Angeles&quot; (受影响)</span><br>         &#125;<br>     &#125;<br></code></pre></td></tr></table></figure>
<p>在上面的例子中，<code>p1</code> 和 <code>p2</code> 共享同一个 <code>Address</code> 对象，修改 <code>p2.address.city</code> 会影响到 <code>p1</code>。</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-深拷贝（Deep-Copy）"><a href="#2-深拷贝（Deep-Copy）" class="headerlink" title="2. 深拷贝（Deep Copy）"></a>2. <strong>深拷贝（Deep Copy）</strong></h3><p>深拷贝不仅复制对象的第一层属性，还会递归地复制对象中所有引用类型的属性，生成一份完全独立的副本。深拷贝的对象和原对象之间没有任何共享的部分，二者完全独立。</p>
<ul>
<li><p><strong>特点</strong>：</p>
<ul>
<li>基本类型的值会被复制。</li>
<li>引用类型属性会被递归复制，原对象和副本之间完全独立，互不影响。</li>
<li>修改深拷贝对象的任何属性，不会影响到原对象。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>    String name;<br>    Address address;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, Address address)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.address = address;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">cloned</span> <span class="hljs-operator">=</span> (Person) <span class="hljs-built_in">super</span>.clone();<br>        cloned.address = (Address) <span class="hljs-built_in">this</span>.address.clone(); <span class="hljs-comment">// 深拷贝</span><br>        <span class="hljs-keyword">return</span> cloned;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>    String city;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Address</span><span class="hljs-params">(String city)</span> &#123;<br>        <span class="hljs-built_in">this</span>.city = city;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.clone();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-type">Address</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>(<span class="hljs-string">&quot;New York&quot;</span>);<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;John&quot;</span>, address);<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> (Person) p1.clone(); <span class="hljs-comment">// 深拷贝</span><br><br>        System.out.println(p1.address.city); <span class="hljs-comment">// 输出 &quot;New York&quot;</span><br>        System.out.println(p2.address.city); <span class="hljs-comment">// 输出 &quot;New York&quot;</span><br><br>        p2.address.city = <span class="hljs-string">&quot;Los Angeles&quot;</span>;<br>        System.out.println(p1.address.city); <span class="hljs-comment">// 仍然输出 &quot;New York&quot; (不受影响)</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在深拷贝的示例中，<code>p1</code> 和 <code>p2</code> 的 <code>Address</code> 对象是独立的，因此修改 <code>p2.address.city</code> 不会影响 <code>p1</code>。</p>
</li>
</ul>
<h3 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="3. 应用场景"></a>3. <strong>应用场景</strong></h3><ul>
<li><strong>浅拷贝</strong>适用于数据结构较为简单的情况，尤其是当对象中的所有字段都是不可变的（如 <code>String</code> 等）。</li>
<li><strong>深拷贝</strong>适用于复杂数据结构，或者需要确保副本和原对象完全独立的场景。</li>
</ul>
<hr>
<h2 id="final的用法"><a href="#final的用法" class="headerlink" title="final的用法"></a>final的用法</h2><p><code>final</code> 是 Java 语言中的一个关键字，用于声明常量、方法和类，具有不同的含义和用途。</p>
<h3 id="1-final-修饰变量"><a href="#1-final-修饰变量" class="headerlink" title="1. final 修饰变量"></a>1. <strong><code>final</code> 修饰变量</strong></h3><ul>
<li><p><strong>常量</strong>：当 <code>final</code> 修饰一个变量时，该变量的值在初始化后不能再被修改。通常用于定义常量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Constants</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_VALUE</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>; <span class="hljs-comment">// 常量定义</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p><strong>局部变量</strong>：在方法内部使用 <code>final</code> 修饰局部变量，表示该变量的值在方法执行期间不能更改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">example</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">localVar</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">// localVar = 20; // 编译错误，不能修改 final 局部变量</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-final-修饰方法"><a href="#2-final-修饰方法" class="headerlink" title="2. final 修饰方法"></a>2. <strong><code>final</code> 修饰方法</strong></h3><ul>
<li><p><strong>防止方法被重写</strong>：当 <code>final</code> 修饰一个方法时，该方法不能被子类重写（override）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">     <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br>         <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>             System.out.println(<span class="hljs-string">&quot;This is a final method.&quot;</span>);<br>         &#125;<br>&#125;<br>     <br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Parent</span> &#123;<br>         <span class="hljs-comment">// @Override</span><br>         <span class="hljs-comment">// public void show() &#123; // 编译错误，不能重写 final 方法</span><br>         <span class="hljs-comment">//     System.out.println(&quot;Trying to override.&quot;);</span><br>         <span class="hljs-comment">// &#125;</span><br>     &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-final-修饰类"><a href="#3-final-修饰类" class="headerlink" title="3. final 修饰类"></a>3. <strong><code>final</code> 修饰类</strong></h3><ul>
<li><p><strong>防止类被继承</strong>：当 <code>final</code> 修饰一个类时，该类不能被继承。这用于创建不可扩展的类，确保类的行为不会被改变。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">     <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ImmutableClass</span> &#123;<br>         <span class="hljs-comment">// 类的内容</span><br>&#125;<br>     <br>     <span class="hljs-comment">// public class ExtendedClass extends ImmutableClass &#123; // 编译错误，不能继承 final 类</span><br>     <span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-final-与匿名内部类"><a href="#4-final-与匿名内部类" class="headerlink" title="4. final 与匿名内部类"></a>4. <strong><code>final</code> 与匿名内部类</strong></h3><ul>
<li><p>在匿名内部类中，使用 <code>final</code> 修饰的局部变量（或对象引用）在匿名内部类中必须是有效的。</p>
<p>这是因为匿名内部类可能会在方法执行完毕后继续存在，<code>final</code> 确保了局部变量的值不会改变，从而避免潜在的状态问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">example</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(message); <span class="hljs-comment">// 可以访问 final 局部变量</span><br>        &#125;<br>    &#125;;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable).start();<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="5-final-与线程安全"><a href="#5-final-与线程安全" class="headerlink" title="5. final 与线程安全"></a>5. <strong><code>final</code> 与线程安全</strong></h3><ul>
<li>使用 <code>final</code> 修饰的变量对于线程安全是有帮助的，尤其是当 <code>final</code> 变量是对象的引用时，它保证了在构造函数执行完毕后，引用不会被改变，并且该引用所指向的对象也是不可变的（如果对象本身是不可变的）。</li>
</ul>
<h3 id="6-final-关键字的限制"><a href="#6-final-关键字的限制" class="headerlink" title="6. final 关键字的限制"></a>6. <strong><code>final</code> 关键字的限制</strong></h3><ul>
<li><p><strong>静态变量</strong>：<code>final</code> 修饰的静态变量必须在声明时或在静态初始化块中初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> STATIC_CONSTANT;<br>    <br>    <span class="hljs-keyword">static</span> &#123;<br>        STATIC_CONSTANT = <span class="hljs-number">10</span>; <span class="hljs-comment">// 正确的初始化方式</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p><strong>对象引用</strong>：<code>final</code> 修饰的对象引用在初始化后不能改变指向其他对象，但可以改变对象的内部状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addElement</span><span class="hljs-params">(String element)</span> &#123;<br>        list.add(element); <span class="hljs-comment">// 可以修改对象的内部状态</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// list = new ArrayList&lt;&gt;(); // 编译错误，不能修改 final 引用</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong><code>final</code> 修饰变量</strong>：定义常量（在编译阶段会存入常量池中）或不可变的局部变量。</li>
<li><strong><code>final</code> 修饰方法</strong>：防止方法被重写，保持方法的行为不变。</li>
<li><strong><code>final</code> 修饰类</strong>：防止类被继承，确保类的行为不被改变。</li>
<li>匿名内部类中的 <code>final</code>：确保局部变量的值在匿名内部类中不会改变。</li>
<li><strong>线程安全与性能</strong>：<code>final</code> 有助于实现线程安全，并可能带来性能优化（内联）。</li>
</ul>
<hr>
<h2 id="static的用法"><a href="#static的用法" class="headerlink" title="static的用法"></a>static的用法</h2><p>在 Java 中，<code>static</code> 关键字用于修饰类的<strong>成员变量</strong>、<strong>方法</strong>、<strong>代码块</strong>和<strong>嵌套类</strong>。<code>static</code> 关键字与类相关，而不是与具体的对象实例相关，这意味着被 <code>static</code> 修饰的成员和方法是属于类本身的，可以在不创建类实例的情况下使用。</p>
<h3 id="1-static-修饰成员变量（静态变量）"><a href="#1-static-修饰成员变量（静态变量）" class="headerlink" title="1. static 修饰成员变量（静态变量）"></a>1. <strong><code>static</code> 修饰成员变量（静态变量）</strong></h3><ul>
<li><p><strong>类变量</strong>：用 <code>static</code> 修饰的成员变量是<strong>静态变量</strong>，属于类而不是某个对象。所有对象共享同一个静态变量，改变一个对象的静态变量会影响其他对象。</p>
</li>
<li><p><strong>存储位置</strong>：静态变量存储在内存的<strong>方法区</strong>中（Java 8 以后为元空间），在类加载时初始化，一直到类卸载时销毁。</p>
</li>
<li><p><strong>使用场景</strong>：适用于需要所有对象共享的状态或值，如常量、计数器等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 静态变量</span><br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Counter</span><span class="hljs-params">()</span> &#123;<br>        count++; <span class="hljs-comment">// 每次创建对象时静态变量递增</span><br>	&#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Counter</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Counter</span>();<br>        <span class="hljs-type">Counter</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Counter</span>();<br>        System.out.println(Counter.count); <span class="hljs-comment">// 输出 2</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，无论创建多少个 <code>Counter</code> 对象，<code>count</code> 变量是所有对象共享的。</p>
</li>
</ul>
<h3 id="2-static-修饰方法（静态方法）"><a href="#2-static-修饰方法（静态方法）" class="headerlink" title="2. static 修饰方法（静态方法）"></a>2. <strong><code>static</code> 修饰方法（静态方法）</strong></h3><ul>
<li><p><strong>类方法</strong>：<code>static</code> 修饰的方法是<strong>静态方法</strong>，属于类而不是对象，<strong>不依赖于具体对象的实例</strong>，可以直接通过类名调用。</p>
</li>
<li><p><strong>限制</strong>：静态方法只能访问静态变量和静态方法，不能访问非静态变量和非静态方法，因为非静态成员属于实例，而静态方法不依赖于实例。</p>
</li>
<li><p><strong>使用场景</strong>：适合那些不需要依赖对象状态或只需要类级别操作的方法，如工具类中的方法（<code>Math</code> 类的 <code>Math.sqrt()</code>）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Utility</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b; <span class="hljs-comment">// 静态方法</span><br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(Utility.add(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// 调用静态方法，不需要实例化</span><br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-static-修饰代码块（静态代码块）"><a href="#3-static-修饰代码块（静态代码块）" class="headerlink" title="3. static 修饰代码块（静态代码块）"></a>3. <strong><code>static</code> 修饰代码块（静态代码块）</strong></h3><ul>
<li><p><strong>类初始化块</strong>：<code>static</code> 代码块用于类的初始化操作，<strong>在类加载时执行一次</strong>，且只执行一次。静态代码块在类的所有静态成员（包括静态变量和静态方法）之前执行，适合一些只需要执行一次的初始化操作。</p>
</li>
<li><p><strong>使用场景</strong>：用于初始化静态变量、加载静态资源等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Static block executed&quot;</span>); <span class="hljs-comment">// 静态代码块</span><br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Example</span> <span class="hljs-variable">ex</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Example</span>(); <span class="hljs-comment">// 类加载时静态代码块执行</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> 输出：<code>Static block executed</code></p>
</li>
</ul>
<h3 id="4-static-修饰内部类（静态嵌套类）"><a href="#4-static-修饰内部类（静态嵌套类）" class="headerlink" title="4. static 修饰内部类（静态嵌套类）"></a>4. <strong><code>static</code> 修饰内部类（静态嵌套类）</strong></h3><ul>
<li><p><strong>静态内部类</strong>：用 <code>static</code> 修饰的内部类称为静态嵌套类，<strong>可以不依赖于外部类的实例</strong>而被创建和使用。与非静态内部类不同，静态嵌套类不能直接访问外部类的非静态成员，除非通过外部类的实例访问。</p>
</li>
<li><p><strong>使用场景</strong>：适用于内部类的行为与外部类没有强依赖关系的情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OuterClass</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NestedClass</span> &#123; <span class="hljs-comment">// 静态内部类</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;Static nested class&quot;</span>);<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        OuterClass.<span class="hljs-type">NestedClass</span> <span class="hljs-variable">nested</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OuterClass</span>.NestedClass();<br>        nested.display(); <span class="hljs-comment">// 静态内部类的调用</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>静态内部类可以像外部类一样独立存在和使用。</p>
</li>
</ul>
<h3 id="5-static-的其他应用场景"><a href="#5-static-的其他应用场景" class="headerlink" title="5. static 的其他应用场景"></a>5. <strong><code>static</code> 的其他应用场景</strong></h3><ul>
<li><p><strong>静态导入</strong>：通过 <code>import static</code> 关键字，可以直接导入类中的静态成员或方法，简化代码书写。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.Math.*; <span class="hljs-comment">// 静态导入 Math 类中的所有静态成员</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(sqrt(<span class="hljs-number">16</span>)); <span class="hljs-comment">// 不需要 Math.sqrt()</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>静态常量</strong>：配合 <code>final</code> 关键字，可以创建静态常量，这些常量通常大写，多个单词之间使用下划线分隔。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Constants</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> <span class="hljs-variable">PI</span> <span class="hljs-operator">=</span> <span class="hljs-number">3.14159</span>; <span class="hljs-comment">// 静态常量</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-static-与多线程"><a href="#6-static-与多线程" class="headerlink" title="6. static 与多线程"></a>6. <strong><code>static</code> 与多线程</strong></h3><ul>
<li>静态变量和静态方法在多线程环境中需要小心使用，因为它们是全局共享的，可能引发线程安全问题。可以通过同步机制（<code>synchronized</code>）来保证线程安全。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        count++;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>静态变量</strong>：属于类，所有实例共享，常用于全局状态、常量等场景。</li>
<li><strong>静态方法</strong>：属于类，不依赖于对象，可以直接通过类名调用，常用于工具方法或类级别操作。</li>
<li><strong>静态代码块</strong>：用于类的初始化，类加载时执行一次。</li>
<li><strong>静态内部类</strong>：不依赖于外部类的实例，可以独立创建，常用于内部逻辑独立的类。</li>
<li><strong>静态导入</strong>：用于简化代码书写，直接访问其他类中的静态成员。</li>
</ul>
<hr>
<h2 id="try-catch-finally，try里有return，finally还会执行吗"><a href="#try-catch-finally，try里有return，finally还会执行吗" class="headerlink" title="try catch finally，try里有return，finally还会执行吗"></a>try catch finally，try里有return，finally还会执行吗</h2><p>在 Java 中，如果在 <code>try</code> 块中有 <code>return</code> 语句，<code>finally</code> 块仍然会执行。<code>finally</code> 块是用来保证无论是否发生异常、是否在 <code>try</code> 或 <code>catch</code> 中有 <code>return</code>，它都会被执行。</p>
<p>即使在 <code>try</code> 块中有 <code>return</code> 语句，<code>finally</code> 块仍然会在 <code>return</code> 执行之前运行，且它可能会改变 <code>return</code> 的值（如果 <code>finally</code> 中也有 <code>return</code> 或修改了返回的变量）。</p>
<h3 id="代码示例-1：finally-在-return-之前执行"><a href="#代码示例-1：finally-在-return-之前执行" class="headerlink" title="代码示例 1：finally 在 return 之前执行"></a>代码示例 1：<code>finally</code> 在 <code>return</code> 之前执行</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">testMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;In try block&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>; <span class="hljs-comment">// try block 有 return</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;In finally block&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> testMethod();<br>        System.out.println(<span class="hljs-string">&quot;Result: &quot;</span> + result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>输出结果</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">In try block<br>In finally block<br>Result: 10<br></code></pre></td></tr></table></figure>
<h3 id="代码示例-2：finally-改变返回值"><a href="#代码示例-2：finally-改变返回值" class="headerlink" title="代码示例 2：finally 改变返回值"></a>代码示例 2：<code>finally</code> 改变返回值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">testMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;In try block&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>; <span class="hljs-comment">// try block 有 return</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;In finally block&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">20</span>; <span class="hljs-comment">// finally block 改变了返回值</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> testMethod();<br>        System.out.println(<span class="hljs-string">&quot;Result: &quot;</span> + result);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p><strong>输出结果</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">In try block<br>In finally block<br>Result: 20<br></code></pre></td></tr></table></figure>
<hr>
<h2 id="OOM你遇到过哪些情况，SOF你遇到过哪些情况"><a href="#OOM你遇到过哪些情况，SOF你遇到过哪些情况" class="headerlink" title="OOM你遇到过哪些情况，SOF你遇到过哪些情况"></a>OOM你遇到过哪些情况，SOF你遇到过哪些情况</h2><p>在实际开发中，<code>OutOfMemoryError</code>（OOM）和 <code>StackOverflowError</code>（SOF）是比较常见的错误，通常是由内存管理不当或递归过深导致的。</p>
<h3 id="OOM（OutOfMemoryError）"><a href="#OOM（OutOfMemoryError）" class="headerlink" title="OOM（OutOfMemoryError）"></a>OOM（OutOfMemoryError）</h3><p><code>OutOfMemoryError</code> 发生时，Java 虚拟机（JVM）没有足够的内存来为应用程序分配所需的内存。除了程序计数器外，JVM其他运行时区域都有可能发生OOM异常。</p>
<ol>
<li><p><strong>内存泄漏（Memory Leak）</strong>：</p>
<ul>
<li><p><strong>对象未被回收</strong>：对象虽然不再使用，但由于被其他对象引用，无法被垃圾回收器回收，导致堆内存占满。</p>
<blockquote>
<p>例如，使用 <code>List</code> 这样的集合存储大量对象，忘记清空或释放它们，可能会导致内存持续增长。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>加载过多的大对象</strong>：</p>
<ul>
<li><p>一次性创建过多或过大的对象，比如加载大量图片、处理大型文件等，导致堆内存溢出。</p>
<blockquote>
<p>例如，读取超大文件时，将文件内容一次性全部加载到内存中。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>线程过多（ThreadLocal内存泄漏）</strong>：</p>
<ul>
<li>创建了大量线程但没有合理管理这些线程，线程占用的内存也会导致 OOM。</li>
</ul>
</li>
</ol>
<ul>
<li>使用 <code>ThreadLocal</code> 时，如果不正确清理，也可能导致线程无法回收。</li>
</ul>
<ol start="4">
<li><strong>栈内存溢出导致的 OOM</strong>：</li>
</ol>
<ul>
<li>栈内存不足时也会抛出 OOM，尤其是递归调用导致深层次栈溢出。</li>
</ul>
<ol start="5">
<li><p><strong>PermGen&#x2F;Metaspace 溢出</strong>（在 JDK 7 及之前版本中发生于 PermGen，在 JDK 8 及之后发生于 Metaspace）：</p>
<ul>
<li>在类加载器中加载大量类或方法，导致 PermGen 或 Metaspace 溢出。常见于运行时频繁动态生成类的框架（如 Hibernate 或 CGLIB 动态代理等）。</li>
<li>运行时常量池溢出，例如String.intern()方法将字符串添加到常量池。</li>
</ul>
</li>
</ol>
<h3 id="SOF（StackOverflowError）"><a href="#SOF（StackOverflowError）" class="headerlink" title="SOF（StackOverflowError）"></a>SOF（StackOverflowError）</h3><p><code>StackOverflowError</code> 通常发生在递归调用过多或者递归没有正确终止时，导致栈内存被耗尽。常见的场景包括：</p>
<ol>
<li><p><strong>递归过深</strong>：</p>
<ul>
<li><p>递归函数没有合理的终止条件，导致递归层级过深，栈空间耗尽。</p>
<blockquote>
<p>例如，计算斐波那契数列时没有限制递归深度：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fibonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br> <span class="hljs-keyword">return</span> fibonacci(n - <span class="hljs-number">1</span>) + fibonacci(n - <span class="hljs-number">2</span>); <span class="hljs-comment">// 没有终止条件</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>错误的递归调用</strong>：</p>
<ul>
<li><p>由于错误逻辑导致自己调用自己，甚至是多个方法之间相互递归调用，导致栈无限增长，最终导致栈溢出。</p>
<blockquote>
<p>比如一个类的方法 <code>methodA</code> 调用 <code>methodB</code>，而 <code>methodB</code> 又调用 <code>methodA</code>，产生无限循环调用。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>构造函数的递归调用</strong>：</p>
<ul>
<li>在类的构造函数中调用另一个构造函数，结果陷入死循环。例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>(); <span class="hljs-comment">// 构造函数递归调用自己</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>OOM</strong> 常见于内存泄漏、加载大量对象或数据、过多线程等情况。</li>
<li><strong>SOF</strong> 常见于递归调用未正确终止或递归过深导致栈溢出。</li>
</ul>
<hr>
<h2 id="在项目中遇到的-OOM-是出现在什么场景下的？"><a href="#在项目中遇到的-OOM-是出现在什么场景下的？" class="headerlink" title="在项目中遇到的 OOM  是出现在什么场景下的？"></a>在项目中遇到的 OOM  是出现在什么场景下的？</h2><p>在项目中，我遇到的 <strong>OOM（OutOfMemoryError）</strong> 通常出现在以下几种场景：</p>
<ol>
<li><strong>大数据处理场景</strong>：</li>
</ol>
<ul>
<li>处理大量数据时，特别是批量导入或导出操作时，如果没有合理的分批处理机制，可能会一次性加载过多数据到内存中，导致堆内存不足，抛出 OOM 错误。例如在处理 Excel 文件或数据库查询时，直接将数十万条数据加载到内存，而不是分页加载或流式处理。</li>
</ul>
<ol start="2">
<li><strong>集合类使用不当</strong>：</li>
</ol>
<ul>
<li>在使用集合类（如 <code>List</code>、<code>Map</code> 等）时，未能及时清空或释放不再需要的对象，导致集合中的对象占用内存不断增加，最终触发 OOM。</li>
</ul>
<ol start="3">
<li><strong>第三方库内存泄漏</strong>：</li>
</ol>
<ul>
<li>某些第三方库在使用时可能有内存泄漏问题。例如，在使用某些图表库或 PDF 生成工具时，由于底层缓存机制没有合理的内存管理，导致内存占用持续增长，最终触发 OOM。</li>
</ul>
<ol start="4">
<li><strong>字符串操作导致 OOM</strong>：</li>
</ol>
<ul>
<li>大量字符串拼接操作可能导致内存占用增加，尤其是在循环中进行拼接时。虽然 Java 8 对 <code>StringBuilder</code> 优化了字符串的拼接效率，但在处理大量长字符串时，仍然可能触发 OOM。</li>
</ul>
<ol start="5">
<li><p><strong>线程池管理不当</strong>：</p>
<ul>
<li>创建了大量线程却没有合理管理线程池，导致线程数量爆增，消耗了大量内存资源，最终引发 OOM。特别是使用 <code>ThreadLocal</code> 时，如果不注意释放线程本地变量，可能导致内存泄漏。</li>
</ul>
</li>
<li><p><strong>JVM 参数配置不当</strong></p>
<ul>
<li>如果 JVM 的 <strong>堆大小</strong> 参数（<code>-Xmx</code> 和 <code>-Xms</code>）设置不合理，可能导致内存不足。</li>
</ul>
</li>
<li><p><strong>内存泄漏（Memory Leak）</strong> </p>
<ul>
<li><strong>对象未被正确释放</strong>：应用中的某些对象不再使用，但由于被错误的强引用（如静态变量或单例模式中的持有）阻止了垃圾回收器的回收，导致内存泄漏。</li>
<li><strong>线程未关闭</strong>：线程未被正确关闭或回收，导致相关的线程局部变量 (<code>ThreadLocal</code>) 没有被清理，长时间运行时，线程累积导致内存泄漏。</li>
</ul>
</li>
<li><p><strong>过度使用缓存</strong></p>
<ul>
<li>过度依赖缓存（如自定义的 <code>Map</code> 缓存、第三方缓存工具等），如果没有合理设置缓存清理机制，缓存数据会不断增长，导致内存耗尽。例如在高并发的 Web 应用中，如果缓存中存储大量用户会话数据或查询结果而未设置过期机制，会引发 OOM。</li>
<li>尤其是使用 <code>WeakHashMap</code>、<code>ConcurrentHashMap</code> 等缓存类时，若不合理控制缓存大小或失效机制，容易导致缓存膨胀。</li>
</ul>
</li>
<li><p><strong>图片或大文件处理</strong></p>
<ul>
<li>处理大量图片或大型文件时（如 PDF、视频文件），将整个文件一次性加载到内存中，可能导致内存溢出。比如使用 <code>ImageIO.read()</code> 来加载大型图片文件，如果文件太大，直接导致 OOM。</li>
<li>文件流处理时没有使用流式（<code>stream</code>）操作，而是一次性加载整个文件或数据块到内存。</li>
</ul>
</li>
<li><p><strong>JNI 调用导致的 OOM</strong></p>
<ul>
<li>使用 <strong>JNI（Java Native Interface）</strong> 调用本地代码（如 C&#x2F;C++ 代码）时，如果本地代码中存在内存泄漏，JVM 无法回收这些内存，最终可能导致 OOM。这种情况一般较难排查，因为涉及本地代码的内存管理。</li>
</ul>
</li>
<li><p><strong>过多的短生存期对象</strong></p>
<ul>
<li><p>应用程序中不断创建大量的短生存期对象（如在高并发系统中大量生成临时对象），即使这些对象会被快速回收，但由于创建频率太高，导致 GC（垃圾回收器）频繁触发，最终可能引发 OOM。</p>
<blockquote>
<p>这种情况常见于 <strong>频繁的对象创建和销毁</strong>，比如高并发场景下创建大量请求对象、响应对象，或是在循环中不断创建临时变量等。</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>Socket 连接资源泄漏</strong></p>
<ul>
<li>如果网络通信中没有合理地关闭 <code>Socket</code> 连接，未正确释放相关资源（如输入&#x2F;输出流），会导致系统内存消耗增加，引发 OOM。长时间不释放连接资源，尤其在高并发的应用中，会消耗大量内存。</li>
</ul>
</li>
<li><p><strong>数据库连接池资源未释放</strong></p>
<ul>
<li>数据库连接池（如 HikariCP、DBCP）使用不当，可能导致连接未正确释放，连接池中的对象不断增长，最终导致内存溢出。这种问题在数据库密集型应用中较为常见。</li>
</ul>
</li>
<li><p><strong>循环创建线程</strong></p>
<ul>
<li>如果应用在运行时不合理地创建大量线程，并且没有正确管理这些线程，可能导致内存消耗急剧增加，触发 OOM。例如，每次处理请求时都创建新线程，但没有合理回收或限制线程数量。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="这些OOM问题是怎么排查的呢"><a href="#这些OOM问题是怎么排查的呢" class="headerlink" title="这些OOM问题是怎么排查的呢"></a>这些OOM问题是怎么排查的呢</h2><p><strong>OutOfMemoryError（OOM）</strong> 的排查可以通过多种方法进行，主要包括分析堆转储文件、监控 JVM 内存使用、优化代码等。以下是常用的排查 OOM 问题的步骤和工具：</p>
<h3 id="1-通过堆转储文件排查内存问题"><a href="#1-通过堆转储文件排查内存问题" class="headerlink" title="1. 通过堆转储文件排查内存问题"></a>1. <strong>通过堆转储文件排查内存问题</strong></h3><p>当应用程序抛出 <code>OutOfMemoryError</code> 时，首先需要获取堆转储（heap dump）文件。堆转储是 JVM 在发生 OOM 时内存的快照，其中包含当前堆中所有对象的状态。</p>
<h4 id="1-1-生成堆转储"><a href="#1-1-生成堆转储" class="headerlink" title="1.1 生成堆转储"></a>1.1 生成堆转储</h4><p>你可以通过以下方式生成堆转储文件：</p>
<ul>
<li><p><strong>JVM 启动参数</strong>：<br>使用以下参数在 OOM 时自动生成堆转储文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/path/to/dump<br></code></pre></td></tr></table></figure></li>
</ul>
<p>这会在 OOM 发生时生成一个 <code>.hprof</code> 文件，用于后续分析。</p>
<ul>
<li><p><strong>手动生成堆转储</strong>：<br>可以使用 JVM 调试工具 <code>jmap</code> 来手动生成堆转储文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jmap -dump:format=b,file=/path/to/dump &lt;pid&gt;<br></code></pre></td></tr></table></figure>
<p><code>&lt;pid&gt;</code> 是应用程序的进程 ID。</p>
<blockquote>
<p>ps -ef | grep java查看</p>
</blockquote>
</li>
</ul>
<h4 id="1-2-分析堆转储"><a href="#1-2-分析堆转储" class="headerlink" title="1.2 分析堆转储"></a>1.2 分析堆转储</h4><p>堆转储文件可以通过以下工具进行分析：</p>
<ul>
<li><p><strong>Eclipse MAT（Memory Analyzer Tool）</strong>：这是一个开源的堆分析工具，能够帮助你查找大对象、内存泄漏、无用的对象引用等问题。</p>
<ul>
<li>使用 MAT 加载 <code>.hprof</code> 文件后，工具会自动生成报告，显示内存中哪些对象占用较大，可以帮助你定位问题。</li>
<li>你可以使用 MAT 的“<strong>Leak Suspects Report</strong>”来检查可能的内存泄漏问题。</li>
</ul>
</li>
<li><p><strong>VisualVM</strong>：这是一个自带于 JDK 的工具，可以分析堆转储，并通过可视化的方式查看内存占用情况。</p>
<ul>
<li>它可以帮助你查看哪些类的实例数量最多、哪些对象占用了最多的内存。</li>
</ul>
</li>
</ul>
<h3 id="2-通过-GC-日志排查问题"><a href="#2-通过-GC-日志排查问题" class="headerlink" title="2. 通过 GC 日志排查问题"></a>2. <strong>通过 GC 日志排查问题</strong></h3><p><strong>垃圾回收日志</strong>（GC logs）可以帮助你了解垃圾回收器的运行情况，从而分析内存压力和内存泄漏的可能性。</p>
<h4 id="2-1-开启-GC-日志"><a href="#2-1-开启-GC-日志" class="headerlink" title="2.1 开启 GC 日志"></a>2.1 开启 GC 日志</h4><p>在 JVM 启动时，可以通过以下参数开启 GC 日志：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:/path/to/gc.log<br></code></pre></td></tr></table></figure>
<p>这将记录每次 GC 的详细信息，包括内存分配、释放、GC 停顿时间等。</p>
<h4 id="2-2-分析-GC-日志"><a href="#2-2-分析-GC-日志" class="headerlink" title="2.2 分析 GC 日志"></a>2.2 分析 GC 日志</h4><p>可以通过以下方法分析 GC 日志：</p>
<ul>
<li><strong>GCViewer</strong>：这是一个开源的工具，专门用于分析 GC 日志文件。它能够帮助你了解堆的增长情况、垃圾回收的频率和时间等。</li>
<li><strong>GCEasy</strong>：一个在线 GC 日志分析工具，支持上传 GC 日志文件并生成图表，帮助你直观地了解内存使用情况。</li>
</ul>
<h4 id="2-3-GC-日志中的重点信息"><a href="#2-3-GC-日志中的重点信息" class="headerlink" title="2.3 GC 日志中的重点信息"></a>2.3 GC 日志中的重点信息</h4><ul>
<li><strong>Full GC 频率过高</strong>：如果 Full GC 过于频繁，说明堆内存不足，可能是因为内存泄漏或对象创建速度过快。</li>
<li><strong>年轻代和老年代</strong>：检查年轻代（Young Generation）和老年代（Old Generation）内存的增长情况，确认内存是否因为对象无法被回收而逐渐被占满。</li>
</ul>
<h3 id="3-通过-JVM-监控工具分析"><a href="#3-通过-JVM-监控工具分析" class="headerlink" title="3. 通过 JVM 监控工具分析"></a>3. <strong>通过 JVM 监控工具分析</strong></h3><h4 id="3-1-使用-jconsole-或-jvisualvm"><a href="#3-1-使用-jconsole-或-jvisualvm" class="headerlink" title="3.1 使用 jconsole 或 jvisualvm"></a>3.1 使用 <code>jconsole</code> 或 <code>jvisualvm</code></h4><ul>
<li><p><strong>JConsole</strong> 和 <strong>JVisualVM</strong> 是 JDK 自带的工具，可以实时监控 JVM 的内存使用情况，包括堆内存、方法区（元空间）、线程等。</p>
<p>它们可以帮助你查看内存使用趋势、分析内存分配和垃圾回收情况，以及捕捉线程的活动状态。</p>
</li>
</ul>
<h4 id="3-2-监控堆内存使用"><a href="#3-2-监控堆内存使用" class="headerlink" title="3.2 监控堆内存使用"></a>3.2 监控堆内存使用</h4><ul>
<li>在监控过程中，查看堆内存的使用率是否逐步增长，如果堆内存使用率持续增长且垃圾回收无法释放大量对象，可能存在内存泄漏。</li>
<li>可以使用 <code>VisualVM</code> 的“<strong>Sampler</strong>”或“<strong>Profiler</strong>”功能，来分析哪些类占用了最多的内存，或者执行时间最长的代码路径。</li>
</ul>
<h3 id="4-排查代码中的内存泄漏"><a href="#4-排查代码中的内存泄漏" class="headerlink" title="4. 排查代码中的内存泄漏"></a>4. <strong>排查代码中的内存泄漏</strong></h3><h4 id="4-1-检查长生命周期的对象"><a href="#4-1-检查长生命周期的对象" class="headerlink" title="4.1 检查长生命周期的对象"></a>4.1 检查长生命周期的对象</h4><ul>
<li><strong>静态变量</strong>：静态变量的生命周期与类相同，因此它们可能在程序运行期间一直占用内存。检查静态集合类（如 <code>List</code>、<code>Map</code> 等）是否存在不必要的对象引用。</li>
<li><strong>ThreadLocal</strong>：使用 <code>ThreadLocal</code> 变量时，必须在使用完后调用 <code>remove()</code> 方法，否则对象无法被回收。</li>
</ul>
<h4 id="4-2-优化缓存使用"><a href="#4-2-优化缓存使用" class="headerlink" title="4.2 优化缓存使用"></a>4.2 优化缓存使用</h4><ul>
<li><p><strong>缓存策略</strong>：检查是否对缓存进行了合理的限制或过期策略。无界缓存会导致内存使用不断增加，最终触发 OOM。</p>
<blockquote>
<p>例如，在使用 <code>ConcurrentHashMap</code> 或自定义缓存时，确保设置了最大缓存大小或过期机制。</p>
</blockquote>
</li>
</ul>
<h4 id="4-3-逐步加载数据"><a href="#4-3-逐步加载数据" class="headerlink" title="4.3 逐步加载数据"></a>4.3 逐步加载数据</h4><ul>
<li><p>在处理大数据集时，不要一次性将所有数据加载到内存中。可以采用<strong>分页加载</strong>或<strong>流式处理</strong>来减少内存占用。</p>
<blockquote>
<p>例如，读取大文件时，可以逐行或逐块读取，而不是一次性将整个文件加载到内存。</p>
</blockquote>
</li>
</ul>
<h3 id="5-检查第三方库的内存使用情况"><a href="#5-检查第三方库的内存使用情况" class="headerlink" title="5. 检查第三方库的内存使用情况"></a>5. <strong>检查第三方库的内存使用情况</strong></h3><p>有时候 OOM 是由第三方库引起的：</p>
<ul>
<li><strong>检查库的版本</strong>：更新第三方库版本，可能会修复一些内存泄漏问题。例如，某些老版本的 PDF 生成库或图表库存在内存泄漏。</li>
<li><strong>分析第三方库的内存占用</strong>：通过 <code>VisualVM</code> 或堆转储工具，检查是否有第三方库的类占用了大量内存。如果是第三方库引发的内存泄漏，可以查看该库的文档或社区建议，找到相应的解决方案。</li>
</ul>
<h3 id="6-调整-JVM-参数"><a href="#6-调整-JVM-参数" class="headerlink" title="6. 调整 JVM 参数"></a>6. <strong>调整 JVM 参数</strong></h3><h4 id="6-1-增加堆内存"><a href="#6-1-增加堆内存" class="headerlink" title="6.1 增加堆内存"></a>6.1 增加堆内存</h4><p>如果应用确实需要大量内存，可以通过调整 JVM 参数增加堆内存：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-Xms512m -Xmx4g<br></code></pre></td></tr></table></figure>
<p>这表示堆内存的初始大小为 512MB，最大可用内存为 4GB。</p>
<h4 id="6-2-调整元空间大小"><a href="#6-2-调整元空间大小" class="headerlink" title="6.2 调整元空间大小"></a>6.2 调整元空间大小</h4><p>在 Java 8 及之后版本，可以通过以下参数调整 <strong>元空间（Metaspace）</strong> 的大小：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=512m<br></code></pre></td></tr></table></figure>
<p>如果应用加载了大量类，可能需要增加元空间的大小，以防止元空间溢出（<code>OutOfMemoryError: Metaspace</code>）。</p>
<h4 id="6-3-设置合理的垃圾回收器"><a href="#6-3-设置合理的垃圾回收器" class="headerlink" title="6.3 设置合理的垃圾回收器"></a>6.3 设置合理的垃圾回收器</h4><p>根据应用的特点选择合适的垃圾回收器（GC），例如：</p>
<ul>
<li><p><strong>G1 垃圾回收器</strong>：适合大堆内存应用（大于 4GB），可以平衡 GC 停顿时间和吞吐量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-XX:+UseG1GC<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-通过线程监控排查-SOF（StackOverflowError）"><a href="#7-通过线程监控排查-SOF（StackOverflowError）" class="headerlink" title="7. 通过线程监控排查 SOF（StackOverflowError）"></a>7. <strong>通过线程监控排查 SOF（StackOverflowError）</strong></h3><p>如果你遇到的是 <strong>StackOverflowError（SOF）</strong>，可以通过以下方法排查：</p>
<ul>
<li><p><strong>检查递归调用</strong>：确保递归调用有正确的终止条件，避免无穷递归。</p>
</li>
<li><p><strong>检查循环方法调用</strong>：防止方法之间的相互调用导致栈溢出。</p>
</li>
<li><p><strong>增加栈大小</strong>：通过 JVM 参数 <code>-Xss</code> 增加栈的大小，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-Xss1m<br></code></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p>排查 OOM 问题的关键是：</p>
<ol>
<li><strong>堆转储分析</strong>：分析内存占用情况，找出大对象或内存泄漏的根源。</li>
<li><strong>GC 日志分析</strong>：监控垃圾回收的频率和内存分配趋势，识别内存不足的原因。</li>
<li><strong>监控 JVM 内存使用</strong>：通过 JConsole、VisualVM 等工具实时监控应用的内存使用情况。</li>
<li><strong>优化代码</strong>：避免内存泄漏、缓存无界增长、一次性加载大数据等不合理的内存使用模式。</li>
</ol>
<p>排查 OOM 是一个持续优化的过程，通常需要结合堆转储、GC 日志和代码分析，逐步排查出问题所在。</p>
<hr>
<h2 id="典型的线上OOM问题排查过程"><a href="#典型的线上OOM问题排查过程" class="headerlink" title="典型的线上OOM问题排查过程"></a>典型的线上OOM问题排查过程</h2><p>线上系统发生 <strong>OutOfMemoryError（OOM）</strong> 或 <strong>StackOverflowError（SOF）</strong> 等问题时，排查和解决问题是一个系统化的过程，通常包括 <strong>监控报警</strong>、<strong>日志分析</strong>、<strong>问题定位</strong>、<strong>内存分析</strong>、<strong>代码优化</strong> 以及 <strong>验证发布</strong> 等环节。以下是一个典型的线上问题排查过程，</p>
<hr>
<h3 id="1-问题发生：线上异常和报警"><a href="#1-问题发生：线上异常和报警" class="headerlink" title="1. 问题发生：线上异常和报警"></a><strong>1. 问题发生：线上异常和报警</strong></h3><h4 id="1-1-监控报警"><a href="#1-1-监控报警" class="headerlink" title="1.1 监控报警"></a>1.1 监控报警</h4><ul>
<li><strong>应用监控工具报警</strong>：例如，使用 <strong>Prometheus + Grafana</strong> 监控 JVM 内存使用情况、GC 频率、响应时间等。发现某个节点或服务内存飙升、响应超时，甚至宕机重启。</li>
<li><strong>报警系统触发</strong>：如果配置了告警规则（如 OOM、Full GC 频率过高、内存使用超过阈值），会自动发送报警邮件、短信或钉钉通知。</li>
</ul>
<h4 id="1-2-用户反馈"><a href="#1-2-用户反馈" class="headerlink" title="1.2 用户反馈"></a>1.2 用户反馈</h4><ul>
<li>用户反馈某些功能无法正常使用，或者服务响应特别慢，甚至应用直接崩溃，无法访问。</li>
</ul>
<hr>
<h3 id="2-初步检查：通过日志和监控工具确认问题"><a href="#2-初步检查：通过日志和监控工具确认问题" class="headerlink" title="2. 初步检查：通过日志和监控工具确认问题"></a><strong>2. 初步检查：通过日志和监控工具确认问题</strong></h3><h4 id="2-1-查看应用日志"><a href="#2-1-查看应用日志" class="headerlink" title="2.1 查看应用日志"></a>2.1 查看应用日志</h4><ul>
<li><p><strong>查看异常日志</strong>：检查应用日志，确认是否有 <code>OutOfMemoryError</code> 或 <code>StackOverflowError</code> 异常抛出，并记录问题发生的时间、异常栈信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">java.lang.OutOfMemoryError: Java heap space<br>at com.example.MyClass.method(MyClass.java:xx)<br></code></pre></td></tr></table></figure>
<ul>
<li><code>OOM: Java heap space</code>：表示堆内存不足，通常是由于内存使用增长过快或对象没有被及时回收导致。</li>
<li><code>OOM: Metaspace</code>：表示元空间不足，通常是由于类加载过多或类加载器泄漏导致。</li>
<li><code>StackOverflowError</code>：表示方法调用栈溢出，通常是由于递归过深或循环调用导致。</li>
</ul>
</li>
</ul>
<h4 id="2-2-查看-GC-日志"><a href="#2-2-查看-GC-日志" class="headerlink" title="2.2 查看 GC 日志"></a>2.2 查看 GC 日志</h4><ul>
<li><p>查看 <strong>GC 日志</strong>，确认垃圾回收的频率和效果。如果出现频繁的 Full GC 且无法释放足够的内存，很可能内存泄漏或不合理的内存使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">[Full GC (Allocation Failure) [PSYoungGen: 2048K-&gt;0K(3072K)] ...<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>日志解析</strong></p>
<ul>
<li><strong>Full GC</strong>：表示这次是一个<strong>完全的垃圾回收</strong>，不仅对 <strong>年轻代</strong>（Young Generation）进行回收，还对 <strong>老年代</strong>（Old Generation）和 <strong>永久代</strong>（Metaspace）进行清理。Full GC 的执行通常伴随着较大的停顿（STW，Stop The World）。</li>
<li>**(Allocation Failure)**：表示 JVM 在尝试为新的对象分配内存时，发现当前可用的内存不足，触发了 Full GC。这种情况通常发生在堆内存即将耗尽时。</li>
<li><strong>PSYoungGen</strong>：<strong>Parallel Scavenge 垃圾收集器</strong>（并行收集器）对 <strong>年轻代</strong> 内存的回收。</li>
<li><strong>2048K-&gt;0K</strong>：表示 <strong>年轻代内存</strong> 的使用情况<ul>
<li><strong>2048K</strong>：表示在 Full GC 之前，年轻代中已经占用了 2048K 内存。</li>
<li><strong>0K</strong>：表示 Full GC 之后，年轻代中的所有对象都被回收了，内存使用量降为 0。</li>
</ul>
</li>
<li><strong>(3072K)<strong>：</strong>年轻代内存的总容量</strong>，即 Full GC 之后年轻代可以容纳的最大内存为 3072K。</li>
</ul>
</li>
</ul>
<h4 id="2-3-实时监控-JVM-内存使用"><a href="#2-3-实时监控-JVM-内存使用" class="headerlink" title="2.3 实时监控 JVM 内存使用"></a>2.3 实时监控 JVM 内存使用</h4><ul>
<li>使用 <strong>JConsole</strong> 或 <strong>VisualVM</strong> 等工具连接到线上 JVM 实例，查看堆内存、元空间、线程等使用情况。</li>
<li>重点关注内存曲线是否逐渐上升（即使 GC 也无法释放内存），这是典型的内存泄漏表现。</li>
</ul>
<hr>
<h3 id="3-数据收集：获取堆转储文件"><a href="#3-数据收集：获取堆转储文件" class="headerlink" title="3. 数据收集：获取堆转储文件"></a><strong>3. 数据收集：获取堆转储文件</strong></h3><h4 id="3-1-生成堆转储（Heap-Dump）"><a href="#3-1-生成堆转储（Heap-Dump）" class="headerlink" title="3.1 生成堆转储（Heap Dump）"></a>3.1 生成堆转储（Heap Dump）</h4><ul>
<li><p>在确认 OOM 发生时，可以通过 JVM 参数自动生成堆转储文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/path/to/dump<br></code></pre></td></tr></table></figure>
<p>这会在 OOM 发生时生成 <code>.hprof</code> 文件，用于后续分析。</p>
</li>
<li><p>如果应用没有自动生成堆转储文件，可以使用 <code>jmap</code> 手动生成：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jmap -dump:format=b,file=/path/to/dump &lt;pid&gt;<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-2-获取-GC-日志"><a href="#3-2-获取-GC-日志" class="headerlink" title="3.2 获取 GC 日志"></a>3.2 获取 GC 日志</h4><ul>
<li>确保 GC 日志已开启并可用。使用以下 JVM 参数确保 GC 日志记录在发生 OOM 时生成：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:/path/to/gc.log<br></code></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="4-问题定位：分析堆转储和-GC-日志"><a href="#4-问题定位：分析堆转储和-GC-日志" class="headerlink" title="4. 问题定位：分析堆转储和 GC 日志"></a><strong>4. 问题定位：分析堆转储和 GC 日志</strong></h3><h4 id="4-1-分析堆转储文件"><a href="#4-1-分析堆转储文件" class="headerlink" title="4.1 分析堆转储文件"></a>4.1 分析堆转储文件</h4><ul>
<li>使用 <strong>Eclipse MAT</strong> 或 <strong>VisualVM</strong> 打开堆转储文件，重点关注：<ul>
<li><strong>大对象</strong>：查看哪些对象占用了大量内存。MAT 中可以生成“<strong>Top Consumers</strong>”或“<strong>Dominators</strong>”报告，显示占用内存最多的对象。</li>
<li><strong>内存泄漏</strong>：MAT 的“<strong>Leak Suspects</strong>”报告能够识别可能存在的内存泄漏，包括哪些对象可能未被正确回收。</li>
<li><strong>对象引用关系</strong>：查看某些类实例是否被错误地长时间持有引用（例如静态变量导致的持久引用），造成无法回收。</li>
</ul>
</li>
</ul>
<h4 id="4-2-分析-GC-日志"><a href="#4-2-分析-GC-日志" class="headerlink" title="4.2 分析 GC 日志"></a>4.2 分析 GC 日志</h4><ul>
<li><strong>检查 GC 日志</strong>，分析垃圾回收的频率、时间、效果：<ul>
<li>Full GC 过于频繁，并且每次回收效果都不佳，意味着老年代内存占用过多。</li>
<li>查看 <strong>Young Generation</strong> 和 <strong>Old Generation</strong> 的内存使用趋势，确认是否是年轻代对象过多晋升到老年代，导致老年代内存膨胀。</li>
</ul>
</li>
</ul>
<h4 id="4-3-检查代码中的问题"><a href="#4-3-检查代码中的问题" class="headerlink" title="4.3 检查代码中的问题"></a>4.3 检查代码中的问题</h4><ul>
<li><strong>循环引用或静态变量持有对象</strong>：在堆转储中，如果某些静态变量（如缓存、ThreadLocal）持有大量对象，可能是内存泄漏的原因。</li>
<li><strong>集合类没有清空</strong>：检查是否有集合类（如 <code>HashMap</code>、<code>List</code>）中存储了大量对象，且没有及时清空或释放。</li>
</ul>
<hr>
<h3 id="5-优化和修复：代码修复与内存优化"><a href="#5-优化和修复：代码修复与内存优化" class="headerlink" title="5. 优化和修复：代码修复与内存优化"></a><strong>5. 优化和修复：代码修复与内存优化</strong></h3><h4 id="5-1-优化代码中的内存使用"><a href="#5-1-优化代码中的内存使用" class="headerlink" title="5.1 优化代码中的内存使用"></a>5.1 优化代码中的内存使用</h4><ul>
<li><p><strong>修复内存泄漏</strong>：</p>
<ul>
<li>及时释放长生命周期的对象引用，如静态集合、线程局部变量（<code>ThreadLocal.remove()</code>）。</li>
<li>避免在长时间运行的服务中累积不必要的对象，如缓存过多或会话对象未及时清理。</li>
</ul>
</li>
<li><p><strong>优化大数据处理</strong>：</p>
<ul>
<li>对大数据进行分页处理或使用流式（<code>stream</code>）处理，而不是一次性将大量数据加载到内存。</li>
<li>在文件处理时，避免一次性加载整个文件到内存，而是分块读取。</li>
</ul>
</li>
</ul>
<h4 id="5-2-调整-JVM-参数"><a href="#5-2-调整-JVM-参数" class="headerlink" title="5.2 调整 JVM 参数"></a>5.2 调整 JVM 参数</h4><ul>
<li><p><strong>增加堆大小</strong>：如果应用确实需要大量堆内存，可以增加堆的初始值（<code>-Xms</code>）和最大值（<code>-Xmx</code>）。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-Xms1g -Xmx4g<br></code></pre></td></tr></table></figure></li>
<li><p><strong>增加元空间</strong>：如果 OOM 是由于元空间（Metaspace）不足导致的，可以增加元空间的大小：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=512m<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="5-3-使用更合适的-GC-策略"><a href="#5-3-使用更合适的-GC-策略" class="headerlink" title="5.3 使用更合适的 GC 策略"></a>5.3 使用更合适的 GC 策略</h4><ul>
<li>如果应用存在高并发或大内存需求，可以考虑切换到 <strong>G1 GC</strong>，它能在较大堆内存中更好地控制停顿时间：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-XX:+UseG1GC<br></code></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="6-验证与发布：线上测试和灰度发布"><a href="#6-验证与发布：线上测试和灰度发布" class="headerlink" title="6. 验证与发布：线上测试和灰度发布"></a><strong>6. 验证与发布：线上测试和灰度发布</strong></h3><h4 id="6-1-压力测试和验证"><a href="#6-1-压力测试和验证" class="headerlink" title="6.1 压力测试和验证"></a>6.1 压力测试和验证</h4><ul>
<li>在修复和优化完成后，通过 <strong>JMeter</strong> 或 <strong>Gatling</strong> 等工具进行压力测试，验证内存使用是否得到控制，是否有新的 OOM 或 SOF 问题。</li>
<li>通过 <strong>JConsole</strong> 或 <strong>VisualVM</strong> 监控堆内存使用情况，观察垃圾回收频率是否降低，内存曲线是否平稳。</li>
</ul>
<h4 id="6-2-灰度发布与监控"><a href="#6-2-灰度发布与监控" class="headerlink" title="6.2 灰度发布与监控"></a>6.2 灰度发布与监控</h4><ul>
<li>在验证通过后，进行 <strong>灰度发布</strong>。选择部分节点或用户群体，逐步将新版本推向线上，观察是否还有内存溢出或性能问题。</li>
<li>持续监控内存使用、GC 日志和应用性能，确保问题彻底解决。</li>
</ul>
<h4 id="6-3-最终发布"><a href="#6-3-最终发布" class="headerlink" title="6.3 最终发布"></a>6.3 最终发布</h4><ul>
<li>当灰度发布验证成功后，可以将修复后的版本全量发布到生产环境，同时保持监控以防止新的内存问题发生。</li>
</ul>
<hr>
<h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>线上 OOM 问题的排查和解决需要一个系统化的流程，确保在问题发生时能够快速响应和准确定位。具体步骤如下：</p>
<ol>
<li><strong>监控报警</strong>：监控内存使用、GC 频率，及时触发告警。</li>
<li><strong>日志检查</strong>：通过应用日志、GC 日志初步确认问题。</li>
<li><strong>获取数据</strong>：生成并分析堆转储文件，确定内存占用情况和泄漏原因。</li>
<li><strong>问题定位</strong>：结合代码和工具分析，查找内存泄漏或不合理的内存使用。</li>
<li><strong>代码优化</strong>：修复泄漏、优化缓存策略、调整 JVM 参数。</li>
<li><strong>验证发布</strong>：通过压测和灰度发布，确保问题彻底解决。</li>
</ol>
<hr>
<h2 id="通过命令行分析-OOM-问题的流程"><a href="#通过命令行分析-OOM-问题的流程" class="headerlink" title="通过命令行分析 OOM 问题的流程"></a>通过命令行分析 OOM 问题的流程</h2><p>在服务器上通过命令分析 OutOfMemoryError (OOM)，通常需要借助 <strong>JVM 自带的工具</strong> 和 <strong>操作系统的监控命令</strong> 来进行内存问题的排查。以下是常见的步骤和工具，用于分析线上 OOM 问题。</p>
<hr>
<h3 id="1-确保-JVM-参数正确设置"><a href="#1-确保-JVM-参数正确设置" class="headerlink" title="1. 确保 JVM 参数正确设置"></a><strong>1. 确保 JVM 参数正确设置</strong></h3><p>首先，确保 JVM 已经配置了在 OOM 发生时自动生成 <strong>堆转储文件</strong> 和 <strong>GC 日志</strong>，这样可以保留发生问题时的详细内存信息。</p>
<h4 id="关键-JVM-参数设置："><a href="#关键-JVM-参数设置：" class="headerlink" title="关键 JVM 参数设置："></a><strong>关键 JVM 参数设置：</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/path/to/heapdump.hprof<br>-XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:/path/to/gc.log<br></code></pre></td></tr></table></figure>

<ul>
<li><code>HeapDumpOnOutOfMemoryError</code>：在 OOM 发生时生成 <strong>堆转储文件</strong>（heap dump），用于分析内存问题。</li>
<li><code>HeapDumpPath</code>：指定堆转储文件的保存路径。</li>
<li><code>PrintGCDetails</code> 和 <code>Xloggc</code>：输出详细的 GC 日志，帮助分析 GC 相关问题。</li>
</ul>
<hr>
<h3 id="2-使用命令分析-JVM-内存状况"><a href="#2-使用命令分析-JVM-内存状况" class="headerlink" title="2. 使用命令分析 JVM 内存状况"></a><strong>2. 使用命令分析 JVM 内存状况</strong></h3><h4 id="2-1-使用-jmap-命令生成堆转储"><a href="#2-1-使用-jmap-命令生成堆转储" class="headerlink" title="2.1 使用 jmap 命令生成堆转储"></a><strong>2.1 使用 <code>jmap</code> 命令生成堆转储</strong></h4><p><code>jmap</code> 工具可以生成当前运行 JVM 进程的 <strong>堆转储文件</strong>，你可以在 OOM 发生前后手动获取。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jmap -dump:format=b,file=/path/to/dumpfile.hprof &lt;pid&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>format=b</code>：表示生成二进制格式的 dump 文件。</li>
<li><code>file</code>：指定保存堆转储文件的路径。</li>
<li><code>&lt;pid&gt;</code>：需要分析的 JVM 进程的 PID，可以通过 <code>jps</code> 或 <code>ps</code> 命令获取。</li>
</ul>
<h4 id="2-2-使用-jmap-查看堆内存分布"><a href="#2-2-使用-jmap-查看堆内存分布" class="headerlink" title="2.2 使用 jmap 查看堆内存分布"></a><strong>2.2 使用 <code>jmap</code> 查看堆内存分布</strong></h4><p>除了生成 dump 文件，<code>jmap</code> 还可以查看堆内存的分布情况，帮助快速定位问题。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jmap -heap &lt;pid&gt;<br></code></pre></td></tr></table></figure>

<p>输出的内容包括：</p>
<ul>
<li>当前使用的垃圾收集器类型。</li>
<li>年轻代（Young Generation）、老年代（Old Generation）和元空间（Metaspace）的内存分配情况。</li>
</ul>
<h4 id="2-3-使用-jstat-监控-GC-情况"><a href="#2-3-使用-jstat-监控-GC-情况" class="headerlink" title="2.3 使用 jstat 监控 GC 情况"></a><strong>2.3 使用 <code>jstat</code> 监控 GC 情况</strong></h4><p><code>jstat</code> 工具可以实时监控 JVM 的 GC 活动，帮助你分析是否有过频繁的垃圾回收，或 GC 效率低下的问题。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jstat -gc &lt;pid&gt; 1000 10<br></code></pre></td></tr></table></figure>

<ul>
<li><code>&lt;pid&gt;</code>：JVM 进程的 PID。</li>
<li><code>1000</code>：每 1000 毫秒（1 秒）输出一次。</li>
<li><code>10</code>：输出 10 次 GC 信息。</li>
</ul>
<p>输出结果包括：</p>
<ul>
<li>年轻代、老年代、元空间的使用情况。</li>
<li>垃圾回收的次数和时间。</li>
</ul>
<h4 id="2-4-使用-jstack-查看线程堆栈"><a href="#2-4-使用-jstack-查看线程堆栈" class="headerlink" title="2.4 使用 jstack 查看线程堆栈"></a><strong>2.4 使用 <code>jstack</code> 查看线程堆栈</strong></h4><p>如果你怀疑 OOM 是由于线程问题引起的（如线程数过多、死锁等），可以使用 <code>jstack</code> 来查看 JVM 进程的 <strong>线程堆栈信息</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jstack &lt;pid&gt; &gt; /path/to/thread_dump.txt<br></code></pre></td></tr></table></figure>

<ul>
<li>这会生成当前所有线程的堆栈信息，有助于分析是否有线程阻塞、死锁，或线程数过多导致 OOM。</li>
</ul>
<h4 id="2-5-使用-jmap-查看内存对象"><a href="#2-5-使用-jmap-查看内存对象" class="headerlink" title="2.5 使用 jmap 查看内存对象"></a><strong>2.5 使用 <code>jmap</code> 查看内存对象</strong></h4><p>使用 <code>jmap</code> 的 <code>-histo</code> 参数，可以快速查看 JVM 内存中各类对象的数量和占用内存情况，帮助分析哪个对象占用了过多内存。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jmap -histo &lt;pid&gt; | <span class="hljs-built_in">head</span> -n 20<br></code></pre></td></tr></table></figure>

<ul>
<li>输出的结果显示对象类型、实例数量和占用的字节数，可以帮助你找出哪些对象占用最多内存。</li>
</ul>
<hr>
<h3 id="3-结合操作系统工具分析内存问题"><a href="#3-结合操作系统工具分析内存问题" class="headerlink" title="3. 结合操作系统工具分析内存问题"></a><strong>3. 结合操作系统工具分析内存问题</strong></h3><p>有时 OOM 问题不仅仅与 JVM 内存有关，也可能是由于操作系统级别的内存不足导致的。因此，可以结合 <strong>操作系统命令</strong> 进一步分析服务器的整体内存和资源状况。</p>
<h4 id="3-1-使用-top-命令监控内存和-CPU"><a href="#3-1-使用-top-命令监控内存和-CPU" class="headerlink" title="3.1 使用 top 命令监控内存和 CPU"></a><strong>3.1 使用 <code>top</code> 命令监控内存和 CPU</strong></h4><p><code>top</code> 命令可以实时查看系统的资源使用情况，帮助确认是否有其他进程占用了大量内存或 CPU。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">top<br></code></pre></td></tr></table></figure>

<ul>
<li>重点关注 JVM 进程的 <strong>内存使用情况</strong>（RES 列）和 <strong>CPU 占用情况</strong>。</li>
<li>可以通过按 <code>M</code> 键按照内存占用排序，按 <code>P</code> 键按照 CPU 占用排序。</li>
</ul>
<h4 id="3-2-使用-free-命令查看系统内存"><a href="#3-2-使用-free-命令查看系统内存" class="headerlink" title="3.2 使用 free 命令查看系统内存"></a><strong>3.2 使用 <code>free</code> 命令查看系统内存</strong></h4><p><code>free</code> 命令可以查看系统总内存、已使用内存和可用内存的情况。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">free -h<br></code></pre></td></tr></table></figure>

<ul>
<li>重点关注 <strong>free</strong> 和 <strong>available</strong> 列，确认系统是否整体内存不足。</li>
</ul>
<h4 id="3-3-使用-ps-命令查看内存占用"><a href="#3-3-使用-ps-命令查看内存占用" class="headerlink" title="3.3 使用 ps 命令查看内存占用"></a><strong>3.3 使用 <code>ps</code> 命令查看内存占用</strong></h4><p>如果怀疑是 JVM 进程本身的内存占用问题，可以使用 <code>ps</code> 命令查看具体进程的内存和 CPU 占用情况。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps aux | grep java<br></code></pre></td></tr></table></figure>

<ul>
<li>这会列出所有运行的 Java 进程，显示内存占用（%MEM 列）和 CPU 占用（%CPU 列）。</li>
</ul>
<hr>
<h3 id="4-分析-GC-日志"><a href="#4-分析-GC-日志" class="headerlink" title="4. 分析 GC 日志"></a><strong>4. 分析 GC 日志</strong></h3><p>在 JVM 中，GC 日志是了解垃圾回收行为、内存使用状况的关键。你可以通过分析 GC 日志，确认是否是由于 GC 过于频繁或回收效果不佳导致的 OOM。</p>
<h4 id="GC-日志分析重点："><a href="#GC-日志分析重点：" class="headerlink" title="GC 日志分析重点："></a><strong>GC 日志分析重点</strong>：</h4><ol>
<li><p><strong>GC 类型</strong>：</p>
<ul>
<li>Minor GC（年轻代回收）频率过高可能表明对象生命周期过短，导致频繁分配和回收。</li>
<li>Full GC 频繁，可能表明老年代内存不足，无法承载新的晋升对象。</li>
</ul>
</li>
<li><p><strong>GC 时间</strong>：</p>
<ul>
<li>每次 GC 的停顿时间是否过长（STW 时间）。</li>
<li>如果 Full GC 占用了大量时间，且效果不佳，则需要考虑调整堆大小或使用更合适的垃圾回收器（如 G1 GC）。</li>
</ul>
</li>
<li><p><strong>内存分配</strong>：</p>
<ul>
<li>在 GC 之前和之后，年轻代、老年代的内存使用变化情况，判断是否回收成功。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="5-使用-Eclipse-MAT-或-VisualVM-分析堆转储"><a href="#5-使用-Eclipse-MAT-或-VisualVM-分析堆转储" class="headerlink" title="5. 使用 Eclipse MAT 或 VisualVM 分析堆转储"></a><strong>5. 使用 <code>Eclipse MAT</code> 或 <code>VisualVM</code> 分析堆转储</strong></h3><p>生成的 <strong>堆转储文件（heap dump）</strong> 可以下载到本地，使用工具进行详细分析。常用的分析工具包括：</p>
<ul>
<li>**Eclipse MAT (Memory Analyzer Tool)**：帮助你识别 <strong>内存泄漏</strong> 和 <strong>大对象</strong>，生成“泄漏嫌疑报告”。</li>
<li><strong>VisualVM</strong>：可用于分析堆转储文件，并结合实时的 JVM 性能监控。</li>
</ul>
<h4 id="堆转储分析重点："><a href="#堆转储分析重点：" class="headerlink" title="堆转储分析重点："></a><strong>堆转储分析重点</strong>：</h4><ol>
<li><strong>大对象</strong>：查找内存占用最多的对象（Top Consumers）。</li>
<li><strong>泄漏对象</strong>：查看是否有大量对象被持有但无法释放，特别是静态集合类。</li>
<li><strong>对象引用链</strong>：检查哪些对象在堆中被引用而无法回收。</li>
</ol>
<hr>
<h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>通过命令行分析 OOM 问题的流程通常包括：</p>
<ol>
<li><strong>设置 JVM 参数</strong> 以确保堆转储和 GC 日志在 OOM 发生时保存。</li>
<li>使用 <strong><code>jmap</code>、<code>jstat</code>、<code>jstack</code> 等工具</strong> 生成堆转储、查看内存分布和线程信息。</li>
<li>结合 <strong><code>top</code>、<code>free</code>、<code>ps</code> 等操作系统命令</strong> 确认服务器整体的资源状况。</li>
<li><strong>分析 GC 日志</strong>，查看垃圾回收频率和效果。</li>
<li><strong>使用工具分析堆转储文件</strong>，找出内存泄漏或大对象问题。</li>
</ol>
<p>这些步骤可以帮助你有效地排查和解决线上 OOM 问题。</p>
<hr>
<h2 id="Java-8-引入元空间的主要目的"><a href="#Java-8-引入元空间的主要目的" class="headerlink" title="Java 8 引入元空间的主要目的"></a>Java 8 引入元空间的主要目的</h2><p>在 Java 8 之前，JVM 使用的 <strong>方法区（Method Area）</strong> 存储类的元数据、静态变量、常量池等，具体的实现是 <strong>永久代（PermGen，Permanent Generation）</strong>。Java 8 引入了 <strong>元空间（Metaspace）</strong>，用来替代永久代，并对类的元数据存储进行了改进。</p>
<h3 id="1-永久代（PermGen）在-Java-7-及之前"><a href="#1-永久代（PermGen）在-Java-7-及之前" class="headerlink" title="1. 永久代（PermGen）在 Java 7 及之前"></a>1. <strong>永久代（PermGen）在 Java 7 及之前</strong></h3><ul>
<li><strong>类元数据</strong>：存储类的元数据信息，如类名、类加载器、字段、方法、接口、常量池等。</li>
<li><strong>静态变量</strong>：类的静态变量也保存在永久代中。</li>
<li><strong>常量池</strong>：字符串常量池（在JAVA6及之前）、方法的常量池等信息存储在永久代。</li>
<li><strong>类加载信息</strong>：类的加载和卸载信息也在永久代中保存。</li>
</ul>
<p>永久代的大小是固定的，随着应用运行时动态加载的类、字符串等增加，可能会导致内存溢出（<code>OutOfMemoryError: PermGen space</code>），这是 Java 7 及之前版本的一个常见问题。</p>
<h3 id="2-元空间（Metaspace）在-Java-8-及之后"><a href="#2-元空间（Metaspace）在-Java-8-及之后" class="headerlink" title="2. 元空间（Metaspace）在 Java 8 及之后"></a>2. <strong>元空间（Metaspace）在 Java 8 及之后</strong></h3><p>Java 8 引入了元空间来替代永久代，主要区别在于：</p>
<ul>
<li><strong>类元数据存储在元空间</strong>：在 Java 8 中，类的元数据（如类名、字段、方法、接口、常量池等）从方法区（即永久代）转移到元空间（Metaspace）中。</li>
<li><strong>使用本地内存（Native Memory）</strong>：与永久代不同，元空间不再使用堆内存，而是使用本地内存（即操作系统提供的内存）。因此，元空间的大小仅受限于系统可用内存，而不再是 JVM 固定大小的限制。</li>
<li><strong>字符串常量池移至堆内存</strong>：Java 7 就已经将字符串常量池从永久代移到了堆内存中，Java 8 保持了这一点。字符串常量和常量池中的符号等信息现在存储在堆中。</li>
<li><strong>静态变量仍然存储在堆内存</strong>：类的静态变量从永久代移到了堆内存中。</li>
</ul>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. <strong>总结</strong></h3><ul>
<li><strong>类元数据</strong>：Java 8 之后，类的元数据从永久代转移到元空间，存储在本地内存中，元空间不再受 JVM 固定大小限制，而是由操作系统的内存管理。</li>
<li><strong>静态变量</strong>：静态变量现在存储在堆中，而不是方法区。</li>
<li><strong>字符串常量池</strong>：Java 7 就已经把字符串常量池移到了堆中，Java 8 继续保持这一变化。</li>
</ul>
<p>Java 8 引入元空间的主要目的就是为了提高类元数据的存储效率，并解决永久代内存溢出的问题。</p>
<hr>
<h2 id="AIO、BIO、NIO的区别"><a href="#AIO、BIO、NIO的区别" class="headerlink" title="AIO、BIO、NIO的区别"></a>AIO、BIO、NIO的区别</h2><p>在 Java 中，IO（输入输出）操作可以通过不同的模型实现。主要有 <strong>BIO</strong>（阻塞 IO）、<strong>NIO</strong>（非阻塞 IO） 和 <strong>AIO</strong>（异步 IO）。它们的主要区别在于处理 IO 操作的方式、线程模型和并发性。</p>
<h3 id="1-BIO（Blocking-IO，阻塞-IO）"><a href="#1-BIO（Blocking-IO，阻塞-IO）" class="headerlink" title="1. BIO（Blocking IO，阻塞 IO）"></a><strong>1. BIO（Blocking IO，阻塞 IO）</strong></h3><h4 id="工作原理：-2"><a href="#工作原理：-2" class="headerlink" title="工作原理："></a><strong>工作原理：</strong></h4><ul>
<li><strong>阻塞模式</strong>：当线程进行 IO 操作时，如果没有数据可读，或者数据还没有准备好，线程会被阻塞，直到 IO 操作完成。</li>
<li><strong>一个线程处理一个连接</strong>：BIO 模型通常采用一个线程处理一个请求的方式，每个客户端请求需要分配一个独立的线程进行处理。</li>
<li><strong>同步</strong>：IO 操作是同步的，线程必须等待数据的到来或者发送完成。</li>
</ul>
<h4 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a><strong>使用场景：</strong></h4><ul>
<li>适用于<strong>连接数少</strong>且<strong>业务处理量小</strong>的场景，如传统的 Web 应用程序。</li>
<li>简单直接，但当并发请求多时，会由于线程资源的开销导致性能下降。</li>
</ul>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a><strong>示例：</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">8080</span>);<br><span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept(); <span class="hljs-comment">// 阻塞，直到有客户端连接</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> socket.getInputStream(); <span class="hljs-comment">// 阻塞，直到有数据可读</span><br></code></pre></td></tr></table></figure>

<h4 id="特点：-2"><a href="#特点：-2" class="headerlink" title="特点："></a><strong>特点：</strong></h4><ul>
<li><strong>阻塞</strong>：线程在等待 IO 操作完成时会阻塞。</li>
<li><strong>线程模型复杂</strong>：每个连接需要一个独立的线程来处理，因此对于高并发场景，需要大量线程，导致线程开销大。</li>
</ul>
<hr>
<h3 id="2-NIO（Non-blocking-IO，非阻塞-IO）"><a href="#2-NIO（Non-blocking-IO，非阻塞-IO）" class="headerlink" title="2. NIO（Non-blocking IO，非阻塞 IO）"></a><strong>2. NIO（Non-blocking IO，非阻塞 IO）</strong></h3><h4 id="工作原理：-3"><a href="#工作原理：-3" class="headerlink" title="工作原理："></a><strong>工作原理：</strong></h4><ul>
<li><strong>非阻塞模式</strong>：线程可以对通道（<code>Channel</code>）进行非阻塞的读写操作。即使没有数据可用，线程也不会被阻塞，它会继续执行其他操作。</li>
<li><strong>多路复用</strong>：NIO 使用 <code>Selector</code> 来监听多个通道的事件，通过一个线程可以处理多个连接。</li>
<li><strong>缓冲区</strong>：NIO 通过 <code>Buffer</code> 来读写数据，所有的数据都是通过缓冲区进行传递。</li>
<li><strong>同步</strong>：尽管是非阻塞的，IO 操作仍然是同步的，应用程序需要自己轮询检查 IO 操作的状态。</li>
</ul>
<h4 id="使用场景：-1"><a href="#使用场景：-1" class="headerlink" title="使用场景："></a><strong>使用场景：</strong></h4><ul>
<li>适用于<strong>高并发</strong>、<strong>长连接</strong>的场景，如聊天室、游戏服务器。</li>
<li>通过少量线程可以处理大量客户端连接。</li>
</ul>
<h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a><strong>示例：</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br><span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">serverSocketChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>serverSocketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);<br><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    selector.select(); <span class="hljs-comment">// 阻塞等待事件</span><br>    Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();<br>    <span class="hljs-keyword">for</span> (SelectionKey key : selectedKeys) &#123;<br>        <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>            <span class="hljs-comment">// 处理新连接</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>            <span class="hljs-comment">// 处理读事件</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="特点：-3"><a href="#特点：-3" class="headerlink" title="特点："></a><strong>特点：</strong></h4><ul>
<li><strong>非阻塞</strong>：线程可以立即返回，并处理其他任务，而不需要等待 IO 操作完成。</li>
<li><strong>少量线程处理大量连接</strong>：通过 <code>Selector</code> 和 <code>Channel</code>，一个线程可以同时处理多个连接，避免了 BIO 中线程资源的浪费。</li>
<li><strong>复杂性更高</strong>：需要管理 <code>Selector</code>、<code>Channel</code>、<code>Buffer</code> 等，开发复杂度增加。</li>
</ul>
<hr>
<h3 id="3-AIO（Asynchronous-IO，异步-IO）"><a href="#3-AIO（Asynchronous-IO，异步-IO）" class="headerlink" title="3. AIO（Asynchronous IO，异步 IO）"></a><strong>3. AIO（Asynchronous IO，异步 IO）</strong></h3><h4 id="工作原理：-4"><a href="#工作原理：-4" class="headerlink" title="工作原理："></a><strong>工作原理：</strong></h4><ul>
<li><strong>异步模式</strong>：AIO 是完全异步的 IO 操作，线程发起 IO 请求后立即返回，系统会在操作完成时通过回调机制通知应用程序。</li>
<li><strong>回调机制</strong>：当数据可用或 IO 操作完成时，系统会自动触发回调函数，不需要像 NIO 一样轮询事件。</li>
<li><strong>异步且非阻塞</strong>：线程在发起操作后立即返回，不会等待操作完成，且操作完成后由操作系统负责通知。</li>
</ul>
<h4 id="使用场景：-2"><a href="#使用场景：-2" class="headerlink" title="使用场景："></a><strong>使用场景：</strong></h4><ul>
<li>适用于<strong>大量 IO 操作</strong>且<strong>长时间等待</strong>的场景，如高性能 Web 服务器。</li>
<li>在 IO 密集型和高并发的应用场景中表现出色。</li>
</ul>
<h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a><strong>示例：</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">AsynchronousServerSocketChannel</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> AsynchronousServerSocketChannel.open();<br>server.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>server.accept(<span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletionHandler</span>&lt;AsynchronousSocketChannel, Object&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">completed</span><span class="hljs-params">(AsynchronousSocketChannel result, Object attachment)</span> &#123;<br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>        result.read(buffer, buffer, <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">completed</span><span class="hljs-params">(Integer result, ByteBuffer attachment)</span> &#123;<br>                <span class="hljs-comment">// 处理读取的数据</span><br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">failed</span><span class="hljs-params">(Throwable exc, ByteBuffer attachment)</span> &#123;<br>                <span class="hljs-comment">// 处理失败</span><br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">failed</span><span class="hljs-params">(Throwable exc, Object attachment)</span> &#123;<br>        <span class="hljs-comment">// 处理失败</span><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<h4 id="特点：-4"><a href="#特点：-4" class="headerlink" title="特点："></a><strong>特点：</strong></h4><ul>
<li><strong>异步非阻塞</strong>：完全异步，通过回调处理结果，线程在发起操作后不会阻塞。</li>
<li><strong>线程效率高</strong>：线程在 IO 操作期间无需阻塞，操作系统负责完成 IO 操作，并通过回调通知应用程序。</li>
<li><strong>开发难度更高</strong>：AIO 的编程模型比 NIO 更复杂，因为需要处理回调函数和异步结果。</li>
</ul>
<hr>
<h3 id="总结对比"><a href="#总结对比" class="headerlink" title="总结对比"></a><strong>总结对比</strong></h3><table>
<thead>
<tr>
<th>特点</th>
<th>BIO（阻塞 IO）</th>
<th>NIO（非阻塞 IO）</th>
<th>AIO（异步 IO）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>编程模型</strong></td>
<td>一个线程处理一个请求</td>
<td>一个线程处理多个请求</td>
<td>操作完成后通过回调通知</td>
</tr>
<tr>
<td><strong>阻塞性</strong></td>
<td>阻塞 IO</td>
<td>非阻塞 IO</td>
<td>异步非阻塞 IO</td>
</tr>
<tr>
<td><strong>线程开销</strong></td>
<td>高（每个连接一个线程）</td>
<td>低（少量线程处理大量连接）</td>
<td>低（异步处理，回调机制）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>连接数较少的应用场景</td>
<td>高并发场景</td>
<td>高并发、高 IO 操作场景</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>低</td>
<td>中等</td>
<td>高</td>
</tr>
<tr>
<td><strong>复杂度</strong></td>
<td>低（简单明了）</td>
<td>中等（需要管理 Selector）</td>
<td>高（需要处理回调）</td>
</tr>
</tbody></table>
<hr>
<h3 id="选择使用场景"><a href="#选择使用场景" class="headerlink" title="选择使用场景"></a><strong>选择使用场景</strong></h3><ul>
<li><strong>BIO</strong>：适用于<strong>小型应用</strong>，连接数少、简单、容易使用，但不适合高并发场景。</li>
<li><strong>NIO</strong>：适合<strong>高并发场景</strong>，例如聊天室、服务器端应用。通过 <code>Selector</code> 实现多路复用，减少线程开销。</li>
<li><strong>AIO</strong>：适用于<strong>超高并发和 IO 密集型应用</strong>，例如高性能的 Web 服务器。AIO 由于使用异步回调机制，可以有效提升系统的并发处理能力。</li>
</ul>
<hr>
<h2 id="红黑树有哪几个特征"><a href="#红黑树有哪几个特征" class="headerlink" title="红黑树有哪几个特征"></a>红黑树有哪几个特征</h2><p>红黑树（Red-Black Tree）是一种 <strong>自平衡的二叉搜索树</strong>（<code>左孩子节点 &lt; 父节点，右孩子节点 &gt; 父节点</code>），它的特点在于通过对树进行颜色标记（红色或黑色）和旋转操作，保证树的高度始终保持在对数级别，从而保证搜索、插入、删除等操作的时间复杂度为 (O(\log n))。红黑树有以下几个主要特征：</p>
<h3 id="红黑树的五大特征："><a href="#红黑树的五大特征：" class="headerlink" title="红黑树的五大特征："></a>红黑树的五大特征：</h3><ol>
<li><strong>节点要么是红色，要么是黑色</strong>。</li>
</ol>
<ul>
<li>每个节点都被标记为红色或黑色，这种标记用于维持树的平衡。</li>
</ul>
<ol start="2">
<li><strong>根节点必须是黑色</strong>。</li>
</ol>
<ul>
<li>红黑树的根节点始终是黑色的，这是为了保持红黑树的平衡性。</li>
</ul>
<ol start="3">
<li><strong>每个叶子节点（NIL）都是黑色</strong>。</li>
</ol>
<ul>
<li>红黑树中的叶子节点通常指的是<strong>空节点（NIL 节点）</strong>，这些 NIL 节点也必须是黑色的。为了统一处理，红黑树通常会将每个实际的叶子节点的两个空子节点都视为黑色的 NIL 节点。</li>
</ul>
<ol start="4">
<li><strong>红色节点的子节点必须是黑色（不能有连续的红色节点）</strong>。</li>
</ol>
<ul>
<li>红色节点的两个子节点必须是黑色的，反之黑色节点可以有红色子节点或黑色子节点。这一特性保证了从根到叶子的路径上不会出现连续的红色节点，确保树不会出现太高的不平衡。</li>
</ul>
<ol start="5">
<li><strong>从任一节点到其每个叶子节点的所有路径上都包含相同数量的黑色节点</strong>（<strong>黑高平衡性</strong>）。</li>
</ol>
<ul>
<li>这个特性称为 <strong>黑色平衡</strong>，它确保了从根节点到每个叶子节点路径上的黑色节点数量相同，从而限制了树的高度。</li>
</ul>
<h3 id="红黑树的自平衡特性："><a href="#红黑树的自平衡特性：" class="headerlink" title="红黑树的自平衡特性："></a>红黑树的自平衡特性：</h3><ul>
<li>通过旋转操作（左旋、右旋）和重新染色操作，红黑树保持平衡性，使得任何插入和删除操作后，红黑树仍然满足上述五大特征。</li>
<li>红黑树的高度始终保持在 (O(\log n))，这使得红黑树在最坏情况下的查找、插入和删除操作的时间复杂度都是 (O(\log n))。</li>
</ul>
<h3 id="红黑树的优点："><a href="#红黑树的优点：" class="headerlink" title="红黑树的优点："></a>红黑树的优点：</h3><ul>
<li>平衡性能：相对于普通的二叉搜索树（BST），红黑树通过自平衡机制避免了退化成链表的情况。</li>
<li>较为简单：与 AVL 树相比，红黑树的插入和删除操作的调整步骤较少，因此更容易实现和维护。</li>
</ul>
<hr>
<h2 id="红黑树的旋转操作和重新染色操作"><a href="#红黑树的旋转操作和重新染色操作" class="headerlink" title="红黑树的旋转操作和重新染色操作"></a>红黑树的旋转操作和重新染色操作</h2><p>在红黑树中，<strong>旋转操作</strong>（左旋、右旋）和<strong>重新染色操作</strong>是为了保持红黑树的平衡性和遵守红黑树的五大特征。这两类操作通常在<strong>插入</strong>和<strong>删除</strong>节点时使用，目的是恢复红黑树的性质。下面详细介绍这些操作的原理。</p>
<h3 id="1-旋转操作"><a href="#1-旋转操作" class="headerlink" title="1. 旋转操作"></a>1. <strong>旋转操作</strong></h3><p>旋转操作是红黑树保持平衡的重要手段。通过<strong>左旋</strong>和<strong>右旋</strong>，可以改变树的结构，从而使树的高度保持相对平衡。旋转操作分为两种：</p>
<h4 id="1-1-左旋（Left-Rotation）"><a href="#1-1-左旋（Left-Rotation）" class="headerlink" title="1.1 左旋（Left Rotation）"></a><strong>1.1 左旋（Left Rotation）</strong></h4><p>左旋是针对某个节点执行的操作，目的是将该节点变成它右子节点的左子节点，而右子节点上升为父节点。左旋的具体操作步骤如下：</p>
<ul>
<li>设 <code>x</code> 为需要左旋的节点，<code>y</code> 为 <code>x</code> 的右子节点。</li>
<li>将 <code>y</code> 的左子节点（如果存在）设为 <code>x</code> 的右子节点（即让 <code>x</code> 接管 <code>y</code> 的左子树）。</li>
<li><code>y</code> 成为 <code>x</code> 的父节点，<code>x</code> 成为 <code>y</code> 的左子节点。</li>
</ul>
<h4 id="左旋示例："><a href="#左旋示例：" class="headerlink" title="左旋示例："></a><strong>左旋示例：</strong></h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">x                       y<br> \        左旋          /<br>  y       ===&gt;         x<br> /                      \<br>T3                      T3<br></code></pre></td></tr></table></figure>

<ul>
<li><code>x</code> 的右子节点 <code>y</code> 被提升为父节点，<code>y</code> 的左子树 <code>T3</code> 成为 <code>x</code> 的右子树。</li>
</ul>
<h4 id="1-2-右旋（Right-Rotation）"><a href="#1-2-右旋（Right-Rotation）" class="headerlink" title="1.2 右旋（Right Rotation）"></a><strong>1.2 右旋（Right Rotation）</strong></h4><p>右旋是针对某个节点执行的操作，与左旋相反。右旋的目的是将该节点变成它的左子节点的右子节点，而左子节点上升为父节点。右旋的具体操作步骤如下：</p>
<ul>
<li>设 <code>y</code> 为需要右旋的节点，<code>x</code> 为 <code>y</code> 的左子节点。</li>
<li>将 <code>x</code> 的右子节点（如果存在）设为 <code>y</code> 的左子节点（即让 <code>y</code> 接管 <code>x</code> 的右子树）。</li>
<li><code>x</code> 成为 <code>y</code> 的父节点，<code>y</code> 成为 <code>x</code> 的右子节点。</li>
</ul>
<h4 id="右旋示例："><a href="#右旋示例：" class="headerlink" title="右旋示例："></a><strong>右旋示例：</strong></h4><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">  y                     x<br> /        右旋            \<br>x         ===&gt;            y<br> \                       /<br>  T3                    T3<br></code></pre></td></tr></table></figure>

<ul>
<li><code>y</code> 的左子节点 <code>x</code> 被提升为父节点，<code>x</code> 的右子树 <code>T3</code> 成为 <code>y</code> 的左子树。</li>
</ul>
<hr>
<h3 id="2-重新染色操作"><a href="#2-重新染色操作" class="headerlink" title="2. 重新染色操作"></a>2. <strong>重新染色操作</strong></h3><p>在红黑树中，<strong>重新染色</strong>是指调整节点的颜色以保持红黑树的五大特征。重新染色通常和旋转操作结合使用，特别是在插入和删除节点后，可能需要根据红黑树的性质调整节点颜色。</p>
<h4 id="2-1-插入时的重新染色"><a href="#2-1-插入时的重新染色" class="headerlink" title="2.1 插入时的重新染色"></a><strong>2.1 插入时的重新染色</strong></h4><p>当插入新节点时，默认将新节点染色为<strong>红色</strong>。插入后，可能会违反红黑树的<strong>特征 4</strong>（红色节点的子节点不能是红色）。这时，需要通过重新染色或旋转操作恢复红黑树的平衡。</p>
<ul>
<li>如果插入节点的父节点是红色，并且父节点的叔叔节点也是红色，那么可以通过将父节点和叔叔节点染成黑色，将祖父节点染成红色，恢复红黑树的平衡。</li>
<li>如果插入节点的父节点是红色，而叔叔节点是黑色，则可能需要旋转操作和重新染色一起完成平衡。</li>
</ul>
<h4 id="2-2-删除时的重新染色"><a href="#2-2-删除时的重新染色" class="headerlink" title="2.2 删除时的重新染色"></a><strong>2.2 删除时的重新染色</strong></h4><p>删除节点时也可能需要重新染色。特别是当删除的节点是黑色时，可能会导致路径上黑色节点数不一致，违反<strong>特征 5</strong>。为了解决这个问题，红黑树会在删除操作时将兄弟节点和父节点重新染色，并结合旋转操作恢复平衡。</p>
<hr>
<h3 id="3-插入时的平衡修复（结合旋转和重新染色）"><a href="#3-插入时的平衡修复（结合旋转和重新染色）" class="headerlink" title="3. 插入时的平衡修复（结合旋转和重新染色）"></a>3. <strong>插入时的平衡修复（结合旋转和重新染色）</strong></h3><p>假设我们插入了一个红色节点，插入后红黑树可能会失去平衡。这时，我们使用旋转和重新染色来修复。以下是插入后的修复规则：</p>
<ol>
<li><strong>父节点是黑色</strong>：不需要做任何调整，因为红黑树仍然满足所有特征。</li>
<li><strong>父节点是红色</strong>：</li>
</ol>
<ul>
<li><strong>叔叔节点是红色</strong>：将父节点和叔叔节点（父节点同一个层级的节点）染成黑色，祖父节点染成红色，然后把祖父节点当作新插入的节点继续检查。</li>
<li><strong>叔叔节点是黑色</strong>：<ul>
<li><strong>新节点是右子节点，父节点是左子节点</strong>：对父节点进行左旋，使情况变成<strong>新节点是左子节点，父节点是左子节点</strong>。</li>
<li><strong>新节点是左子节点，父节点是左子节点</strong>：对祖父节点进行右旋，同时父节点染黑，祖父节点染红。</li>
</ul>
</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ul>
<li><p>插入 [1,2,3]</p>
<div align="left"><img src="https://www.helloimg.com/i/2024/09/14/66e5780cbb8a1.png" alt="插入123" width="30%" height="200">
  ====> <img src="https://www.helloimg.com/i/2024/09/15/66e69c9bb7f64.png" alt="左旋"  width="20%" height="200"/></div>


<p>​                   												父节点在右边，左旋祖父节点1</p>
</li>
<li><p>插入[3,2,1]</p>
<div align="left"><img src="https://www.helloimg.com/i/2024/09/15/66e69ea031698.png" alt="插入321" width="30%" height="200">
  ====> <img src="https://www.helloimg.com/i/2024/09/15/66e69f8c41cf1.png" alt="左旋"  width="30%" height="200"/></div>


<p>​																	父节点在左边，右旋祖父节点3</p>
</li>
</ul>
<h5 id="节点在左边的情况"><a href="#节点在左边的情况" class="headerlink" title="节点在左边的情况"></a>节点在左边的情况</h5><ul>
<li><p>插入10</p>
<div align="left"><img src="https://www.helloimg.com/i/2024/09/15/66e6a02c46346.png" alt="插入10" width="30%" height="200">
  ====> <img src="https://www.helloimg.com/i/2024/09/15/66e6a0887821f.png" alt="左旋"  width="30%" height="200"/> ====> <img src="https://www.helloimg.com/i/2024/09/15/66e6a18026664.png" alt="染色" width="30%" height="200"/></div>


<p>​								插入10，父节点在左边，叔叔节点存在并且为红色，无需旋转						染色</p>
</li>
<li><p>插入20</p>
<div align="left"><img src="https://www.helloimg.com/i/2024/09/15/66e6a3798d343.jpg" alt="插入10" width="30%" height="200">
  ====> <img src="https://www.helloimg.com/i/2024/09/15/66e6a55e1d5da.jpg" alt="左旋"  width="30%" height="200"/> ====> <img src="https://www.helloimg.com/i/2024/09/15/66e6a5e051a5e.png" alt="染色" width="30%" height="200"" /></div>


<p>​										插入20，父节点在左边，左旋新节点							染色父节点和祖父节点，右旋祖父节点23</p>
</li>
</ul>
<h5 id="节点在右边的情况"><a href="#节点在右边的情况" class="headerlink" title="节点在右边的情况"></a>节点在右边的情况</h5><ul>
<li><p>插入98</p>
<div align="left"><img src="https://www.helloimg.com/i/2024/09/15/66e6a6eb499f9.png" alt="插入10" width="30%" height="200">
  ====> <img src="https://www.helloimg.com/i/2024/09/15/66e6a7361fdcd.png" alt="左旋"  width="30%" height="200"/> ====> <img src="https://www.helloimg.com/i/2024/09/15/66e6a86fb32e5.png" alt="染色" width="30%" height="200"" /></div>


<p>​													叔叔节点存在并为红色，无需旋转												  染色</p>
</li>
<li><p>插入42</p>
<div align="left"><img src="https://www.helloimg.com/i/2024/09/15/66e6a8aa6aab1.png" alt="插入10" width="30%" height="200">
  ====> <img src="https://www.helloimg.com/i/2024/09/15/66e6a95784e94.png" alt="左旋"  width="30%" height="200"/> ====> <img src="https://www.helloimg.com/i/2024/09/15/66e6aa14584d9.jpg" alt="染色" width="30%" height="200" /></div>


<p>​											父节点在右边，新节点在左边，右旋											染色并左旋祖父节点6</p>
</li>
</ul>
<h3 id="4-删除时的平衡修复（结合旋转和重新染色）"><a href="#4-删除时的平衡修复（结合旋转和重新染色）" class="headerlink" title="4. 删除时的平衡修复（结合旋转和重新染色）"></a>4. <strong>删除时的平衡修复（结合旋转和重新染色）</strong></h3><p>在红黑树中，删除黑色节点可能会导致路径上黑色节点的数量不平衡。这时也需要使用旋转和重新染色操作来恢复平衡。删除修复的规则如下：</p>
<ol>
<li><strong>兄弟节点是红色</strong>：<ul>
<li>将父节点染红，兄弟节点染黑，对父节点进行旋转操作（具体是左旋或右旋，取决于兄弟节点的位置），然后重新调整兄弟节点和父节点的关系。</li>
</ul>
</li>
<li><strong>兄弟节点是黑色，兄弟的子节点也是黑色</strong>：<ul>
<li>将兄弟节点染红，将问题向上移到父节点，并继续检查。</li>
</ul>
</li>
<li><strong>兄弟节点是黑色，兄弟的一个子节点是红色</strong>：<ul>
<li>根据具体情况，通过一次或两次旋转（左旋或右旋）修复，然后重新染色。</li>
</ul>
</li>
</ol>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><h5 id="节点在左边的情况-1"><a href="#节点在左边的情况-1" class="headerlink" title="节点在左边的情况"></a>节点在左边的情况</h5><ul>
<li><p><strong>case1</strong>：兄弟节点是红色，左旋父节点</p>
<ul>
<li>删除 20</li>
</ul>
<div align="left"><img src="https://www.helloimg.com/i/2024/09/15/66e6aacc56db4.png" alt="删除" width="30%" height="200">
  ====> <img src="https://www.helloimg.com/i/2024/09/15/66e6ab491e328.png" alt="左旋"  width="30%" height="200"/> ====> <img src="https://www.helloimg.com/i/2024/09/15/66e6aba61e0ac.png" alt="染色" width="30%" height="200" /></div>


<p>​																																								case1</p>
</li>
<li><p><strong>case2</strong>：兄弟节点的子节点是黑色，不需要做任何调整</p>
<ul>
<li>删除54</li>
</ul>
<div align="left"><img src="https://www.helloimg.com/i/2024/09/15/66e6ac58b58d5.png" alt="删除" width="30%" height="200">
  ====> <img src="https://www.helloimg.com/i/2024/09/15/66e6acd87122c.png" alt="左旋"  width="30%" height="200"/></div>
</li>
<li><p><strong>case3</strong>：兄弟节点的右节点是黑色，右旋兄弟节点</p>
</li>
<li><p><strong>case4</strong>：左旋父节点</p>
<ul>
<li>删除 26</li>
</ul>
<div align="left"><img src="https://www.helloimg.com/i/2024/09/15/66e6acd87122c.png" alt="删除" width="20%" height="200">
  ====> <img src="https://www.helloimg.com/i/2024/09/15/66e6add997e9e.png" alt="左旋"  width="20%" height="200"/> ====> <img src="https://www.helloimg.com/i/2024/09/15/66e6ae6644cb4.png" alt="左旋"  width="20%" height="200"/> ====> <img src="https://www.helloimg.com/i/2024/09/15/66e6af0647a30.png" alt="左旋"  width="20%" height="200"/></div>


<p>​																											case3												     case4</p>
</li>
</ul>
<h5 id="节点在右边的情况-1"><a href="#节点在右边的情况-1" class="headerlink" title="节点在右边的情况"></a>节点在右边的情况</h5><ul>
<li><p><strong>case1</strong>：兄弟节点是红色，右旋父节点48</p>
</li>
<li><p><strong>case2</strong>：兄弟节点的子节点都是黑色，设置父节点43为红色</p>
<ul>
<li>删除54</li>
</ul>
<div align="left"><img src="https://www.helloimg.com/i/2024/09/15/66e6afc90ec47.png" alt="删除" width="20%" height="200">
  ====> <img src="https://www.helloimg.com/i/2024/09/15/66e6b00ddfc3c.png" alt="左旋"  width="20%" height="200"/> ====> <img src="https://www.helloimg.com/i/2024/09/15/66e6b05db2f6e.png" alt="染色" width="20%" height="200" /> ====> <img src="https://www.helloimg.com/i/2024/09/15/66e6b1863c095.png" alt="染色" width="20%" height="200" /></div>
</li>
<li><p><strong>case3</strong>：兄弟节点的左孩子为黑色，左旋兄弟节点</p>
</li>
<li><p><strong>case4</strong>：右旋父节点</p>
<ul>
<li>删除43，48</li>
</ul>
<div align="left"><img src="https://www.helloimg.com/i/2024/09/15/66e6b1863c095.png" alt="删除" width="15%" height="180">
  ====> <img src="https://www.helloimg.com/i/2024/09/15/66e6b2e275087.png" alt="左旋"  width="15%" height="180"/>====><img src="https://www.helloimg.com/i/2024/09/15/66e6b32d00fb4.png" alt="染色" width="15%" height="180" />====><img src="https://www.helloimg.com/i/2024/09/15/66e6b449e6221.png" alt="染色" width="15%" height="180" />====><img src="https://www.helloimg.com/i/2024/09/15/66e6b51029dc7.png" alt="染色" width="15%" height="180" /></div>


<p>​										删除43										 删除48										左旋0										右旋33</p>
</li>
</ul>
<hr>
<h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li><strong>旋转操作</strong>：左旋和右旋是用于调整红黑树结构的基本操作，帮助保持树的平衡。</li>
<li><strong>重新染色</strong>：通过调整节点的颜色来保持红黑树的颜色平衡，特别是在插入和删除时，重新染色操作经常与旋转操作配合使用。</li>
</ul>
<p>这两种操作的核心目标是维护红黑树的五个特性，确保其高度在 (O(\log n)) 内，从而使得红黑树的操作（插入、删除、查找）始终高效。</p>
<h1 id="JVM篇"><a href="#JVM篇" class="headerlink" title="JVM篇"></a>JVM篇</h1><blockquote>
<p>重点：内存模型、类加载机制、GC</p>
</blockquote>
<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p><strong>JMM</strong> (Java Memory Model) 是 <strong>Java 内存模型</strong> 的缩写，定义了在多线程环境下，Java 程序中的<strong>变量</strong>（包括实例字段、静态字段和数组元素）的读写操作<strong>如何在内存中交互</strong>，它规定了<strong>不同线程之间共享变量的可见性</strong>和<strong>有序性</strong>。</p>
<p>Java 内存模型的主要目的是为了保证<strong>线程安全性</strong>，并提供一种标准的机制，让程序员知道如何在多线程环境中正确地<strong>同步</strong>变量的访问。</p>
<h3 id="1-JMM-的两大核心问题"><a href="#1-JMM-的两大核心问题" class="headerlink" title="1. JMM 的两大核心问题"></a>1. <strong>JMM 的两大核心问题</strong></h3><h4 id="1-1-可见性（Visibility）"><a href="#1-1-可见性（Visibility）" class="headerlink" title="1.1 可见性（Visibility）"></a><strong>1.1 可见性（Visibility）</strong></h4><p>可见性指的是<strong>一个线程对共享变量的修改是否能够及时被其他线程看见</strong>。在没有同步机制的情况下，不同线程可能会在它们自己的缓存或 CPU 寄存器中存储变量的副本，导致线程之间对同一个变量的修改不可见。</p>
<ul>
<li>通过 <code>volatile</code> 关键字、锁（如 <code>synchronized</code> 或 <code>Lock</code>）等机制可以保证可见性。</li>
<li><code>volatile</code> 保证了变量的修改会被及时刷新到主内存中，并且每次读操作都会从主内存中读取最新值。</li>
</ul>
<h4 id="1-2-有序性（Ordering）"><a href="#1-2-有序性（Ordering）" class="headerlink" title="1.2 有序性（Ordering）"></a><strong>1.2 有序性（Ordering）</strong></h4><p>有序性指的是<strong>程序的执行顺序与代码的顺序一致</strong>。由于编译器优化和处理器的指令重排序，程序的执行顺序可能会与源码顺序不一致。</p>
<ul>
<li>Java 内存模型中提供了<strong>内存屏障</strong>等手段来限制重排序，确保某些操作不会被乱序执行。</li>
<li>同时通过 <code>synchronized</code>、<code>volatile</code> 等同步机制可以强制执行顺序。</li>
</ul>
<h3 id="2-主内存和工作内存"><a href="#2-主内存和工作内存" class="headerlink" title="2. 主内存和工作内存"></a>2. <strong>主内存和工作内存</strong></h3><p>JMM 规定了线程与内存的交互方式：</p>
<ul>
<li><strong>主内存</strong>：所有线程共享的区域，存储所有变量的实际值。</li>
<li><strong>工作内存</strong>：每个线程都有自己的私有工作内存，它存储了从主内存拷贝的变量的副本。</li>
</ul>
<p>当线程操作变量时，它必须将变量从主内存加载到工作内存，操作完成后，再把结果写回主内存。线程之间不能直接访问对方的工作内存，因此一个线程对变量的修改必须在写回主内存后才能被其他线程看到。</p>
<h3 id="3-Happens-before-规则"><a href="#3-Happens-before-规则" class="headerlink" title="3. Happens-before 规则"></a>3. <strong>Happens-before 规则</strong></h3><p>JMM 中有一个<strong>happens-before 规则</strong>，它是用来定义操作之间的<strong>内存可见性</strong>和<strong>顺序性</strong>的。它确保了程序中某些操作的结果必须对另一个操作可见，或者要求某些操作必须按顺序执行。</p>
<p>常见的 happens-before 规则包括：</p>
<ul>
<li><strong>程序顺序规则</strong>：在一个线程中，前面的操作 happens-before 后面的操作。</li>
<li><strong>锁规则</strong>：对一个锁的解锁操作 happens-before 后续对同一个锁的加锁操作。</li>
<li><strong>volatile 变量规则</strong>：对 <code>volatile</code> 变量的写操作 happens-before 后续对该变量的读操作。</li>
<li><strong>线程启动规则</strong>：一个线程的 <code>start()</code> 操作 happens-before 该线程中的任何操作。</li>
<li><strong>线程终止规则</strong>：一个线程中的所有操作 happens-before 该线程的 <code>join()</code> 操作完成后。</li>
</ul>
<h3 id="4-同步机制"><a href="#4-同步机制" class="headerlink" title="4. 同步机制"></a>4. <strong>同步机制</strong></h3><p>JMM 提供了一些机制来确保线程间的内存可见性和有序性：</p>
<ul>
<li><code>volatile</code>：用于标记变量，保证对该变量的写操作立即可见，且禁止重排序。</li>
<li><code>synchronized</code>：通过锁的方式保证代码块的同步，防止多个线程同时执行同一个代码块。</li>
<li><code>final</code>：确保对象的引用在构造函数完成后立即可见。</li>
</ul>
<h3 id="5-JMM-的实际应用场景"><a href="#5-JMM-的实际应用场景" class="headerlink" title="5. JMM 的实际应用场景"></a>5. <strong>JMM 的实际应用场景</strong></h3><ul>
<li><strong>共享数据的可见性问题</strong>：比如在多线程环境中，一个线程修改了某个变量，但另一个线程无法及时看到修改。这是由于没有使用适当的同步机制，导致线程读取了旧的缓存值。</li>
<li><strong>指令重排序问题</strong>：在没有同步机制的情况下，指令可能会被编译器或处理器重排序，导致程序执行的实际顺序与代码顺序不同，从而出现意外行为。</li>
<li><strong>单例模式的双重检查锁定问题</strong>：如果没有使用 <code>volatile</code> 修饰单例对象的引用，可能会导致指令重排序，使得其他线程看到一个未完全初始化的对象。</li>
</ul>
<h3 id="6-JMM-的设计目标"><a href="#6-JMM-的设计目标" class="headerlink" title="6. JMM 的设计目标"></a>6. <strong>JMM 的设计目标</strong></h3><p>Java 内存模型的设计目标是为了在多线程环境中保证程序的安全性和性能，主要体现在以下几个方面：</p>
<ul>
<li><strong>高效的线程通信</strong>：通过工作内存和主内存的交互，允许线程以高效的方式操作共享数据。</li>
<li><strong>提供足够的灵活性</strong>：允许编译器和处理器在保证程序正确性的前提下，对程序进行优化，比如指令重排序等。</li>
<li><strong>保证并发正确性</strong>：通过 happens-before 规则和同步机制，确保多线程程序的正确性和一致性。</li>
</ul>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p><strong>Java Memory Model (JMM)</strong> 通过定义线程与内存的交互规则，解决了多线程编程中的可见性和有序性问题。它通过 <code>volatile</code>、<code>synchronized</code> 等关键字，确保在并发环境下程序的正确性。</p>
<img src="https://www.helloimg.com/i/2024/09/15/66e6ba3c22fd5.png" alt="Snipaste_2024-09-15_18-48-29.png" title="Snipaste_2024-09-15_18-48-29.png" />

<hr>
<h2 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h2><p><strong>JVM 内存模型</strong>（JVM Memory Model）描述了 JVM 在运行 Java 程序时管理内存的方式。它定义了 JVM 中不同内存区域的功能与作用，主要包括<strong>堆</strong>、<strong>方法区</strong>、<strong>栈</strong>、<strong>程序计数器</strong>、以及<strong>本地方法栈</strong>。每个区域负责存储特定类型的数据，并有各自的生命周期。</p>
<h3 id="1-JVM-内存结构"><a href="#1-JVM-内存结构" class="headerlink" title="1. JVM 内存结构"></a>1. <strong>JVM 内存结构</strong></h3><p>JVM 内存分为若干个逻辑区域，分别用于存储不同类型的数据，主要包括：</p>
<ul>
<li><strong>线程独占</strong>：栈，本地方法栈，程序计数器</li>
<li><strong>线程共享</strong>：堆，方法区</li>
</ul>
<h4 id="1-1-堆（Heap）"><a href="#1-1-堆（Heap）" class="headerlink" title="1.1 堆（Heap）"></a><strong>1.1 堆（Heap）</strong></h4><ul>
<li><strong>堆</strong>是 JVM 内存中最大的一块区域，用于存储<strong>所有对象实例</strong>和<strong>数组</strong>。</li>
<li>堆是所有线程共享的内存区域，任何线程都可以访问堆中的对象。</li>
<li>Java 堆在 JVM 启动时创建，通常会被分为<strong>年轻代（Young Generation）</strong>和<strong>老年代（Old Generation）</strong>，以便更高效地进行垃圾回收：<ul>
<li><strong>年轻代</strong>：保存新创建的对象，年轻代又分为 Eden 区和两个 Survivor 区。垃圾回收会优先在年轻代进行。</li>
<li><strong>老年代</strong>：保存生命周期较长、经过多次垃圾回收依然存活的对象。</li>
</ul>
</li>
<li><strong>垃圾回收（GC）</strong>会在堆中释放不再被引用的对象。</li>
</ul>
<h4 id="1-2-方法区（Method-Area）"><a href="#1-2-方法区（Method-Area）" class="headerlink" title="1.2 方法区（Method Area）"></a><strong>1.2 方法区（Method Area）</strong></h4><ul>
<li><strong>方法区</strong>是堆的一部分（JDK 8 及以上版本中叫作<strong>元空间（Metaspace）</strong>），用于存储<strong>类的结构信息</strong>、<strong>常量</strong>、<strong>静态变量</strong>、<strong>JIT 编译后的代码</strong>等数据。</li>
<li>每个线程共享该区域，主要用于类加载的相关数据。</li>
<li>JDK 8 之前，方法区也包括<strong>永久代（PermGen）</strong>，JDK 8 之后，永久代被移除，改用元空间管理类元数据。1.7的永久代和1.8的元空间都是方法区的一种实现。</li>
</ul>
<h4 id="1-3-Java-虚拟机栈（JVM-Stack）"><a href="#1-3-Java-虚拟机栈（JVM-Stack）" class="headerlink" title="1.3 Java 虚拟机栈（JVM Stack）"></a><strong>1.3 Java 虚拟机栈（JVM Stack）</strong></h4><ul>
<li><strong>Java 虚拟机栈</strong>用于保存每个线程的<strong>栈帧（Stack Frame）</strong>，每个栈帧对应一个方法的调用。栈帧中包含：<ul>
<li><strong>局部变量表</strong>：方法执行时使用的局部变量，包括基本数据类型和对象引用。</li>
<li><strong>操作数栈</strong>：执行计算时用于存储中间结果。</li>
<li><strong>方法返回地址</strong>：记录方法调用完成后返回的位置。</li>
</ul>
</li>
<li>每个线程都有自己的虚拟机栈，栈的生命周期与线程相同。</li>
</ul>
<h4 id="1-4-本地方法栈（Native-Method-Stack）"><a href="#1-4-本地方法栈（Native-Method-Stack）" class="headerlink" title="1.4 本地方法栈（Native Method Stack）"></a><strong>1.4 本地方法栈（Native Method Stack）</strong></h4><ul>
<li><strong>本地方法栈</strong>与 Java 虚拟机栈类似，但它是为<strong>本地方法</strong>（用 C&#x2F;C++ 实现的非 Java 代码）服务的。主要为本地方法调用提供内存。</li>
<li>JVM 使用本地方法栈来处理通过 JNI（Java Native Interface）调用的本地方法。</li>
</ul>
<h4 id="1-5-程序计数器（Program-Counter-PC-寄存器）"><a href="#1-5-程序计数器（Program-Counter-PC-寄存器）" class="headerlink" title="1.5 程序计数器（Program Counter, PC 寄存器）"></a><strong>1.5 程序计数器（Program Counter, PC 寄存器）</strong></h4><ul>
<li><strong>程序计数器</strong>是一个小的内存区域，记录当前线程将要执行的<strong>下一条字节码指令的地址</strong>。</li>
<li>程序计数器是<strong>线程私有</strong>的，每个线程都有一个独立的程序计数器，用于指示当前线程执行到的指令位置。</li>
<li>在执行 Java 方法时，程序计数器记录的是字节码指令的地址；在执行本地方法时，程序计数器为空（undefined）。</li>
</ul>
<h3 id="2-内存模型中的生命周期"><a href="#2-内存模型中的生命周期" class="headerlink" title="2. 内存模型中的生命周期"></a>2. <strong>内存模型中的生命周期</strong></h3><ul>
<li><strong>堆</strong>和<strong>方法区</strong>是所有线程共享的，因此它们的生命周期与 JVM 的生命周期一致。</li>
<li><strong>Java 虚拟机栈</strong>、<strong>本地方法栈</strong>和<strong>程序计数器</strong>是线程私有的，它们的生命周期与线程的生命周期一致。线程结束时，它们对应的内存也会被释放。</li>
</ul>
<h3 id="3-JVM-的垃圾回收"><a href="#3-JVM-的垃圾回收" class="headerlink" title="3. JVM 的垃圾回收"></a>3. <strong>JVM 的垃圾回收</strong></h3><p>JVM 中的堆区域是垃圾回收的主要目标，垃圾回收器通过<strong>分代回收</strong>的机制，优化对象的内存管理：</p>
<ul>
<li><strong>年轻代 GC（Minor GC）</strong>：主要针对年轻代中的对象进行垃圾回收。年轻代的对象大多是短命的，因此频繁地进行 Minor GC 效率较高。</li>
<li><strong>老年代 GC（Major GC 或 Full GC）</strong>：老年代的对象通常存活时间较长，因此老年代的垃圾回收频率较低，但每次回收的时间相对较长。</li>
</ul>
<p>此外，方法区中的类元数据也可能涉及垃圾回收，尤其是在 JDK 8 之后，方法区的元空间扩展到堆外内存。</p>
<h3 id="4-内存溢出错误（OutOfMemoryError-OOM）"><a href="#4-内存溢出错误（OutOfMemoryError-OOM）" class="headerlink" title="4. 内存溢出错误（OutOfMemoryError, OOM）"></a>4. <strong>内存溢出错误（OutOfMemoryError, OOM）</strong></h3><p>不同内存区域都可能导致<strong>内存溢出错误</strong>：</p>
<ul>
<li><strong>堆内存溢出（Heap OOM）</strong>：如果应用程序在堆中创建过多对象，导致堆内存不足，抛出 <code>java.lang.OutOfMemoryError: Java heap space</code>。</li>
<li><strong>方法区溢出</strong>：当类信息、常量池等占用过多内存，元空间或永久代超出限制时，抛出 <code>java.lang.OutOfMemoryError: Metaspace</code>（JDK 8 及以后）或 <code>java.lang.OutOfMemoryError: PermGen space</code>（JDK 7 及以前）。</li>
<li><strong>栈内存溢出（StackOverflowError）</strong>：当递归调用过深或方法调用过多导致虚拟机栈超出限制时，抛出 <code>java.lang.StackOverflowError</code>。</li>
<li><strong>本地方法栈溢出</strong>：本地方法栈的内存不足时，可能抛出 <code>OutOfMemoryError</code>。</li>
</ul>
<h3 id="5-JVM-内存调优"><a href="#5-JVM-内存调优" class="headerlink" title="5. JVM 内存调优"></a>5. <strong>JVM 内存调优</strong></h3><p>JVM 提供了一些常见的内存参数用于调优内存的分配和垃圾回收：</p>
<ul>
<li><strong>堆大小设置</strong>：<ul>
<li><code>-Xms</code>：设置 JVM 初始堆大小。</li>
<li><code>-Xmx</code>：设置 JVM 最大堆大小。</li>
</ul>
</li>
<li><strong>元空间大小设置</strong>（JDK 8 及以上）：<ul>
<li><code>-XX:MetaspaceSize</code>：设置元空间初始大小。</li>
<li><code>-XX:MaxMetaspaceSize</code>：设置元空间最大大小。</li>
</ul>
</li>
<li><strong>栈大小设置</strong>：<ul>
<li><code>-Xss</code>：设置每个线程的栈大小。</li>
</ul>
</li>
</ul>
<p>通过合理调整这些参数，可以避免内存溢出并提高应用程序的性能。</p>
<h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><p>JVM 内存模型由多个不同的区域组成，包括<strong>堆</strong>、<strong>方法区</strong>、<strong>虚拟机栈</strong>、<strong>本地方法栈</strong>和<strong>程序计数器</strong>。它们各自负责不同类型的数据存储和管理。在多线程环境下，每个线程都有自己独立的栈、程序计数器和本地方法栈，而堆和方法区则是所有线程共享的。JVM 的垃圾回收机制主要针对堆中的对象，并且通过分代回收提高效率。</p>
<hr>
<h2 id="说说类加载与卸载"><a href="#说说类加载与卸载" class="headerlink" title="说说类加载与卸载"></a>说说类加载与卸载</h2><p><strong>类加载</strong>与<strong>卸载</strong>是 JVM 运行时动态管理类字节码的机制，负责将类的字节码从各种数据源加载到内存中并将其转化为 JVM 可执行的类结构。当类不再使用时，JVM 还可以通过类卸载机制释放相关的资源。</p>
<h3 id="一、类加载过程"><a href="#一、类加载过程" class="headerlink" title="一、类加载过程"></a>一、类加载过程</h3><p>类的加载是将 <code>.class</code> 文件中的字节码数据加载到 JVM 内存中的过程，Java 中的<strong>类加载</strong>是动态进行的，即在程序<strong>运行时才加载</strong>类，而不是在程序启动时一次性加载所有类。类加载的过程包括三个步骤：<strong>加载</strong>、<strong>连接</strong>和<strong>初始化</strong>。每个步骤都有各自的任务，具体过程如下：</p>
<h4 id="1-加载（Loading）"><a href="#1-加载（Loading）" class="headerlink" title="1. 加载（Loading）"></a>1. <strong>加载（Loading）</strong></h4><ul>
<li><strong>加载过程</strong>是将类的字节码（从类文件或其他资源如网络、数据库等）读入到 JVM 中，将其转化为<strong>方法区</strong>中的运行时数据结构。</li>
<li><strong>类加载器（ClassLoader）</strong>负责定位和加载类文件。在 Java 中有三种主要的类加载器：<ul>
<li><strong>Bootstrap ClassLoader</strong>（启动类加载器）：加载 JDK 核心类库（<code>$JAVA_HOME/lib</code> 下的类）。</li>
<li><strong>Extension ClassLoader</strong>（扩展类加载器）：加载扩展类库（<code>$JAVA_HOME/lib/ext</code> 下的类）。</li>
<li><strong>Application ClassLoader</strong>（应用程序类加载器）：加载应用程序的类路径（<code>classpath</code>）下的类。</li>
</ul>
</li>
<li>用户还可以自定义类加载器来实现特定需求。</li>
</ul>
<h4 id="2-连接（Linking）"><a href="#2-连接（Linking）" class="headerlink" title="2. 连接（Linking）"></a>2. <strong>连接（Linking）</strong></h4><p>连接过程将已经加载的类进行校验、准备并将其合并到 JVM 的运行环境中。连接过程分为以下三个子阶段：</p>
<ol>
<li><strong>验证（Verification）</strong>：确保字节码的正确性和安全性，防止错误或恶意代码导致程序崩溃。</li>
<li><strong>准备（Preparation）</strong>：为类的<strong>静态变量</strong>分配内存，并设置其初始默认值（注意：这不是赋值为用户定义的初始值，而是根据数据类型赋默认值，如 <code>0</code> 或 <code>null</code>）。</li>
<li><strong>解析（Resolution）</strong>：将类中的符号引用转换为直接引用，符号引用是指使用字符串标识的方法、字段、类，而直接引用是 JVM 内部的实际内存地址或偏移量。</li>
</ol>
<h4 id="3-初始化（Initialization）"><a href="#3-初始化（Initialization）" class="headerlink" title="3. 初始化（Initialization）"></a>3. <strong>初始化（Initialization）</strong></h4><ul>
<li><strong>初始化</strong>是类加载的最后一个阶段，执行类的<strong>静态初始化块</strong>（<code>static</code> 块）和<strong>静态变量的初始化</strong>。</li>
<li>初始化过程按照类中代码的顺序执行，初始化阶段会真正赋予静态变量设定的初值，并执行静态代码块中的代码。</li>
<li>只有在类<strong>第一次使用</strong>时（如实例化类对象、访问类的静态字段或方法）才会触发类的初始化。</li>
</ul>
<h3 id="二、类加载的时机"><a href="#二、类加载的时机" class="headerlink" title="二、类加载的时机"></a>二、类加载的时机</h3><p>类加载是<strong>延迟加载</strong>的，即类不会在程序启动时一次性加载，而是在<strong>需要用到时</strong>才会被加载。以下几种情况会触发类的加载：</p>
<ul>
<li><strong>创建类的实例</strong>（如 <code>new</code> 关键字）。</li>
<li><strong>访问类的静态变量或静态方法</strong>。</li>
<li><strong>反射</strong>（使用 <code>Class.forName()</code> 或反射调用类）。</li>
<li><strong>初始化子类时</strong>会先初始化其父类。</li>
<li><strong>Java 虚拟机启动时</strong>指定的主类。</li>
</ul>
<h3 id="三、类卸载（Unloading）"><a href="#三、类卸载（Unloading）" class="headerlink" title="三、类卸载（Unloading）"></a>三、类卸载（Unloading）</h3><p><strong>类卸载</strong>是 JVM 的机制之一，用于释放那些已经不再被使用的类和类加载器占用的资源。类卸载通常是在满足以下条件时才会进行：</p>
<ul>
<li><strong>类加载器卸载</strong>：当类的加载器被卸载时，所有由它加载的类也会被卸载。</li>
<li><strong>类不再被使用</strong>：即类的所有实例和静态变量都被回收，且没有任何地方再引用这个类。</li>
</ul>
<p>类卸载通常发生在以下场景：</p>
<ul>
<li><strong>自定义类加载器</strong>：当一个自定义类加载器及其加载的类不再被引用时，垃圾回收器可以回收该类加载器及其加载的类。</li>
<li><strong>JVM 垃圾回收</strong>：类的卸载与垃圾回收器密切相关，通常在 Full GC 过程中，当类和类加载器都没有引用时，GC 可能回收类。</li>
</ul>
<p>JVM 并不会频繁卸载类，因为类的卸载在实践中相对少见，尤其是对通过核心类加载器加载的类。类的卸载通常与<strong>类加载器</strong>的生命周期密切相关。比如，Web 应用服务器在重新部署应用时，会创建新的类加载器来加载新的类，同时卸载旧的类加载器和关联的类。</p>
<h3 id="四、类加载器的双亲委派模型"><a href="#四、类加载器的双亲委派模型" class="headerlink" title="四、类加载器的双亲委派模型"></a>四、类加载器的双亲委派模型</h3><p>Java 的类加载机制遵循<strong>双亲委派模型</strong>，保证了核心类库的安全性和稳定性。其基本原理是：</p>
<ul>
<li>每个类加载器在加载类时，会先<strong>委派给父类加载器</strong>，层层向上直至<strong>引导类加载器</strong>。</li>
<li>只有当父类加载器找不到指定类时，子类加载器才会尝试加载该类。</li>
</ul>
<h4 id="双亲委派机制的优点"><a href="#双亲委派机制的优点" class="headerlink" title="双亲委派机制的优点"></a>双亲委派机制的优点</h4><h5 id="1-避免类的重复加载，保证核心类库的安全性"><a href="#1-避免类的重复加载，保证核心类库的安全性" class="headerlink" title="1. 避免类的重复加载，保证核心类库的安全性"></a>1. <strong>避免类的重复加载，保证核心类库的安全性</strong></h5><ul>
<li><p>双亲委派机制通过委派给父加载器来加载类，确保同一个类只会被加载一次，避免了多个类加载器加载同名类而导致的类重复加载问题，同时也确保了 Java 核心类库（如 <code>java.lang.*</code>、<code>java.util.*</code> 等）的安全性和稳定性。通过委派机制，应用程序类加载器不会加载和核心类库同名的类，避免了核心类库的类被篡改或替代。</p>
<blockquote>
<p>例如，当应用程序定义了一个名为 <code>java.lang.String</code> 的类，双亲委派机制会确保首先使用引导类加载器（<code>Bootstrap ClassLoader</code>）加载核心库中的 <code>String</code> 类，而不会使用用户定义的类，从而防止对系统核心功能的干扰。</p>
<p>在没有双亲委派机制的情况下，不同的类加载器可能会加载相同名称的类，导致多个类实例在 JVM 中共存，产生兼容性问题或类转换异常（<code>ClassCastException</code>）。</p>
</blockquote>
</li>
</ul>
<h5 id="2-层次化管理类加载，提高系统的稳定性和可维护性"><a href="#2-层次化管理类加载，提高系统的稳定性和可维护性" class="headerlink" title="2. 层次化管理类加载，提高系统的稳定性和可维护性"></a>2. <strong>层次化管理类加载</strong>，<strong>提高系统的稳定性和可维护性</strong></h5><ul>
<li><p>双亲委派机制建立了一种<strong>层次化的类加载管理结构</strong>，各级加载器各司其职。引导类加载器负责加载核心类库，扩展类加载器负责加载扩展类库，而应用程序类加载器加载用户自定义的类。这样，类的加载职责清晰分工，结构清晰明了，减少了冲突和错误的可能性，提高了系统的稳定性。</p>
</li>
<li><p>这种层次化的管理结构，使得类加载器之间的依赖关系简单明了，也增强了类加载的可控性和调试的便利性。</p>
</li>
<li><p>这种分层结构减少了冲突和错误的可能性，提高了系统的稳定性。</p>
</li>
</ul>
<h5 id="3-支持模块化和动态扩展"><a href="#3-支持模块化和动态扩展" class="headerlink" title="3. 支持模块化和动态扩展"></a>3. <strong>支持模块化和动态扩展</strong></h5><ul>
<li>双亲委派机制与 Java 模块系统和动态扩展特性相容良好。应用程序可以通过自定义类加载器加载特定的类，甚至可以在运行时动态加载、卸载类，这为实现插件式系统、热加载等提供了基础支持。</li>
<li>通过双亲委派机制，系统可以灵活地加载不同的模块，而不会破坏核心类库的完整性。</li>
</ul>
<blockquote>
<p>支持模块化和动态扩展的一个典型例子是在 Java 应用中实现<strong>插件式架构</strong>或<strong>模块化系统</strong>。</p>
<h4 id="1-OSGi（Open-Service-Gateway-Initiative）模块化框架"><a href="#1-OSGi（Open-Service-Gateway-Initiative）模块化框架" class="headerlink" title="1. OSGi（Open Service Gateway Initiative）模块化框架"></a>1. <strong>OSGi（Open Service Gateway Initiative）模块化框架</strong></h4><p>OSGi 是 Java 中用于实现模块化和动态扩展的框架，它允许开发者将应用程序划分为多个模块（称为<strong>Bundles</strong>），并且这些模块可以在运行时动态加载、卸载、更新。每个 Bundle 有自己的类加载器，OSGi 通过双亲委派机制来确保模块之间的类加载逻辑。</p>
<ul>
<li><strong>模块化</strong>：OSGi 将应用程序划分为多个独立的模块，每个模块都有自己的类加载器。核心类库由父类加载器加载，模块则由各自的类加载器加载。</li>
<li><strong>动态扩展</strong>：在 OSGi 中，可以在应用程序运行时动态加载或卸载模块。例如，Web 应用可以在不重启的情况下安装新的插件或功能模块。</li>
</ul>
<p><strong>双亲委派在 OSGi 中的作用</strong>：每个 Bundle 的类加载器会首先委派给父加载器，确保模块之间的类库冲突最小化，同时保证核心类库的完整性。如果一个 Bundle 中需要使用 <code>java.util.List</code> 类，它会先委派给父类加载器加载，而不会从它自己的类加载器中寻找。</p>
<h4 id="2-Spring-插件系统"><a href="#2-Spring-插件系统" class="headerlink" title="2. Spring 插件系统"></a>2. <strong>Spring 插件系统</strong></h4><p>Spring 框架提供了支持插件式架构的能力，允许开发者通过<strong>自定义类加载器</strong>来实现模块的热加载或动态扩展。例如，在某些场景下，企业级应用可能需要动态地添加业务功能模块，而无需重启服务器。</p>
<ul>
<li><strong>模块化</strong>：Spring Boot 中通过 <code>spring.factories</code> 机制加载不同的自动配置模块。开发者可以基于插件系统的架构，在应用启动时选择加载哪些模块。</li>
<li><strong>动态扩展</strong>：通过自定义类加载器，可以在应用运行过程中动态加载新的类（如新功能模块或第三方插件），实现功能的扩展。</li>
</ul>
<p><strong>双亲委派在 Spring 中的作用</strong>：Spring 的自定义类加载器会首先将类加载请求委派给父类加载器，确保加载的核心类（如 <code>javax.servlet.*</code>）和应用库类不被自定义插件覆盖，从而保证应用的稳定性。</p>
<h4 id="3-Tomcat、Jetty-等-Web-服务器中的类加载机制"><a href="#3-Tomcat、Jetty-等-Web-服务器中的类加载机制" class="headerlink" title="3. Tomcat、Jetty 等 Web 服务器中的类加载机制"></a>3. <strong>Tomcat、Jetty 等 Web 服务器中的类加载机制</strong></h4><p>在 Web 服务器（如 Tomcat 或 Jetty）中，应用程序的类是通过 Web 应用的类加载器加载的，而 Web 服务器自身的类库（如 Servlet API）是通过服务器的类加载器加载的。每个 Web 应用都有自己的类加载器，允许不同的 Web 应用之间相互隔离，同时又能共享父加载器加载的核心库。</p>
<ul>
<li><strong>模块化</strong>：每个 Web 应用都是一个独立的模块，部署在服务器上的多个 Web 应用可以互不干扰，各自加载自己的类。</li>
<li><strong>动态扩展</strong>：Web 服务器支持热部署，可以在运行时添加、更新或删除 Web 应用，无需重启服务器。</li>
</ul>
<p><strong>双亲委派在 Web 服务器中的作用</strong>：Web 应用的类加载器会首先将类加载请求委派给父类加载器，这样确保所有应用都使用统一的 Servlet API，而不会被 Web 应用中的自定义类加载器重新定义。</p>
<h4 id="4-Maven-插件系统"><a href="#4-Maven-插件系统" class="headerlink" title="4. Maven 插件系统"></a>4. <strong>Maven 插件系统</strong></h4><p>Maven 是 Java 的项目管理和构建工具，支持通过插件系统扩展功能。每个插件都可以看作是一个独立的模块，加载时由其自定义类加载器管理。</p>
<ul>
<li><strong>模块化</strong>：Maven 通过插件系统加载不同的功能模块（如编译、打包、测试等），每个插件作为独立的模块，可以在构建过程中按需加载。</li>
<li><strong>动态扩展</strong>：用户可以通过引入新的插件来扩展 Maven 的构建能力。例如，加入新的打包工具或编译器插件，无需修改 Maven 核心。</li>
</ul>
<p><strong>双亲委派在 Maven 中的作用</strong>：Maven 插件的类加载器会委派给 Maven 核心加载器，确保插件不会覆盖 Maven 核心类库，避免冲突。</p>
<h4 id="5-IDE-插件系统"><a href="#5-IDE-插件系统" class="headerlink" title="5. IDE 插件系统"></a>5. <strong>IDE 插件系统</strong></h4><p>集成开发环境（IDE）如 IntelliJ IDEA 支持通过插件系统来扩展功能。开发者可以动态安装、卸载插件，而无需重启 IDE。这些插件系统背后的实现原理正是依赖于类加载器的动态扩展能力。</p>
<ul>
<li><strong>模块化</strong>：每个插件都有自己的类加载器，插件可以作为独立的模块进行加载。插件的依赖和核心 IDE 的依赖可以相互隔离。</li>
<li><strong>动态扩展</strong>：开发者可以在 IDE 运行时安装新的插件或卸载不需要的插件，添加新的功能如代码分析、语言支持等。</li>
</ul>
<p><strong>双亲委派在 IDE 中的作用</strong>：插件类加载器会委派给父类加载器，确保插件不会加载和 IDE 核心库冲突的类。</p>
</blockquote>
<h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><ol>
<li><strong>类加载</strong>分为三个主要步骤：加载、连接（包括验证、准备和解析）、初始化。</li>
<li><strong>类加载器</strong>按照双亲委派模型工作，先委派给父加载器，保证核心类库的安全性。</li>
<li><strong>类卸载</strong>在特定条件下才会发生，通常依赖于类加载器的回收。</li>
</ol>
<hr>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p>垃圾回收（Garbage Collection, GC）是 Java 中自动管理内存的机制。JVM 使用多种垃圾回收算法来识别并回收不再使用的对象，释放堆内存以便其他对象使用。不同的垃圾回收算法各有优缺点，它们通常会根据应用程序的需求进行选择和调整。</p>
<h3 id="1-引用计数算法（Reference-Counting）"><a href="#1-引用计数算法（Reference-Counting）" class="headerlink" title="1. 引用计数算法（Reference Counting）"></a>1. <strong>引用计数算法（Reference Counting）</strong></h3><p>这是最简单的一种垃圾回收算法，通过为每个对象维护一个引用计数器，记录有多少引用指向该对象。</p>
<ul>
<li><p><strong>工作原理</strong>：每当一个对象被引用时，引用计数加一；当引用失效时，引用计数减一。如果某个对象的引用计数变为 0，说明该对象没有被任何地方引用，便可以进行回收。</p>
</li>
<li><p><strong>优点</strong>：实现简单，垃圾对象可以很快被回收。</p>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li><strong>无法处理循环引用</strong>：如果两个对象互相引用，它们的引用计数不会变为 0，导致无法被回收。</li>
<li>在 Java 中较少使用，因为这种算法的缺点在某些场景下影响较大。</li>
</ul>
</li>
</ul>
<h3 id="2-标记-清除算法（Mark-Sweep）"><a href="#2-标记-清除算法（Mark-Sweep）" class="headerlink" title="2. 标记-清除算法（Mark-Sweep）"></a>2. <strong>标记-清除算法（Mark-Sweep）</strong></h3><p>标记-清除（Mark-Sweep）是较为常见的垃圾回收算法，用于解决引用计数算法无法处理循环引用的问题。</p>
<ul>
<li><p><strong>工作原理</strong>：</p>
<ol>
<li><strong>标记阶段</strong>：GC 从根对象（即 GC Roots，比如栈中的局部变量、静态变量等）开始遍历，标记所有可达的对象。</li>
<li><strong>清除阶段</strong>：扫描堆中所有对象，<strong>未被标记</strong>的对象会被认为是不可达的，可以回收。</li>
</ol>
</li>
<li><p><strong>优点</strong>：</p>
<ul>
<li>能够解决循环引用问题。</li>
<li>不需要额外的内存空间。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li><strong>效率较低</strong>：因为需要<strong>两次扫描</strong>堆空间，首先标记，再清除，清除过程中可能暂停用户线程（STW, Stop The World）。</li>
<li><strong>内存碎片化</strong>：对象回收后，内存空间并不连续，导致内存碎片增多，影响后续内存分配的效率（分配大对象时可能因为没有足够连续空间而出现分配失败）。</li>
</ul>
</li>
</ul>
<h3 id="3-标记-整理算法（Mark-Compact）"><a href="#3-标记-整理算法（Mark-Compact）" class="headerlink" title="3. 标记-整理算法（Mark-Compact）"></a>3. <strong>标记-整理算法（Mark-Compact）</strong></h3><p>为了解决标记-清除算法中的<strong>内存碎片问题</strong>，提出了标记-整理算法。</p>
<ul>
<li><p><strong>工作原理</strong>：</p>
<ol>
<li><strong>标记阶段</strong>：同样从 GC Roots 开始标记所有可达对象。</li>
<li><strong>整理阶段</strong>：将所有存活的对象向内存空间的一端移动，确保回收后内存是连续的，最后清理掉未被标记的对象。</li>
</ol>
</li>
<li><p><strong>优点</strong>：</p>
<ul>
<li>消除了内存碎片问题，提升了内存分配的效率。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li><strong>对象移动</strong>带来了额外的开销（对象复制和指针更新）。</li>
</ul>
</li>
</ul>
<h3 id="4-复制算法（Copying-Scavenge）"><a href="#4-复制算法（Copying-Scavenge）" class="headerlink" title="4. 复制算法（Copying&#x2F;Scavenge）"></a>4. <strong>复制算法（Copying&#x2F;Scavenge）</strong></h3><p>复制算法是一种高效的垃圾回收算法，主要用于<strong>新生代</strong>的垃圾回收。在新生代，大部分对象生命周期较短，因此复制算法特别适合这种情况。</p>
<ul>
<li><p><strong>工作原理</strong>：</p>
<ol>
<li>将内存分为两个等大的区域（<strong>From 区</strong>和 <strong>To 区</strong>），每次只使用其中的一个区域。</li>
<li>当 GC 发生时，将存活的对象从当前区域（From）复制到另一个区域（To）。</li>
<li>复制完成后，清理掉当前区域的所有对象，From 和 To 互换角色。</li>
</ol>
</li>
<li><p><strong>优点</strong>：</p>
<ul>
<li>每次只处理存活对象，效率高，适用于大多数对象存活时间短的场景。</li>
<li>没有内存碎片问题，因为对象总是被连续地复制到新区域。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li>内存浪费：需要<strong>两倍</strong>的空间才能实现复制操作。</li>
<li>如果存活对象较多，复制操作的成本会增加。</li>
</ul>
</li>
</ul>
<h3 id="5-分代收集算法（Generational-Collection）"><a href="#5-分代收集算法（Generational-Collection）" class="headerlink" title="5. 分代收集算法（Generational Collection）"></a>5. <strong>分代收集算法（Generational Collection）</strong></h3><p>Java 的垃圾回收通常使用<strong>分代收集算法</strong>，将堆内存划分为多个区域（新生代、老年代、永久代&#x2F;元空间），并根据对象生命周期的不同，采用不同的回收策略。</p>
<ul>
<li><p><strong>新生代</strong>：</p>
<ul>
<li>包含 Eden 区和两个 Survivor 区。</li>
<li>新生对象会分配到 Eden 区，Minor GC 时会将存活的对象从 Eden 区和其中一个 Survivor 区复制到另一个 Survivor 区，最终（默认15次）晋升到老年代。</li>
<li><strong>算法</strong>：采用复制算法，因为大多数对象存活时间短，快速回收。</li>
</ul>
</li>
<li><p><strong>老年代</strong>：</p>
<ul>
<li>存放生命周期较长的对象（经过多次 Minor GC 晋升的新生代对象）。</li>
<li>老年代对象较为稳定，垃圾回收频率较低，通常使用<strong>标记-清除</strong>或<strong>标记-整理</strong>算法。</li>
</ul>
</li>
<li><p><strong>元空间（Metaspace）</strong>：</p>
<ul>
<li>Java 8 之后取代了永久代，存放类的元数据（如类结构、方法信息），内存分配在本地内存，而非堆内存。</li>
</ul>
</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>优化内存回收效率</strong>：新生代和老年代分别使用不同的算法，适应对象不同的生命周期特性，提升了整体效率。</li>
<li><strong>频繁的 Minor GC 回收</strong>新生代的短生命周期对象，减少了老年代的回收压力。</li>
</ul>
<h3 id="6-CMS（Concurrent-Mark-Sweep）算法"><a href="#6-CMS（Concurrent-Mark-Sweep）算法" class="headerlink" title="6. CMS（Concurrent Mark-Sweep）算法"></a>6. <strong>CMS（Concurrent Mark-Sweep）算法</strong></h3><p>CMS 是一种<strong>低停顿</strong>的垃圾回收算法，主要用于<strong>老年代</strong>，它的目标是尽可能减少垃圾回收过程中应用的停顿时间（停顿时间越短，响应越快）。</p>
<ul>
<li><p><strong>工作原理</strong>：</p>
<ol>
<li><strong>初始标记</strong>：标记从 GC Roots 可达的对象，<ul>
<li><strong>会发生STW</strong>：但标记范围仅限于 GC Roots 的直接可达对象，速度较快，停顿时间短。</li>
<li><strong>STW 原因</strong>：需要暂停应用线程来确保 GC Roots 和相关对象的正确标记。</li>
</ul>
</li>
<li><strong>并发标记</strong>：在不停止应用线程的情况下，继续标记对象。</li>
<li><strong>重新标记</strong>：再次标记发生在并发标记阶段新增或改变的对象，确保标记的准确性。<ul>
<li>重新标记阶段是为了修正并发标记阶段可能发生的对象引用关系的变化。在并发标记过程中，应用线程仍在运行，可能会出现对象引用的变动，因此重新标记需要将新产生或变化的引用重新标记。</li>
<li><strong>会发生STW</strong>：但由于它只需要处理并发标记期间变化的引用，所以相对较快，停顿时间通常比初始标记长一些，但整体仍然较短。</li>
<li><strong>STW 原因</strong>：为了确保对象引用关系的一致性，需要暂停所有应用线程来完成准确的标记。</li>
</ul>
</li>
<li><strong>并发清除</strong>：不停止应用线程，清除不可达对象。<ul>
<li>在并发清理阶段未能及时回收足够的内存，堆内存可能会被耗尽，导致无法继续分配新的对象。在这种情况下，CMS 会触发 Full GC（标记-整理算法），这会导致较长时间的 STW。</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>优点</strong>：</p>
<ul>
<li><strong>停顿时间短</strong>：大部分标记工作是并发进行的，减少了应用线程的暂停时间。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li>会产生大量的内存碎片。</li>
<li>并发清除阶段占用 CPU 资源，导致整体性能下降。</li>
<li>不适用于堆内存较小的场景，因为内存紧张时可能导致 “Concurrent Mode Failure”，进而触发 Full GC。</li>
</ul>
</li>
</ul>
<h3 id="7-G1（Garbage-First）算法"><a href="#7-G1（Garbage-First）算法" class="headerlink" title="7. G1（Garbage-First）算法"></a>7. <strong>G1（Garbage-First）算法</strong></h3><p>G1 是一种<strong>面向大内存</strong>、<strong>低延迟</strong>的垃圾回收算法，设计用于替代 CMS 算法。G1 将堆内存分为多个独立的区域，并在垃圾回收时优先回收最多垃圾的区域。</p>
<ul>
<li><p><strong>工作原理</strong>：</p>
<ol>
<li>将堆划分为多个大小相等的区域（Region），每个区域可以充当新生代或老年代的角色。</li>
<li>G1 优先回收垃圾最多的区域（Garbage-First）。</li>
<li>G1 在回收时会同时处理新生代和老年代对象，避免全堆扫描。</li>
</ol>
</li>
<li><p><strong>优点</strong>：</p>
<ul>
<li><strong>可预测的停顿时间</strong>：G1 的最大优势是可以通过参数指定最大停顿时间，GC 过程被划分为多个独立的小任务，便于控制。</li>
<li><strong>减少内存碎片</strong>：G1 使用标记-整理算法，保证了回收后内存空间是连续的。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li>实现复杂，调优成本较高。</li>
</ul>
</li>
</ul>
<h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>引用计数算法</strong>：简单但不能解决循环引用问题。</li>
<li><strong>标记-清除算法</strong>：有效解决循环引用，但可能产生内存碎片。</li>
<li><strong>标记-整理算法</strong>：解决了内存碎片问题，但移动对象增加了成本。</li>
<li><strong>复制算法</strong>：适合新生代的对象回收，效率高但需要更多内存。</li>
<li><strong>分代收集算法</strong>：结合新生代和老年代，分别使用不同的算法，优化了整体性能。</li>
<li><strong>CMS 算法</strong>：并发回收，减少停顿时间，但有内存碎片问题。</li>
<li><strong>G1 算法</strong>：面向大内存，控制停顿时间，适用于低延迟应用。</li>
</ul>
<p>每种垃圾回收算法都有其适用的场景，具体选择会依据应用的性能需求、延迟要求和内存大小而定。</p>
<hr>
<h2 id="JVM-常用垃圾收集器"><a href="#JVM-常用垃圾收集器" class="headerlink" title="JVM 常用垃圾收集器"></a><strong>JVM 常用垃圾收集器</strong></h2><p>JVM 常用的垃圾收集器可以分为两大类：<strong>新生代收集器</strong>和<strong>老年代收集器</strong>，它们的主要目标是管理不同生命周期的对象。随着 JDK 的发展，不同的垃圾收集器被设计出来以满足不同的应用需求，如低延迟、高吞吐量等。常用的垃圾收集器包括以下几种：</p>
<h3 id="1-Serial-收集器"><a href="#1-Serial-收集器" class="headerlink" title="1. Serial 收集器"></a>1. <strong>Serial 收集器</strong></h3><ul>
<li><strong>类型</strong>：新生代 + 老年代收集器</li>
<li><strong>工作模式</strong>：单线程</li>
<li><strong>特点</strong>：Serial 收集器是最基础的垃圾收集器，使用单线程进行垃圾回收工作。在进行垃圾回收时，会导致应用程序的所有线程停止（即 <strong>Stop-The-World, STW</strong>）。</li>
<li><strong>使用场景</strong>：适用于单核 CPU 或堆内存较小的场景。</li>
<li><strong>缺点</strong>：由于是单线程，回收效率低，容易导致长时间的停顿，适用于资源有限或需要简单配置的小型应用程序。</li>
</ul>
<h3 id="2-ParNew-收集器"><a href="#2-ParNew-收集器" class="headerlink" title="2. ParNew 收集器"></a>2. <strong>ParNew 收集器</strong></h3><ul>
<li><strong>类型</strong>：新生代收集器</li>
<li><strong>工作模式</strong>：多线程</li>
<li><strong>特点</strong>：ParNew 收集器是 Serial 收集器的多线程版本，它采用复制算法（Copying）来管理新生代内存。它能够利用多核 CPU 来并行处理垃圾回收，回收时同样会触发 <strong>STW</strong>。</li>
<li><strong>使用场景</strong>：通常与老年代的 CMS 收集器配合使用，适合并发较多的应用。</li>
<li><strong>缺点</strong>：回收时仍然会暂停应用线程（STW）。</li>
</ul>
<h3 id="3-Parallel-Scavenge-收集器"><a href="#3-Parallel-Scavenge-收集器" class="headerlink" title="3. Parallel Scavenge 收集器"></a>3. <strong>Parallel Scavenge 收集器</strong></h3><ul>
<li><strong>类型</strong>：新生代收集器</li>
<li><strong>工作模式</strong>：多线程</li>
<li><strong>特点</strong>：Parallel Scavenge 又称为 “吞吐量优先收集器”。它的目标是通过多线程最大化吞吐量，即最小化 GC 运行时间，以提高应用程序的整体吞吐量。它也使用复制算法来管理新生代内存。</li>
<li><strong>使用场景</strong>：适合后台计算等需要高吞吐量的场景，比如大批量数据处理。</li>
<li><strong>缺点</strong>：相比于 CMS 收集器，停顿时间可能更长，因为它关注的是吞吐量，而不是响应时间。</li>
</ul>
<h3 id="4-Serial-Old-收集器"><a href="#4-Serial-Old-收集器" class="headerlink" title="4. Serial Old 收集器"></a>4. <strong>Serial Old 收集器</strong></h3><ul>
<li><strong>类型</strong>：老年代收集器</li>
<li><strong>工作模式</strong>：单线程</li>
<li><strong>特点</strong>：Serial Old 是老年代的单线程垃圾收集器，使用<strong>标记-整理算法</strong>（Mark-Compact）进行老年代对象的回收。它是 Serial 收集器的老年代版本。</li>
<li><strong>使用场景</strong>：与 Serial 收集器配合使用，适用于单线程和内存较小的环境中，也作为 CMS 发生 Concurrent Mode Failure 时的后备收集器。</li>
<li><strong>缺点</strong>：单线程操作，性能较低，且会触发较长时间的 STW。</li>
</ul>
<h3 id="5-Parallel-Old-收集器"><a href="#5-Parallel-Old-收集器" class="headerlink" title="5. Parallel Old 收集器"></a>5. <strong>Parallel Old 收集器</strong></h3><ul>
<li><strong>类型</strong>：老年代收集器</li>
<li><strong>工作模式</strong>：多线程</li>
<li><strong>特点</strong>：Parallel Old 是 Parallel Scavenge 的老年代版本，它使用多线程的<strong>标记-整理算法</strong>进行垃圾回收。</li>
<li><strong>使用场景</strong>：适合需要高吞吐量的场景，与 Parallel Scavenge 配合使用，实现新生代和老年代的全程并行垃圾回收。</li>
<li><strong>缺点</strong>：虽然优化了吞吐量，但仍然会有停顿。</li>
</ul>
<h3 id="6-CMS（Concurrent-Mark-Sweep）收集器"><a href="#6-CMS（Concurrent-Mark-Sweep）收集器" class="headerlink" title="6. CMS（Concurrent Mark-Sweep）收集器"></a>6. <strong>CMS（Concurrent Mark-Sweep）收集器</strong></h3><ul>
<li><p><strong>类型</strong>：老年代收集器</p>
</li>
<li><p><strong>工作模式</strong>：多线程</p>
</li>
<li><p><strong>特点</strong>：CMS 收集器是一种以<strong>低停顿</strong>为目标的垃圾收集器，专门用于回收老年代对象。它的主要特点是与应用线程并发进行垃圾回收，以减少 STW 时间。CMS 采用标记-清除算法，回收时分为以下四个阶段：</p>
<ol>
<li><strong>初始标记</strong>（短暂 STW）</li>
<li><strong>并发标记</strong></li>
<li><strong>重新标记</strong>（短暂 STW）</li>
<li><strong>并发清除</strong></li>
</ol>
</li>
<li><p><strong>使用场景</strong>：适用于对<strong>响应时间敏感</strong>的应用，比如互联网服务、交互式应用等。</p>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li><strong>产生内存碎片</strong>：CMS 采用标记-清除算法，不会对内存进行整理，可能会导致内存碎片化。</li>
<li><strong>Concurrent Mode Failure</strong>：在内存回收不及时时，可能会触发 Full GC（Serial Old 收集器），导致长时间的停顿。</li>
</ul>
</li>
</ul>
<h3 id="7-G1（Garbage-First）收集器"><a href="#7-G1（Garbage-First）收集器" class="headerlink" title="7. G1（Garbage First）收集器"></a>7. <strong>G1（Garbage First）收集器</strong></h3><ul>
<li><p><strong>类型</strong>：新生代 + 老年代收集器</p>
</li>
<li><p><strong>工作模式</strong>：多线程</p>
</li>
<li><p><strong>特点</strong>：G1 收集器是一种<strong>面向大内存、低停顿</strong>的收集器，设计用于替代 CMS。它将堆内存划分为多个大小相等的独立区域（Region），并优先回收垃圾最多的区域（Garbage First）。G1 同时回收新生代和老年代的对象。</p>
</li>
<li><p><strong>工作原理</strong>：</p>
<ol>
<li>G1 采用 <strong>标记-整理算法</strong> 来避免内存碎片化。</li>
<li>支持用户指定停顿时间目标，通过参数 <code>-XX:MaxGCPauseMillis</code> 可以调整 GC 停顿时间。</li>
</ol>
</li>
<li><p><strong>使用场景</strong>：适用于大内存、低停顿需求的场景，如高可用系统、实时应用等。它对内存大小和应用规模都有很好的适应性。</p>
</li>
<li><p><strong>优点</strong>：相比于 CMS，G1 可以避免内存碎片化，支持用户指定停顿时间，整体性能较为平衡。</p>
</li>
<li><p><strong>缺点</strong>：实现较为复杂，调优成本较高。</p>
</li>
</ul>
<h3 id="8-ZGC（Z-Garbage-Collector）"><a href="#8-ZGC（Z-Garbage-Collector）" class="headerlink" title="8. ZGC（Z Garbage Collector）"></a>8. <strong>ZGC（Z Garbage Collector）</strong></h3><ul>
<li><strong>类型</strong>：新生代 + 老年代收集器</li>
<li><strong>工作模式</strong>：多线程</li>
<li><strong>特点</strong>：ZGC 是一款<strong>超低延迟</strong>的垃圾收集器，设计目标是在堆内存非常大的情况下（最大支持数 TB 级别），依然能够将垃圾回收的停顿时间控制在 <strong>10ms 以内</strong>。ZGC 通过分块并发回收，最大程度地减少了 STW 时间。</li>
<li><strong>使用场景</strong>：ZGC 非常适合需要超低延迟且使用大堆内存的应用，如金融系统、实时交易系统等。</li>
<li><strong>优点</strong>：<ul>
<li>超低停顿时间，能处理大规模内存。</li>
<li>并发性更强，最大化减少 STW。</li>
</ul>
</li>
<li><strong>缺点</strong>：目前是实验性收集器，尚在优化中。</li>
</ul>
<h3 id="9-Shenandoah-收集器"><a href="#9-Shenandoah-收集器" class="headerlink" title="9. Shenandoah 收集器"></a>9. <strong>Shenandoah 收集器</strong></h3><ul>
<li><strong>类型</strong>：新生代 + 老年代收集器</li>
<li><strong>工作模式</strong>：多线程</li>
<li><strong>特点</strong>：Shenandoah 也是一款低延迟的垃圾收集器，它与 ZGC 类似，旨在将垃圾回收的停顿时间控制在极低范围内。Shenandoah 通过并发压缩和并发标记来减少 STW，支持用户指定停顿时间目标。</li>
<li><strong>使用场景</strong>：适合需要大堆内存和低延迟的应用场景。</li>
<li><strong>优点</strong>：低延迟，能够与应用线程并发工作。</li>
<li><strong>缺点</strong>：相比于 ZGC，Shenandoah 实现更复杂，调优难度较高。</li>
</ul>
<h3 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h3><p>JVM 提供了多种垃圾收集器来应对不同的应用场景：</p>
<ul>
<li><strong>Serial</strong> 和 <strong>Serial Old</strong>：适合小型应用，单线程操作。</li>
<li><strong>ParNew</strong> 和 <strong>Parallel Scavenge</strong>：适合需要高吞吐量的多线程应用。</li>
<li><strong>CMS</strong>：适用于响应时间敏感的场景，但有内存碎片问题。</li>
<li><strong>G1</strong>：适合大内存和低延迟需求的应用，是 CMS 的替代方案。</li>
<li><strong>ZGC</strong> 和 <strong>Shenandoah</strong>：专为超大内存和低延迟场景设计，未来有望成为主流选择。</li>
</ul>
<p>不同收集器可以根据应用的特定需求进行选择和调优，以实现最佳的性能表现。</p>
<hr>
<h2 id="说说栈和堆的区别"><a href="#说说栈和堆的区别" class="headerlink" title="说说栈和堆的区别"></a>说说栈和堆的区别</h2><p>在 Java 中，<strong>栈</strong>（Stack）和<strong>堆</strong>（Heap）是两种不同的内存区域，它们有不同的用途和管理方式。以下是栈和堆的主要区别：</p>
<h3 id="1-内存分配方式"><a href="#1-内存分配方式" class="headerlink" title="1. 内存分配方式"></a>1. <strong>内存分配方式</strong></h3><ul>
<li><strong>栈</strong>：栈内存是<strong>自动分配</strong>的，主要用于存储<strong>局部变量</strong>、<strong>方法调用</strong>、<strong>函数参数</strong>等。每当一个方法被调用时，JVM 会为该方法分配一块栈空间（<strong>顺序存储</strong>）。当方法执行完毕，栈上的数据会自动释放。栈中的数据是按<strong>先进后出</strong>（LIFO，Last In First Out）的原则管理的。</li>
<li><strong>堆</strong>：堆内存是<strong>动态分配</strong>的，主要用于存储所有的<strong>对象实例</strong>和<strong>数组</strong>。Java 中所有的对象（包括通过 <code>new</code> 关键字创建的对象）都存储在堆中。堆内存是由垃圾回收机制（GC）来管理的，不会自动释放，需要等待垃圾回收器回收。</li>
</ul>
<h3 id="2-内存的大小和限制"><a href="#2-内存的大小和限制" class="headerlink" title="2. 内存的大小和限制"></a>2. <strong>内存的大小和限制</strong></h3><ul>
<li><strong>栈</strong>：栈的空间通常较小，并且栈的大小是有上限的。在大多数 JVM 实现中，栈的大小可以通过启动参数（如 <code>-Xss</code>）来指定。如果方法调用过深或者递归太深，会导致栈空间耗尽，进而引发 <strong>StackOverflowError</strong>。</li>
<li><strong>堆</strong>：堆的内存空间通常比栈大得多，存储了程序运行过程中创建的所有对象。堆的大小可以通过 JVM 启动参数（如 <code>-Xms</code> 和 <code>-Xmx</code>）来调整。如果堆内存不足，会引发 <strong>OutOfMemoryError</strong>。</li>
</ul>
<h3 id="3-存储内容"><a href="#3-存储内容" class="headerlink" title="3. 存储内容"></a>3. <strong>存储内容</strong></h3><ul>
<li><p><strong>栈</strong>：</p>
<ul>
<li>方法的局部变量（基本类型和对象引用）存储在栈中。</li>
<li>方法的返回地址、函数调用栈帧的信息也保存在栈中。</li>
<li>栈中存储的变量数据往往生命周期短暂，随着方法的结束而被销毁。</li>
</ul>
</li>
<li><p><strong>堆</strong>：</p>
<ul>
<li>堆用于存储所有的对象实例和数组，Java 中通过 <code>new</code> 创建的对象都在堆上分配内存。</li>
<li>无论对象是在局部变量中创建的还是通过引用传递的，所有对象的实际数据都保存在堆内存中。</li>
<li>对象在堆中的生命周期比栈中变量长，由垃圾回收器负责回收。</li>
</ul>
</li>
</ul>
<h3 id="4-生命周期"><a href="#4-生命周期" class="headerlink" title="4. 生命周期"></a>4. <strong>生命周期</strong></h3><ul>
<li><strong>栈</strong>：栈中的数据是与方法的生命周期一致的。当方法调用时，数据入栈；当方法执行结束时，数据出栈并自动释放。因此，栈中的数据生命周期较短，通常是瞬时的。</li>
<li><strong>堆</strong>：堆中的对象的生命周期不依赖于方法的结束，可能会存在较长时间。只要有引用指向堆中的对象，它就不会被回收，直到没有任何引用指向该对象时，它才会被垃圾回收器回收。</li>
</ul>
<h3 id="5-线程安全性"><a href="#5-线程安全性" class="headerlink" title="5. 线程安全性"></a>5. <strong>线程安全性</strong></h3><ul>
<li><strong>栈</strong>：栈内存是线程私有的，每个线程都有自己的栈，因此栈中的数据天然是<strong>线程安全</strong>的，不需要同步机制。</li>
<li><strong>堆</strong>：堆内存是线程共享的，多个线程可以同时访问堆中的对象，因此需要注意线程安全问题。如果多个线程同时访问堆中的数据，可能需要通过同步机制（如 <code>synchronized</code> 或 <code>ReentrantLock</code>）来保证线程安全。</li>
</ul>
<h3 id="6-访问速度"><a href="#6-访问速度" class="headerlink" title="6. 访问速度"></a>6. <strong>访问速度</strong></h3><ul>
<li><strong>栈</strong>：由于栈的内存分配是连续的，且采用 LIFO 方式管理，栈内存的访问速度较快。栈是基于寄存器的，操作效率很高。</li>
<li><strong>堆</strong>：堆内存的分配是动态的，结构相对复杂，且需要垃圾回收器（STW）进行管理，因此访问速度比栈慢。</li>
</ul>
<h3 id="7-GC（垃圾回收）的作用"><a href="#7-GC（垃圾回收）的作用" class="headerlink" title="7. GC（垃圾回收）的作用"></a>7. <strong>GC（垃圾回收）的作用</strong></h3><ul>
<li><strong>栈</strong>：栈中的局部变量和数据在方法结束时自动释放，因此不需要垃圾回收器的干预。</li>
<li><strong>堆</strong>：堆中的对象需要垃圾回收器来管理。当没有引用指向堆中的对象时，垃圾回收器会在合适的时间进行回收，以释放内存空间。</li>
</ul>
<h3 id="8-异常类型不同"><a href="#8-异常类型不同" class="headerlink" title="8. 异常类型不同"></a><strong>8. 异常类型不同</strong></h3><ul>
<li><strong>栈</strong>：如果栈内存使用过多（比如递归调用太深），可能会导致<strong>栈溢出错误</strong>（<code>StackOverflowError</code>）。栈的空间有限，当超过栈的最大深度时，就会抛出该异常。</li>
<li><strong>堆</strong>：堆内存不足时，JVM 会抛出<strong>内存溢出错误</strong>（<code>OutOfMemoryError</code>）。</li>
</ul>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StackHeapExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <span class="hljs-comment">// 基本类型，存储在栈中</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(); <span class="hljs-comment">// person 引用存储在栈中，Person 对象存储在堆中</span><br>        person.setName(<span class="hljs-string">&quot;Alice&quot;</span>);<br>        person.sayHello();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name; <span class="hljs-comment">// name 引用存储在堆中，字符串对象存储在堆中</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name; <span class="hljs-comment">// this 和 name 引用都在堆中</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">greeting</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello, &quot;</span> + name; <span class="hljs-comment">// greeting 是局部变量，存储在栈中</span><br>        System.out.println(greeting);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>在 <code>main</code> 方法中：<ul>
<li><code>a</code> 是基本类型变量，存储在栈中。</li>
<li><code>person</code> 是对象引用，存储在栈中，实际的 <code>Person</code> 对象存储在堆中。</li>
</ul>
</li>
<li>在 <code>Person</code> 类中：<ul>
<li><code>name</code> 是成员变量，属于对象实例，存储在堆中。</li>
<li>方法 <code>sayHello</code> 中的 <code>greeting</code> 是局部变量，存储在栈中。</li>
</ul>
</li>
</ul>
<h3 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p><strong>栈（Stack）</strong>：</p>
<ul>
<li>用于存储方法的局部变量、参数和调用信息。</li>
<li>内存由系统自动分配和释放，速度快。</li>
<li>线程私有，线程安全。</li>
<li>容量有限，可能发生栈溢出。</li>
</ul>
</li>
<li><p><strong>堆（Heap）</strong>：</p>
<ul>
<li>用于存储所有的对象实例和数组。</li>
<li>内存由程序在运行时动态分配，灵活但速度相对较慢。</li>
<li>线程共享，可能存在线程安全问题。</li>
<li>空间大，可能发生内存溢出。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>属性</strong></th>
<th><strong>栈（Stack）</strong></th>
<th><strong>堆（Heap）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>分配方式</strong></td>
<td>LIFO自动分配、释放</td>
<td>动态分配、垃圾回收器管理</td>
</tr>
<tr>
<td><strong>存储内容</strong></td>
<td>局部变量、方法调用信息</td>
<td>对象实例、数组</td>
</tr>
<tr>
<td><strong>线程安全性</strong></td>
<td>线程私有，天然线程安全</td>
<td>线程共享，需考虑同步机制</td>
</tr>
<tr>
<td><strong>访问速度</strong></td>
<td>快</td>
<td>相对较慢</td>
</tr>
<tr>
<td><strong>生命周期</strong></td>
<td>方法执行期间</td>
<td>由垃圾回收器管理，可能长时间存在</td>
</tr>
<tr>
<td><strong>大小限制</strong></td>
<td>较小，有固定大小上限</td>
<td>较大，大小可调，通过 <code>-Xms</code> 和 <code>-Xmx</code> 设置</td>
</tr>
<tr>
<td><strong>GC 的作用</strong></td>
<td>不需要</td>
<td>需要，由垃圾回收器管理</td>
</tr>
<tr>
<td><strong>异常</strong></td>
<td><code>StackOverflowError</code></td>
<td><code>OutOfMemoryError</code></td>
</tr>
</tbody></table>
<hr>
<h2 id="什么时候会触发FullGC"><a href="#什么时候会触发FullGC" class="headerlink" title="什么时候会触发FullGC"></a>什么时候会触发FullGC</h2><p>在 Java 中，<strong>Full GC</strong> 是一种较为耗时的垃圾回收操作，它会对整个堆空间（包括年轻代和老年代）以及方法区（如 Metaspace、永久代）进行全面的垃圾回收，会影响应用的性能，因为 Full GC 会暂停所有应用线程（即 <strong>Stop-The-World, STW</strong>），并对堆内存中的所有区域进行垃圾回收。通常情况下，Full GC 的触发条件如下：</p>
<h3 id="1-老年代（Old-Generation）空间不足"><a href="#1-老年代（Old-Generation）空间不足" class="headerlink" title="1. 老年代（Old Generation）空间不足"></a><strong>1. 老年代（Old Generation）空间不足</strong></h3><ul>
<li>当老年代空间不足时，会触发 Full GC。对象从新生代（Young Generation）晋升到老年代时，如果老年代的可用空间不足，就会进行 Full GC 来尝试回收老年代的垃圾，释放空间。</li>
</ul>
<h4 id="触发场景："><a href="#触发场景：" class="headerlink" title="触发场景："></a>触发场景：</h4><ul>
<li>应用中有大量长生命周期的对象，这些对象在经过多次垃圾回收后存活，最终被晋升到老年代，导致老年代占用率不断上升。</li>
<li>晋升到老年代的对象较多或新生代对象过大，需要搬移到老年代时无法容纳。</li>
</ul>
<h3 id="2-永久代（PermGen）或元空间（Metaspace）空间不足"><a href="#2-永久代（PermGen）或元空间（Metaspace）空间不足" class="headerlink" title="2. 永久代（PermGen）或元空间（Metaspace）空间不足"></a><strong>2. 永久代（PermGen）或元空间（Metaspace）空间不足</strong></h3><ul>
<li>在 Java 8 之前，JVM 使用<strong>永久代（PermGen）</strong>来存储类的元数据、常量池、静态变量等，Java 8 之后则引入了<strong>元空间（Metaspace）</strong>来替代永久代。如果永久代或元空间的空间不足（如类加载过多、内存泄漏等），也会触发 Full GC 以释放无用的类信息。</li>
</ul>
<h4 id="触发场景：-1"><a href="#触发场景：-1" class="headerlink" title="触发场景："></a>触发场景：</h4><ul>
<li>动态类加载大量类，如框架中频繁使用反射、动态代理、CGlib 等生成大量类。</li>
<li>类卸载不及时，特别是 Web 容器（如 Tomcat）中的类加载器频繁创建和销毁。</li>
</ul>
<h3 id="3-System-gc-的调用"><a href="#3-System-gc-的调用" class="headerlink" title="3. System.gc() 的调用"></a>3. <strong>System.gc() 的调用</strong></h3><p>显式调用 <code>System.gc()</code> 方法时，JVM 会尝试进行 Full GC。这是开发者手动请求垃圾回收的一种方式，但并不建议频繁使用。因为 Full GC 会暂停所有应用线程，并不一定能显著提高内存回收效果，反而可能导致性能下降，尤其是当应用正在处理大量请求时，可能导致响应延迟。</p>
<h4 id="触发场景：-2"><a href="#触发场景：-2" class="headerlink" title="触发场景："></a>触发场景：</h4><ul>
<li>程序员通过代码或第三方库显式调用了 <code>System.gc()</code>。</li>
<li>某些监控工具或应用框架可能自动调用 <code>System.gc()</code> 来试图释放内存。</li>
</ul>
<h3 id="4-大对象分配失败（Promotion-Failure）"><a href="#4-大对象分配失败（Promotion-Failure）" class="headerlink" title="4. 大对象分配失败（Promotion Failure）"></a>4. <strong>大对象分配失败（Promotion Failure）</strong></h3><p>当大对象（如大数组、集合等）直接分配到老年代时，老年代如果没有足够的连续空间（<code>老年代经过多次垃圾回收后，可能会产生内存碎片</code>）来存储该对象，JVM 会触发 Full GC 来尝试腾出空间。大对象通常无法在年轻代存活很久，因此被直接分配到老年代，但如果老年代空间不足，会引发 GC。</p>
<h4 id="触发场景：-3"><a href="#触发场景：-3" class="headerlink" title="触发场景："></a>触发场景：</h4><ul>
<li>创建了大量大对象，尤其是当 <code>-XX:+UseLargePages</code> 选项启用时，需要连续内存块存储大对象。</li>
<li>新生代空间不足，导致大对象被直接分配到老年代。</li>
<li>Full GC 会尝试整理这些内存碎片。</li>
</ul>
<h3 id="5-空间分配担保机制失败（Allocation-Failure-Handle-Promotion-Failure）"><a href="#5-空间分配担保机制失败（Allocation-Failure-Handle-Promotion-Failure）" class="headerlink" title="5. 空间分配担保机制失败（Allocation Failure&#x2F;Handle Promotion Failure）"></a>5. <strong>空间分配担保机制失败（Allocation Failure&#x2F;Handle Promotion Failure）</strong></h3><p>在年轻代垃圾回收（Minor GC）时，如果对象无法在年轻代回收完毕，且晋升到老年代时，老年代没有足够空间来存放这些晋升对象，JVM 可能会触发 Full GC 来回收老年代的对象。此时，老年代可能会进行整理操作以腾出空间。</p>
<h4 id="触发场景：-4"><a href="#触发场景：-4" class="headerlink" title="触发场景："></a>触发场景：</h4><ul>
<li>短时间内生成了大量大对象，或新生代满了之后需要将存活的对象晋升到老年代</li>
<li>经过多次 Minor GC 后，依然有很多对象晋升到老年代，老年代即将满。</li>
<li>晋升阈值设定不合理，导致对象在新生代停留过少时间，过早晋升到老年代。</li>
</ul>
<h3 id="6-Concurrent-Mode-Failure（CMS-收集器）"><a href="#6-Concurrent-Mode-Failure（CMS-收集器）" class="headerlink" title="6. Concurrent Mode Failure（CMS 收集器）"></a>6. <strong>Concurrent Mode Failure（CMS 收集器）</strong></h3><p>对于使用 CMS（Concurrent Mark-Sweep）垃圾收集器的 JVM，当 CMS 垃圾回收器在<strong>并发清理</strong>过程中发现老年代内存不足（即并发回收速度赶不上内存分配速度）时，CMS 会被迫触发一次 Full GC 作为后备措施，称为**”Concurrent Mode Failure”<strong>（</strong>并发模式失败**）。</p>
<h4 id="触发场景：-5"><a href="#触发场景：-5" class="headerlink" title="触发场景："></a>触发场景：</h4><ul>
<li>CMS 收集器无法在并发回收过程中及时回收足够的空间以应对新对象的晋升。</li>
<li>老年代增长速度超过 CMS 的并发回收能力。</li>
<li>G1 垃圾收集器在某些情况下，如果堆内存不足也会触发 Full GC 作为回退手段</li>
</ul>
<h3 id="7-堆内存不足"><a href="#7-堆内存不足" class="headerlink" title="7. 堆内存不足"></a><strong>7. 堆内存不足</strong></h3><ul>
<li>如果整个堆内存（包括新生代和老年代）都接近满负荷，并且 GC 无法成功释放足够的空间，会触发 Full GC 来回收更多的内存。</li>
<li>如果 Full GC 仍然无法释放足够的空间，则会抛出 <code>OutOfMemoryError</code>。</li>
</ul>
<h3 id="8-JVM-参数配置不合理"><a href="#8-JVM-参数配置不合理" class="headerlink" title="8. JVM 参数配置不合理"></a>8. <strong>JVM 参数配置不合理</strong></h3><p>有时不合理的 JVM 参数配置（如堆大小、各代内存比例等）也可能导致 Full GC 频繁触发。例如，如果年轻代过大，Minor GC 可能将大量对象晋升到老年代，而老年代空间不足时会触发 Full GC。或者元空间（Metaspace）配置过小，类元数据无法存储，导致频繁 Full GC。</p>
<h4 id="触发场景：-6"><a href="#触发场景：-6" class="headerlink" title="触发场景："></a>触发场景：</h4><ul>
<li>年轻代与老年代的比例不平衡，导致晋升压力过大。</li>
<li>元空间大小配置过小，导致类加载过多时触发 Full GC。</li>
</ul>
<hr>
<h3 id="如何避免频繁的-Full-GC？"><a href="#如何避免频繁的-Full-GC？" class="headerlink" title="如何避免频繁的 Full GC？"></a><strong>如何避免频繁的 Full GC？</strong></h3><ol>
<li><strong>调整堆内存大小</strong>：通过 JVM 参数 <code>-Xms</code> 和 <code>-Xmx</code> 增大堆内存的初始大小和最大大小，减少 Full GC 发生的频率。</li>
<li><strong>优化对象创建和生命周期管理</strong>：避免创建不必要的对象，并确保及时释放不再使用的对象引用，防止内存泄漏。</li>
<li><strong>选择合适的垃圾回收器</strong>：不同垃圾回收器适合不同的场景。对于低延迟的应用，可能需要选择 G1、ZGC 等现代的垃圾回收器。</li>
<li><strong>调优元空间大小</strong>：通过 JVM 参数 <code>-XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code> 设置元空间的大小，避免因类加载过多而导致的 Full GC。</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">DrJuly2333</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2024/09/15/JAVA%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/">http://example.com/2024/09/15/JAVA%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JAVA/">JAVA</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/09/15/JAVA%E9%9D%A2%E8%AF%95Spring%E7%AF%87/" title="JAVA面试八股文Spring篇"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">JAVA面试八股文Spring篇</div></div></a></div><div class="next-post pull-right"><a href="/2024/08/10/%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" title="鸟哥的Linux实战阅读笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">鸟哥的Linux实战阅读笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2024/09/15/JAVA%E9%9D%A2%E8%AF%95Spring%E7%AF%87/" title="JAVA面试八股文Spring篇"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-15</div><div class="title">JAVA面试八股文Spring篇</div></div></a></div><div><a href="/2024/07/24/Java%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/" title="JAVA工作总结和面试"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-24</div><div class="title">JAVA工作总结和面试</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">DrJuly2333</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/DrJuly2333" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:HTTTS2022@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">欢迎光临小站，这里是我日常收集和整理的总结，希望能对您有所帮助：）<br/><br/>本站的内容经过个人加工总结而来，也参考了网友们分享的资料，如有侵权，请第一时间联系我，我将及时进行修改和删除</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.</span> <span class="toc-text">基本数据和引用类型的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">1. 基本数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">1.1.1.</span> <span class="toc-text">特点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">2. 引用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">特点：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%E8%BF%98%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="toc-number">2.</span> <span class="toc-text">Java是值传递还是引用传递</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92"><span class="toc-number">2.1.</span> <span class="toc-text">1. 基本数据类型的值传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92"><span class="toc-number">2.2.</span> <span class="toc-text">2. 引用类型的值传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BF%AE%E6%94%B9%E5%BC%95%E7%94%A8%E6%9C%AC%E8%BA%AB%E4%B8%8D%E4%BC%9A%E5%BD%B1%E5%93%8D%E5%A4%96%E9%83%A8%E5%BC%95%E7%94%A8"><span class="toc-number">2.3.</span> <span class="toc-text">3. 修改引用本身不会影响外部引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88String%E8%A6%81%E8%AE%BE%E8%AE%A1%E6%88%90%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84"><span class="toc-number">3.</span> <span class="toc-text">为什么String要设计成不可变的</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-String-%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.1.</span> <span class="toc-text">1. String 的不可变性设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88-String-%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84%EF%BC%9F"><span class="toc-number">3.2.</span> <span class="toc-text">2. 为什么 String 是不可变的？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%9A"><span class="toc-number">3.2.1.</span> <span class="toc-text">1. 安全性：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9A"><span class="toc-number">3.2.2.</span> <span class="toc-text">2. 线程安全：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A"><span class="toc-number">3.2.3.</span> <span class="toc-text">3. 性能优化：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%93%88%E5%B8%8C%E5%80%BC%E7%BC%93%E5%AD%98%EF%BC%9A"><span class="toc-number">3.2.4.</span> <span class="toc-text">4. 哈希值缓存：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E8%AE%BE%E8%AE%A1%E7%AE%80%E5%8D%95%E6%80%A7%EF%BC%9A"><span class="toc-number">3.2.5.</span> <span class="toc-text">5. 设计简单性：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%BF%AE%E6%94%B9%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">3.3.</span> <span class="toc-text">3. 字符串的修改如何实现？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E7%9A%84-%E6%8B%BC%E6%8E%A5%E6%93%8D%E4%BD%9C%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.</span> <span class="toc-text">String的 + 拼接操作底层实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96%EF%BC%88%E5%B8%B8%E9%87%8F%E6%8A%98%E5%8F%A0%EF%BC%89"><span class="toc-number">4.1.</span> <span class="toc-text">1. 编译器优化（常量折叠）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8-StringBuilder%EF%BC%88%E8%BF%90%E8%A1%8C%E6%97%B6%E6%8B%BC%E6%8E%A5%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">2. 使用 StringBuilder（运行时拼接）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90%EF%BC%9A"><span class="toc-number">4.2.1.</span> <span class="toc-text">例子：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%90%8E%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%E7%AD%89%E6%95%88%E4%BA%8E%EF%BC%9A"><span class="toc-number">4.2.2.</span> <span class="toc-text">编译后的字节码等效于：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-StringBuilder-vs-StringBuffer"><span class="toc-number">4.3.</span> <span class="toc-text">3. StringBuilder vs StringBuffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A4%9A%E6%AC%A1%E4%BD%BF%E7%94%A8-%E6%8B%BC%E6%8E%A5%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="toc-number">4.4.</span> <span class="toc-text">4. 多次使用 + 拼接的性能问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">ArrayList动态扩容过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-ArrayList-%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-number">5.1.</span> <span class="toc-text">1. ArrayList 底层结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%E5%92%8C%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9"><span class="toc-number">5.2.</span> <span class="toc-text">2. 添加元素和动态扩容</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#add-%E6%96%B9%E6%B3%95%E7%9A%84%E7%AE%80%E5%8C%96%E7%89%88%EF%BC%9A"><span class="toc-number">5.2.1.</span> <span class="toc-text">add() 方法的简化版：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ensureCapacityInternal-%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">5.2.2.</span> <span class="toc-text">ensureCapacityInternal() 方法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ensureExplicitCapacity-%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">5.2.3.</span> <span class="toc-text">ensureExplicitCapacity() 方法：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9%E7%9A%84%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%EF%BC%9Agrow"><span class="toc-number">5.3.</span> <span class="toc-text">3. 动态扩容的核心方法：grow()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#hugeCapacity-%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">5.3.1.</span> <span class="toc-text">hugeCapacity() 方法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91%EF%BC%9A"><span class="toc-number">5.3.2.</span> <span class="toc-text">核心逻辑：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%80%BB%E7%BB%93"><span class="toc-number">5.4.</span> <span class="toc-text">4. 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text">HashMap的底层原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">6.1.</span> <span class="toc-text">1. 底层数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-HashMap-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%AD%97%E6%AE%B5"><span class="toc-number">6.2.</span> <span class="toc-text">2. HashMap 的核心字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Node-%E8%8A%82%E7%82%B9%E7%BB%93%E6%9E%84"><span class="toc-number">6.3.</span> <span class="toc-text">3. Node 节点结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-HashMap-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">6.4.</span> <span class="toc-text">4. HashMap 的工作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE-put"><span class="toc-number">6.4.1.</span> <span class="toc-text">1. 插入数据 (put)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9F%A5%E6%89%BE%E6%95%B0%E6%8D%AE-get"><span class="toc-number">6.4.2.</span> <span class="toc-text">2. 查找数据 (get)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">6.4.3.</span> <span class="toc-text">3. 扩容机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-HashMap-%E7%9A%84%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3"><span class="toc-number">6.5.</span> <span class="toc-text">5. HashMap 的哈希冲突解决</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">6.6.</span> <span class="toc-text">6. 线程安全性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap-%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF-2-%E7%9A%84-N-%E6%AC%A1%E6%96%B9"><span class="toc-number">7.</span> <span class="toc-text">HashMap 的长度为什么是 2 的 N 次方</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap-%E4%B8%AD%E7%9A%84-key-%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E4%BB%BB%E4%BD%95%E7%B1%BB%E4%BD%9C%E4%B8%BA-key-%E5%90%97"><span class="toc-number">8.</span> <span class="toc-text">HashMap 中的 key 可以使用任何类作为 key 吗</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99-equals-%E6%96%B9%E6%B3%95"><span class="toc-number">8.1.</span> <span class="toc-text">1. 必须重写 equals() 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99-hashCode-%E6%96%B9%E6%B3%95"><span class="toc-number">8.2.</span> <span class="toc-text">2. 必须重写 hashCode() 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="toc-number">8.3.</span> <span class="toc-text">3. 不可变性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%94%A8%E4%BA%8E-HashMap-%E7%9A%84%E7%B1%BB"><span class="toc-number">8.4.</span> <span class="toc-text">常见用于 HashMap 的类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">8.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E5%92%8CConcurrentHashMap%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.</span> <span class="toc-text">HashMap和ConcurrentHashMap的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-HashMap-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">9.1.</span> <span class="toc-text">1. HashMap 数据结构与底层原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="toc-number">9.1.1.</span> <span class="toc-text">数据结构：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">9.1.2.</span> <span class="toc-text">工作原理：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDK7-%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B%E6%AD%BB%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%BD%A2%E6%88%90%E8%BF%87%E7%A8%8B"><span class="toc-number">9.1.3.</span> <span class="toc-text">JDK7 扩容过程死循环的形成过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-ConcurrentHashMap-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">9.2.</span> <span class="toc-text">2. ConcurrentHashMap 数据结构与底层原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A-1"><span class="toc-number">9.2.1.</span> <span class="toc-text">数据结构：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9A-1"><span class="toc-number">9.2.2.</span> <span class="toc-text">工作原理：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fail-Fast%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-number">10.</span> <span class="toc-text">Fail-Fast机制原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Fail-Fast-%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">10.1.</span> <span class="toc-text">Fail-Fast 机制的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Fail-Fast-%E6%9C%BA%E5%88%B6%E7%A4%BA%E4%BE%8B"><span class="toc-number">10.1.1.</span> <span class="toc-text">Fail-Fast 机制示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fail-Fast-%E6%9C%BA%E5%88%B6%E6%8A%9B%E5%87%BA-ConcurrentModificationException-%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">10.2.</span> <span class="toc-text">Fail-Fast 机制抛出 ConcurrentModificationException 的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fail-Fast-%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">10.3.</span> <span class="toc-text">Fail-Fast 机制的局限性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D-Fail-Fast"><span class="toc-number">10.4.</span> <span class="toc-text">如何避免 Fail-Fast</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">10.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E5%B8%B8%E7%94%A8%E7%89%B9%E7%82%B9"><span class="toc-number">11.</span> <span class="toc-text">泛型常用特点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8"><span class="toc-number">11.1.</span> <span class="toc-text">1. 类型安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E7%9A%84%E9%99%90%E5%88%B6%EF%BC%88%E4%B8%8A%E7%95%8C%E4%B8%8E%E4%B8%8B%E7%95%8C%EF%BC%89"><span class="toc-number">11.2.</span> <span class="toc-text">2. 类型参数的限制（上界与下界）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-number">11.3.</span> <span class="toc-text">3. 泛型类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">11.4.</span> <span class="toc-text">4. 泛型方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="toc-number">11.5.</span> <span class="toc-text">5. 类型擦除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%B8%8D%E8%83%BD%E7%94%A8%E4%BA%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">11.6.</span> <span class="toc-text">6. 不能用于基本数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%B3%9B%E5%9E%8B%E4%B8%8D%E8%83%BD%E7%94%A8%E4%BA%8E%E9%9D%99%E6%80%81%E5%AD%97%E6%AE%B5%E6%88%96%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">11.7.</span> <span class="toc-text">7. 泛型不能用于静态字段或静态方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%B3%9B%E5%9E%8B%E6%95%B0%E7%BB%84%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">11.8.</span> <span class="toc-text">8. 泛型数组的限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">11.9.</span> <span class="toc-text">9. 通配符 ?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%A4%9A%E9%87%8D%E9%99%90%E5%AE%9A"><span class="toc-number">11.10.</span> <span class="toc-text">10. 多重限定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98"><span class="toc-number">11.11.</span> <span class="toc-text">11. 协变和逆变</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">12.</span> <span class="toc-text">深拷贝和浅拷贝的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%88Shallow-Copy%EF%BC%89"><span class="toc-number">12.1.</span> <span class="toc-text">1. 浅拷贝（Shallow Copy）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%88Deep-Copy%EF%BC%89"><span class="toc-number">12.2.</span> <span class="toc-text">2. 深拷贝（Deep Copy）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">12.3.</span> <span class="toc-text">3. 应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">13.</span> <span class="toc-text">final的用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-final-%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F"><span class="toc-number">13.1.</span> <span class="toc-text">1. final 修饰变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-final-%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95"><span class="toc-number">13.2.</span> <span class="toc-text">2. final 修饰方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-final-%E4%BF%AE%E9%A5%B0%E7%B1%BB"><span class="toc-number">13.3.</span> <span class="toc-text">3. final 修饰类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-final-%E4%B8%8E%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">13.4.</span> <span class="toc-text">4. final 与匿名内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-final-%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">13.5.</span> <span class="toc-text">5. final 与线程安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-final-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">13.6.</span> <span class="toc-text">6. final 关键字的限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">13.7.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">14.</span> <span class="toc-text">static的用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-static-%E4%BF%AE%E9%A5%B0%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%EF%BC%88%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%EF%BC%89"><span class="toc-number">14.1.</span> <span class="toc-text">1. static 修饰成员变量（静态变量）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-static-%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95%EF%BC%88%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-number">14.2.</span> <span class="toc-text">2. static 修饰方法（静态方法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-static-%E4%BF%AE%E9%A5%B0%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%88%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%89"><span class="toc-number">14.3.</span> <span class="toc-text">3. static 修饰代码块（静态代码块）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-static-%E4%BF%AE%E9%A5%B0%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88%E9%9D%99%E6%80%81%E5%B5%8C%E5%A5%97%E7%B1%BB%EF%BC%89"><span class="toc-number">14.4.</span> <span class="toc-text">4. static 修饰内部类（静态嵌套类）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-static-%E7%9A%84%E5%85%B6%E4%BB%96%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">14.5.</span> <span class="toc-text">5. static 的其他应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-static-%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">14.6.</span> <span class="toc-text">6. static 与多线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">14.7.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#try-catch-finally%EF%BC%8Ctry%E9%87%8C%E6%9C%89return%EF%BC%8Cfinally%E8%BF%98%E4%BC%9A%E6%89%A7%E8%A1%8C%E5%90%97"><span class="toc-number">15.</span> <span class="toc-text">try catch finally，try里有return，finally还会执行吗</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-1%EF%BC%9Afinally-%E5%9C%A8-return-%E4%B9%8B%E5%89%8D%E6%89%A7%E8%A1%8C"><span class="toc-number">15.1.</span> <span class="toc-text">代码示例 1：finally 在 return 之前执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-2%EF%BC%9Afinally-%E6%94%B9%E5%8F%98%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">15.2.</span> <span class="toc-text">代码示例 2：finally 改变返回值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OOM%E4%BD%A0%E9%81%87%E5%88%B0%E8%BF%87%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%EF%BC%8CSOF%E4%BD%A0%E9%81%87%E5%88%B0%E8%BF%87%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5"><span class="toc-number">16.</span> <span class="toc-text">OOM你遇到过哪些情况，SOF你遇到过哪些情况</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OOM%EF%BC%88OutOfMemoryError%EF%BC%89"><span class="toc-number">16.1.</span> <span class="toc-text">OOM（OutOfMemoryError）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SOF%EF%BC%88StackOverflowError%EF%BC%89"><span class="toc-number">16.2.</span> <span class="toc-text">SOF（StackOverflowError）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-number">16.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84-OOM-%E6%98%AF%E5%87%BA%E7%8E%B0%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%EF%BC%9F"><span class="toc-number">17.</span> <span class="toc-text">在项目中遇到的 OOM  是出现在什么场景下的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%99%E4%BA%9BOOM%E9%97%AE%E9%A2%98%E6%98%AF%E6%80%8E%E4%B9%88%E6%8E%92%E6%9F%A5%E7%9A%84%E5%91%A2"><span class="toc-number">18.</span> <span class="toc-text">这些OOM问题是怎么排查的呢</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%80%9A%E8%BF%87%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6%E6%8E%92%E6%9F%A5%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98"><span class="toc-number">18.1.</span> <span class="toc-text">1. 通过堆转储文件排查内存问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E7%94%9F%E6%88%90%E5%A0%86%E8%BD%AC%E5%82%A8"><span class="toc-number">18.1.1.</span> <span class="toc-text">1.1 生成堆转储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%88%86%E6%9E%90%E5%A0%86%E8%BD%AC%E5%82%A8"><span class="toc-number">18.1.2.</span> <span class="toc-text">1.2 分析堆转储</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%80%9A%E8%BF%87-GC-%E6%97%A5%E5%BF%97%E6%8E%92%E6%9F%A5%E9%97%AE%E9%A2%98"><span class="toc-number">18.2.</span> <span class="toc-text">2. 通过 GC 日志排查问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%BC%80%E5%90%AF-GC-%E6%97%A5%E5%BF%97"><span class="toc-number">18.2.1.</span> <span class="toc-text">2.1 开启 GC 日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%88%86%E6%9E%90-GC-%E6%97%A5%E5%BF%97"><span class="toc-number">18.2.2.</span> <span class="toc-text">2.2 分析 GC 日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-GC-%E6%97%A5%E5%BF%97%E4%B8%AD%E7%9A%84%E9%87%8D%E7%82%B9%E4%BF%A1%E6%81%AF"><span class="toc-number">18.2.3.</span> <span class="toc-text">2.3 GC 日志中的重点信息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%80%9A%E8%BF%87-JVM-%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7%E5%88%86%E6%9E%90"><span class="toc-number">18.3.</span> <span class="toc-text">3. 通过 JVM 监控工具分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E4%BD%BF%E7%94%A8-jconsole-%E6%88%96-jvisualvm"><span class="toc-number">18.3.1.</span> <span class="toc-text">3.1 使用 jconsole 或 jvisualvm</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E7%9B%91%E6%8E%A7%E5%A0%86%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8"><span class="toc-number">18.3.2.</span> <span class="toc-text">3.2 监控堆内存使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%8E%92%E6%9F%A5%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">18.4.</span> <span class="toc-text">4. 排查代码中的内存泄漏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E6%A3%80%E6%9F%A5%E9%95%BF%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">18.4.1.</span> <span class="toc-text">4.1 检查长生命周期的对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E4%BC%98%E5%8C%96%E7%BC%93%E5%AD%98%E4%BD%BF%E7%94%A8"><span class="toc-number">18.4.2.</span> <span class="toc-text">4.2 优化缓存使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E9%80%90%E6%AD%A5%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE"><span class="toc-number">18.4.3.</span> <span class="toc-text">4.3 逐步加载数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%A3%80%E6%9F%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E7%9A%84%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5"><span class="toc-number">18.5.</span> <span class="toc-text">5. 检查第三方库的内存使用情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%B0%83%E6%95%B4-JVM-%E5%8F%82%E6%95%B0"><span class="toc-number">18.6.</span> <span class="toc-text">6. 调整 JVM 参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-%E5%A2%9E%E5%8A%A0%E5%A0%86%E5%86%85%E5%AD%98"><span class="toc-number">18.6.1.</span> <span class="toc-text">6.1 增加堆内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-%E8%B0%83%E6%95%B4%E5%85%83%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F"><span class="toc-number">18.6.2.</span> <span class="toc-text">6.2 调整元空间大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-%E8%AE%BE%E7%BD%AE%E5%90%88%E7%90%86%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">18.6.3.</span> <span class="toc-text">6.3 设置合理的垃圾回收器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E9%80%9A%E8%BF%87%E7%BA%BF%E7%A8%8B%E7%9B%91%E6%8E%A7%E6%8E%92%E6%9F%A5-SOF%EF%BC%88StackOverflowError%EF%BC%89"><span class="toc-number">18.7.</span> <span class="toc-text">7. 通过线程监控排查 SOF（StackOverflowError）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-5"><span class="toc-number">18.8.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E7%9A%84%E7%BA%BF%E4%B8%8AOOM%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E8%BF%87%E7%A8%8B"><span class="toc-number">19.</span> <span class="toc-text">典型的线上OOM问题排查过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%97%AE%E9%A2%98%E5%8F%91%E7%94%9F%EF%BC%9A%E7%BA%BF%E4%B8%8A%E5%BC%82%E5%B8%B8%E5%92%8C%E6%8A%A5%E8%AD%A6"><span class="toc-number">19.1.</span> <span class="toc-text">1. 问题发生：线上异常和报警</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6"><span class="toc-number">19.1.1.</span> <span class="toc-text">1.1 监控报警</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E7%94%A8%E6%88%B7%E5%8F%8D%E9%A6%88"><span class="toc-number">19.1.2.</span> <span class="toc-text">1.2 用户反馈</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%9D%E6%AD%A5%E6%A3%80%E6%9F%A5%EF%BC%9A%E9%80%9A%E8%BF%87%E6%97%A5%E5%BF%97%E5%92%8C%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7%E7%A1%AE%E8%AE%A4%E9%97%AE%E9%A2%98"><span class="toc-number">19.2.</span> <span class="toc-text">2. 初步检查：通过日志和监控工具确认问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E6%9F%A5%E7%9C%8B%E5%BA%94%E7%94%A8%E6%97%A5%E5%BF%97"><span class="toc-number">19.2.1.</span> <span class="toc-text">2.1 查看应用日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E6%9F%A5%E7%9C%8B-GC-%E6%97%A5%E5%BF%97"><span class="toc-number">19.2.2.</span> <span class="toc-text">2.2 查看 GC 日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E5%AE%9E%E6%97%B6%E7%9B%91%E6%8E%A7-JVM-%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8"><span class="toc-number">19.2.3.</span> <span class="toc-text">2.3 实时监控 JVM 内存使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86%EF%BC%9A%E8%8E%B7%E5%8F%96%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6"><span class="toc-number">19.3.</span> <span class="toc-text">3. 数据收集：获取堆转储文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E7%94%9F%E6%88%90%E5%A0%86%E8%BD%AC%E5%82%A8%EF%BC%88Heap-Dump%EF%BC%89"><span class="toc-number">19.3.1.</span> <span class="toc-text">3.1 生成堆转储（Heap Dump）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E8%8E%B7%E5%8F%96-GC-%E6%97%A5%E5%BF%97"><span class="toc-number">19.3.2.</span> <span class="toc-text">3.2 获取 GC 日志</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%EF%BC%9A%E5%88%86%E6%9E%90%E5%A0%86%E8%BD%AC%E5%82%A8%E5%92%8C-GC-%E6%97%A5%E5%BF%97"><span class="toc-number">19.4.</span> <span class="toc-text">4. 问题定位：分析堆转储和 GC 日志</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E5%88%86%E6%9E%90%E5%A0%86%E8%BD%AC%E5%82%A8%E6%96%87%E4%BB%B6"><span class="toc-number">19.4.1.</span> <span class="toc-text">4.1 分析堆转储文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E5%88%86%E6%9E%90-GC-%E6%97%A5%E5%BF%97"><span class="toc-number">19.4.2.</span> <span class="toc-text">4.2 分析 GC 日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E6%A3%80%E6%9F%A5%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">19.4.3.</span> <span class="toc-text">4.3 检查代码中的问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BC%98%E5%8C%96%E5%92%8C%E4%BF%AE%E5%A4%8D%EF%BC%9A%E4%BB%A3%E7%A0%81%E4%BF%AE%E5%A4%8D%E4%B8%8E%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96"><span class="toc-number">19.5.</span> <span class="toc-text">5. 优化和修复：代码修复与内存优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8"><span class="toc-number">19.5.1.</span> <span class="toc-text">5.1 优化代码中的内存使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E8%B0%83%E6%95%B4-JVM-%E5%8F%82%E6%95%B0"><span class="toc-number">19.5.2.</span> <span class="toc-text">5.2 调整 JVM 参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-%E4%BD%BF%E7%94%A8%E6%9B%B4%E5%90%88%E9%80%82%E7%9A%84-GC-%E7%AD%96%E7%95%A5"><span class="toc-number">19.5.3.</span> <span class="toc-text">5.3 使用更合适的 GC 策略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E9%AA%8C%E8%AF%81%E4%B8%8E%E5%8F%91%E5%B8%83%EF%BC%9A%E7%BA%BF%E4%B8%8A%E6%B5%8B%E8%AF%95%E5%92%8C%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83"><span class="toc-number">19.6.</span> <span class="toc-text">6. 验证与发布：线上测试和灰度发布</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E5%92%8C%E9%AA%8C%E8%AF%81"><span class="toc-number">19.6.1.</span> <span class="toc-text">6.1 压力测试和验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83%E4%B8%8E%E7%9B%91%E6%8E%A7"><span class="toc-number">19.6.2.</span> <span class="toc-text">6.2 灰度发布与监控</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-%E6%9C%80%E7%BB%88%E5%8F%91%E5%B8%83"><span class="toc-number">19.6.3.</span> <span class="toc-text">6.3 最终发布</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-6"><span class="toc-number">19.7.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%88%86%E6%9E%90-OOM-%E9%97%AE%E9%A2%98%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">20.</span> <span class="toc-text">通过命令行分析 OOM 问题的流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%A1%AE%E4%BF%9D-JVM-%E5%8F%82%E6%95%B0%E6%AD%A3%E7%A1%AE%E8%AE%BE%E7%BD%AE"><span class="toc-number">20.1.</span> <span class="toc-text">1. 确保 JVM 参数正确设置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE-JVM-%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE%EF%BC%9A"><span class="toc-number">20.1.1.</span> <span class="toc-text">关键 JVM 参数设置：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E5%88%86%E6%9E%90-JVM-%E5%86%85%E5%AD%98%E7%8A%B6%E5%86%B5"><span class="toc-number">20.2.</span> <span class="toc-text">2. 使用命令分析 JVM 内存状况</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E4%BD%BF%E7%94%A8-jmap-%E5%91%BD%E4%BB%A4%E7%94%9F%E6%88%90%E5%A0%86%E8%BD%AC%E5%82%A8"><span class="toc-number">20.2.1.</span> <span class="toc-text">2.1 使用 jmap 命令生成堆转储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E4%BD%BF%E7%94%A8-jmap-%E6%9F%A5%E7%9C%8B%E5%A0%86%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83"><span class="toc-number">20.2.2.</span> <span class="toc-text">2.2 使用 jmap 查看堆内存分布</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E4%BD%BF%E7%94%A8-jstat-%E7%9B%91%E6%8E%A7-GC-%E6%83%85%E5%86%B5"><span class="toc-number">20.2.3.</span> <span class="toc-text">2.3 使用 jstat 监控 GC 情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E4%BD%BF%E7%94%A8-jstack-%E6%9F%A5%E7%9C%8B%E7%BA%BF%E7%A8%8B%E5%A0%86%E6%A0%88"><span class="toc-number">20.2.4.</span> <span class="toc-text">2.4 使用 jstack 查看线程堆栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-%E4%BD%BF%E7%94%A8-jmap-%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E5%AF%B9%E8%B1%A1"><span class="toc-number">20.2.5.</span> <span class="toc-text">2.5 使用 jmap 查看内存对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BB%93%E5%90%88%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B7%A5%E5%85%B7%E5%88%86%E6%9E%90%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98"><span class="toc-number">20.3.</span> <span class="toc-text">3. 结合操作系统工具分析内存问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E4%BD%BF%E7%94%A8-top-%E5%91%BD%E4%BB%A4%E7%9B%91%E6%8E%A7%E5%86%85%E5%AD%98%E5%92%8C-CPU"><span class="toc-number">20.3.1.</span> <span class="toc-text">3.1 使用 top 命令监控内存和 CPU</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E4%BD%BF%E7%94%A8-free-%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98"><span class="toc-number">20.3.2.</span> <span class="toc-text">3.2 使用 free 命令查看系统内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E4%BD%BF%E7%94%A8-ps-%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8"><span class="toc-number">20.3.3.</span> <span class="toc-text">3.3 使用 ps 命令查看内存占用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%88%86%E6%9E%90-GC-%E6%97%A5%E5%BF%97"><span class="toc-number">20.4.</span> <span class="toc-text">4. 分析 GC 日志</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GC-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E9%87%8D%E7%82%B9%EF%BC%9A"><span class="toc-number">20.4.1.</span> <span class="toc-text">GC 日志分析重点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BD%BF%E7%94%A8-Eclipse-MAT-%E6%88%96-VisualVM-%E5%88%86%E6%9E%90%E5%A0%86%E8%BD%AC%E5%82%A8"><span class="toc-number">20.5.</span> <span class="toc-text">5. 使用 Eclipse MAT 或 VisualVM 分析堆转储</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E8%BD%AC%E5%82%A8%E5%88%86%E6%9E%90%E9%87%8D%E7%82%B9%EF%BC%9A"><span class="toc-number">20.5.1.</span> <span class="toc-text">堆转储分析重点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-7"><span class="toc-number">20.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-8-%E5%BC%95%E5%85%A5%E5%85%83%E7%A9%BA%E9%97%B4%E7%9A%84%E4%B8%BB%E8%A6%81%E7%9B%AE%E7%9A%84"><span class="toc-number">21.</span> <span class="toc-text">Java 8 引入元空间的主要目的</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%B0%B8%E4%B9%85%E4%BB%A3%EF%BC%88PermGen%EF%BC%89%E5%9C%A8-Java-7-%E5%8F%8A%E4%B9%8B%E5%89%8D"><span class="toc-number">21.1.</span> <span class="toc-text">1. 永久代（PermGen）在 Java 7 及之前</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%85%83%E7%A9%BA%E9%97%B4%EF%BC%88Metaspace%EF%BC%89%E5%9C%A8-Java-8-%E5%8F%8A%E4%B9%8B%E5%90%8E"><span class="toc-number">21.2.</span> <span class="toc-text">2. 元空间（Metaspace）在 Java 8 及之后</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%80%BB%E7%BB%93"><span class="toc-number">21.3.</span> <span class="toc-text">3. 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AIO%E3%80%81BIO%E3%80%81NIO%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">22.</span> <span class="toc-text">AIO、BIO、NIO的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-BIO%EF%BC%88Blocking-IO%EF%BC%8C%E9%98%BB%E5%A1%9E-IO%EF%BC%89"><span class="toc-number">22.1.</span> <span class="toc-text">1. BIO（Blocking IO，阻塞 IO）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9A-2"><span class="toc-number">22.1.1.</span> <span class="toc-text">工作原理：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">22.1.2.</span> <span class="toc-text">使用场景：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-number">22.1.3.</span> <span class="toc-text">示例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A-2"><span class="toc-number">22.1.4.</span> <span class="toc-text">特点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-NIO%EF%BC%88Non-blocking-IO%EF%BC%8C%E9%9D%9E%E9%98%BB%E5%A1%9E-IO%EF%BC%89"><span class="toc-number">22.2.</span> <span class="toc-text">2. NIO（Non-blocking IO，非阻塞 IO）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9A-3"><span class="toc-number">22.2.1.</span> <span class="toc-text">工作原理：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A-1"><span class="toc-number">22.2.2.</span> <span class="toc-text">使用场景：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-1"><span class="toc-number">22.2.3.</span> <span class="toc-text">示例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A-3"><span class="toc-number">22.2.4.</span> <span class="toc-text">特点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-AIO%EF%BC%88Asynchronous-IO%EF%BC%8C%E5%BC%82%E6%AD%A5-IO%EF%BC%89"><span class="toc-number">22.3.</span> <span class="toc-text">3. AIO（Asynchronous IO，异步 IO）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9A-4"><span class="toc-number">22.3.1.</span> <span class="toc-text">工作原理：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A-2"><span class="toc-number">22.3.2.</span> <span class="toc-text">使用场景：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-2"><span class="toc-number">22.3.3.</span> <span class="toc-text">示例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A-4"><span class="toc-number">22.3.4.</span> <span class="toc-text">特点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E5%AF%B9%E6%AF%94"><span class="toc-number">22.4.</span> <span class="toc-text">总结对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">22.5.</span> <span class="toc-text">选择使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E6%9C%89%E5%93%AA%E5%87%A0%E4%B8%AA%E7%89%B9%E5%BE%81"><span class="toc-number">23.</span> <span class="toc-text">红黑树有哪几个特征</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E4%BA%94%E5%A4%A7%E7%89%B9%E5%BE%81%EF%BC%9A"><span class="toc-number">23.1.</span> <span class="toc-text">红黑树的五大特征：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E8%87%AA%E5%B9%B3%E8%A1%A1%E7%89%B9%E6%80%A7%EF%BC%9A"><span class="toc-number">23.2.</span> <span class="toc-text">红黑树的自平衡特性：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-number">23.3.</span> <span class="toc-text">红黑树的优点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%97%8B%E8%BD%AC%E6%93%8D%E4%BD%9C%E5%92%8C%E9%87%8D%E6%96%B0%E6%9F%93%E8%89%B2%E6%93%8D%E4%BD%9C"><span class="toc-number">24.</span> <span class="toc-text">红黑树的旋转操作和重新染色操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%97%8B%E8%BD%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">24.1.</span> <span class="toc-text">1. 旋转操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%B7%A6%E6%97%8B%EF%BC%88Left-Rotation%EF%BC%89"><span class="toc-number">24.1.1.</span> <span class="toc-text">1.1 左旋（Left Rotation）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A6%E6%97%8B%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-number">24.1.2.</span> <span class="toc-text">左旋示例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%8F%B3%E6%97%8B%EF%BC%88Right-Rotation%EF%BC%89"><span class="toc-number">24.1.3.</span> <span class="toc-text">1.2 右旋（Right Rotation）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%B3%E6%97%8B%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-number">24.1.4.</span> <span class="toc-text">右旋示例：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%87%8D%E6%96%B0%E6%9F%93%E8%89%B2%E6%93%8D%E4%BD%9C"><span class="toc-number">24.2.</span> <span class="toc-text">2. 重新染色操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E6%8F%92%E5%85%A5%E6%97%B6%E7%9A%84%E9%87%8D%E6%96%B0%E6%9F%93%E8%89%B2"><span class="toc-number">24.2.1.</span> <span class="toc-text">2.1 插入时的重新染色</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%88%A0%E9%99%A4%E6%97%B6%E7%9A%84%E9%87%8D%E6%96%B0%E6%9F%93%E8%89%B2"><span class="toc-number">24.2.2.</span> <span class="toc-text">2.2 删除时的重新染色</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%8F%92%E5%85%A5%E6%97%B6%E7%9A%84%E5%B9%B3%E8%A1%A1%E4%BF%AE%E5%A4%8D%EF%BC%88%E7%BB%93%E5%90%88%E6%97%8B%E8%BD%AC%E5%92%8C%E9%87%8D%E6%96%B0%E6%9F%93%E8%89%B2%EF%BC%89"><span class="toc-number">24.3.</span> <span class="toc-text">3. 插入时的平衡修复（结合旋转和重新染色）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">24.3.1.</span> <span class="toc-text">示例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E5%9C%A8%E5%B7%A6%E8%BE%B9%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">24.3.1.1.</span> <span class="toc-text">节点在左边的情况</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E5%9C%A8%E5%8F%B3%E8%BE%B9%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">24.3.1.2.</span> <span class="toc-text">节点在右边的情况</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%88%A0%E9%99%A4%E6%97%B6%E7%9A%84%E5%B9%B3%E8%A1%A1%E4%BF%AE%E5%A4%8D%EF%BC%88%E7%BB%93%E5%90%88%E6%97%8B%E8%BD%AC%E5%92%8C%E9%87%8D%E6%96%B0%E6%9F%93%E8%89%B2%EF%BC%89"><span class="toc-number">24.4.</span> <span class="toc-text">4. 删除时的平衡修复（结合旋转和重新染色）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">24.4.1.</span> <span class="toc-text">示例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E5%9C%A8%E5%B7%A6%E8%BE%B9%E7%9A%84%E6%83%85%E5%86%B5-1"><span class="toc-number">24.4.1.1.</span> <span class="toc-text">节点在左边的情况</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E5%9C%A8%E5%8F%B3%E8%BE%B9%E7%9A%84%E6%83%85%E5%86%B5-1"><span class="toc-number">24.4.1.2.</span> <span class="toc-text">节点在右边的情况</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-8"><span class="toc-number">24.5.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM%E7%AF%87"><span class="toc-number"></span> <span class="toc-text">JVM篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">Java内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-JMM-%E7%9A%84%E4%B8%A4%E5%A4%A7%E6%A0%B8%E5%BF%83%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.</span> <span class="toc-text">1. JMM 的两大核心问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%8F%AF%E8%A7%81%E6%80%A7%EF%BC%88Visibility%EF%BC%89"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 可见性（Visibility）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E6%9C%89%E5%BA%8F%E6%80%A7%EF%BC%88Ordering%EF%BC%89"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 有序性（Ordering）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%BB%E5%86%85%E5%AD%98%E5%92%8C%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98"><span class="toc-number">1.2.</span> <span class="toc-text">2. 主内存和工作内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Happens-before-%E8%A7%84%E5%88%99"><span class="toc-number">1.3.</span> <span class="toc-text">3. Happens-before 规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.</span> <span class="toc-text">4. 同步机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-JMM-%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.5.</span> <span class="toc-text">5. JMM 的实际应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-JMM-%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87"><span class="toc-number">1.6.</span> <span class="toc-text">6. JMM 的设计目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">1.7.</span> <span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">JVM内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">1. JVM 内存结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%A0%86%EF%BC%88Heap%EF%BC%89"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.1 堆（Heap）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%88Method-Area%EF%BC%89"><span class="toc-number">2.1.2.</span> <span class="toc-text">1.2 方法区（Method Area）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%EF%BC%88JVM-Stack%EF%BC%89"><span class="toc-number">2.1.3.</span> <span class="toc-text">1.3 Java 虚拟机栈（JVM Stack）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%EF%BC%88Native-Method-Stack%EF%BC%89"><span class="toc-number">2.1.4.</span> <span class="toc-text">1.4 本地方法栈（Native Method Stack）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88Program-Counter-PC-%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%89"><span class="toc-number">2.1.5.</span> <span class="toc-text">1.5 程序计数器（Program Counter, PC 寄存器）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.2.</span> <span class="toc-text">2. 内存模型中的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-JVM-%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">2.3.</span> <span class="toc-text">3. JVM 的垃圾回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E9%94%99%E8%AF%AF%EF%BC%88OutOfMemoryError-OOM%EF%BC%89"><span class="toc-number">2.4.</span> <span class="toc-text">4. 内存溢出错误（OutOfMemoryError, OOM）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-JVM-%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98"><span class="toc-number">2.5.</span> <span class="toc-text">5. JVM 内存调优</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-1"><span class="toc-number">2.6.</span> <span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%8D%B8%E8%BD%BD"><span class="toc-number">3.</span> <span class="toc-text">说说类加载与卸载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">一、类加载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8A%A0%E8%BD%BD%EF%BC%88Loading%EF%BC%89"><span class="toc-number">3.1.1.</span> <span class="toc-text">1. 加载（Loading）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%BF%9E%E6%8E%A5%EF%BC%88Linking%EF%BC%89"><span class="toc-number">3.1.2.</span> <span class="toc-text">2. 连接（Linking）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88Initialization%EF%BC%89"><span class="toc-number">3.1.3.</span> <span class="toc-text">3. 初始化（Initialization）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="toc-number">3.2.</span> <span class="toc-text">二、类加载的时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%B1%BB%E5%8D%B8%E8%BD%BD%EF%BC%88Unloading%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">三、类卸载（Unloading）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.4.</span> <span class="toc-text">四、类加载器的双亲委派模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">3.4.1.</span> <span class="toc-text">双亲委派机制的优点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E9%81%BF%E5%85%8D%E7%B1%BB%E7%9A%84%E9%87%8D%E5%A4%8D%E5%8A%A0%E8%BD%BD%EF%BC%8C%E4%BF%9D%E8%AF%81%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%BA%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">3.4.1.1.</span> <span class="toc-text">1. 避免类的重复加载，保证核心类库的安全性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%B1%82%E6%AC%A1%E5%8C%96%E7%AE%A1%E7%90%86%E7%B1%BB%E5%8A%A0%E8%BD%BD%EF%BC%8C%E6%8F%90%E9%AB%98%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%92%8C%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7"><span class="toc-number">3.4.1.2.</span> <span class="toc-text">2. 层次化管理类加载，提高系统的稳定性和可维护性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%94%AF%E6%8C%81%E6%A8%A1%E5%9D%97%E5%8C%96%E5%92%8C%E5%8A%A8%E6%80%81%E6%89%A9%E5%B1%95"><span class="toc-number">3.4.1.3.</span> <span class="toc-text">3. 支持模块化和动态扩展</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-OSGi%EF%BC%88Open-Service-Gateway-Initiative%EF%BC%89%E6%A8%A1%E5%9D%97%E5%8C%96%E6%A1%86%E6%9E%B6"><span class="toc-number">3.4.2.</span> <span class="toc-text">1. OSGi（Open Service Gateway Initiative）模块化框架</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Spring-%E6%8F%92%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.4.3.</span> <span class="toc-text">2. Spring 插件系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Tomcat%E3%80%81Jetty-%E7%AD%89-Web-%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">3.4.4.</span> <span class="toc-text">3. Tomcat、Jetty 等 Web 服务器中的类加载机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Maven-%E6%8F%92%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.4.5.</span> <span class="toc-text">4. Maven 插件系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-IDE-%E6%8F%92%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.4.6.</span> <span class="toc-text">5. IDE 插件系统</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">3.5.</span> <span class="toc-text">五、总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">垃圾回收算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95%EF%BC%88Reference-Counting%EF%BC%89"><span class="toc-number">4.1.</span> <span class="toc-text">1. 引用计数算法（Reference Counting）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95%EF%BC%88Mark-Sweep%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">2. 标记-清除算法（Mark-Sweep）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95%EF%BC%88Mark-Compact%EF%BC%89"><span class="toc-number">4.3.</span> <span class="toc-text">3. 标记-整理算法（Mark-Compact）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95%EF%BC%88Copying-Scavenge%EF%BC%89"><span class="toc-number">4.4.</span> <span class="toc-text">4. 复制算法（Copying&#x2F;Scavenge）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%EF%BC%88Generational-Collection%EF%BC%89"><span class="toc-number">4.5.</span> <span class="toc-text">5. 分代收集算法（Generational Collection）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-CMS%EF%BC%88Concurrent-Mark-Sweep%EF%BC%89%E7%AE%97%E6%B3%95"><span class="toc-number">4.6.</span> <span class="toc-text">6. CMS（Concurrent Mark-Sweep）算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-G1%EF%BC%88Garbage-First%EF%BC%89%E7%AE%97%E6%B3%95"><span class="toc-number">4.7.</span> <span class="toc-text">7. G1（Garbage-First）算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-9"><span class="toc-number">4.8.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM-%E5%B8%B8%E7%94%A8%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">5.</span> <span class="toc-text">JVM 常用垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Serial-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">5.1.</span> <span class="toc-text">1. Serial 收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-ParNew-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">5.2.</span> <span class="toc-text">2. ParNew 收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Parallel-Scavenge-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">5.3.</span> <span class="toc-text">3. Parallel Scavenge 收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Serial-Old-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">5.4.</span> <span class="toc-text">4. Serial Old 收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Parallel-Old-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">5.5.</span> <span class="toc-text">5. Parallel Old 收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-CMS%EF%BC%88Concurrent-Mark-Sweep%EF%BC%89%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">5.6.</span> <span class="toc-text">6. CMS（Concurrent Mark-Sweep）收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-G1%EF%BC%88Garbage-First%EF%BC%89%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">5.7.</span> <span class="toc-text">7. G1（Garbage First）收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-ZGC%EF%BC%88Z-Garbage-Collector%EF%BC%89"><span class="toc-number">5.8.</span> <span class="toc-text">8. ZGC（Z Garbage Collector）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-Shenandoah-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">5.9.</span> <span class="toc-text">9. Shenandoah 收集器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-10"><span class="toc-number">5.10.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E6%A0%88%E5%92%8C%E5%A0%86%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.</span> <span class="toc-text">说说栈和堆的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">6.1.</span> <span class="toc-text">1. 内存分配方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%86%85%E5%AD%98%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%92%8C%E9%99%90%E5%88%B6"><span class="toc-number">6.2.</span> <span class="toc-text">2. 内存的大小和限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AD%98%E5%82%A8%E5%86%85%E5%AE%B9"><span class="toc-number">6.3.</span> <span class="toc-text">3. 存储内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">6.4.</span> <span class="toc-text">4. 生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">6.5.</span> <span class="toc-text">5. 线程安全性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6"><span class="toc-number">6.6.</span> <span class="toc-text">6. 访问速度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-GC%EF%BC%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%89%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">6.7.</span> <span class="toc-text">7. GC（垃圾回收）的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%90%8C"><span class="toc-number">6.8.</span> <span class="toc-text">8. 异常类型不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="toc-number">6.9.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-11"><span class="toc-number">6.10.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E8%A7%A6%E5%8F%91FullGC"><span class="toc-number">7.</span> <span class="toc-text">什么时候会触发FullGC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%80%81%E5%B9%B4%E4%BB%A3%EF%BC%88Old-Generation%EF%BC%89%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3"><span class="toc-number">7.1.</span> <span class="toc-text">1. 老年代（Old Generation）空间不足</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-number">7.1.1.</span> <span class="toc-text">触发场景：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B0%B8%E4%B9%85%E4%BB%A3%EF%BC%88PermGen%EF%BC%89%E6%88%96%E5%85%83%E7%A9%BA%E9%97%B4%EF%BC%88Metaspace%EF%BC%89%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3"><span class="toc-number">7.2.</span> <span class="toc-text">2. 永久代（PermGen）或元空间（Metaspace）空间不足</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%9C%BA%E6%99%AF%EF%BC%9A-1"><span class="toc-number">7.2.1.</span> <span class="toc-text">触发场景：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-System-gc-%E7%9A%84%E8%B0%83%E7%94%A8"><span class="toc-number">7.3.</span> <span class="toc-text">3. System.gc() 的调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%9C%BA%E6%99%AF%EF%BC%9A-2"><span class="toc-number">7.3.1.</span> <span class="toc-text">触发场景：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A4%A7%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D%E5%A4%B1%E8%B4%A5%EF%BC%88Promotion-Failure%EF%BC%89"><span class="toc-number">7.4.</span> <span class="toc-text">4. 大对象分配失败（Promotion Failure）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%9C%BA%E6%99%AF%EF%BC%9A-3"><span class="toc-number">7.4.1.</span> <span class="toc-text">触发场景：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D%E6%9C%BA%E5%88%B6%E5%A4%B1%E8%B4%A5%EF%BC%88Allocation-Failure-Handle-Promotion-Failure%EF%BC%89"><span class="toc-number">7.5.</span> <span class="toc-text">5. 空间分配担保机制失败（Allocation Failure&#x2F;Handle Promotion Failure）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%9C%BA%E6%99%AF%EF%BC%9A-4"><span class="toc-number">7.5.1.</span> <span class="toc-text">触发场景：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Concurrent-Mode-Failure%EF%BC%88CMS-%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%89"><span class="toc-number">7.6.</span> <span class="toc-text">6. Concurrent Mode Failure（CMS 收集器）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%9C%BA%E6%99%AF%EF%BC%9A-5"><span class="toc-number">7.6.1.</span> <span class="toc-text">触发场景：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%A0%86%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3"><span class="toc-number">7.7.</span> <span class="toc-text">7. 堆内存不足</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-JVM-%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%90%88%E7%90%86"><span class="toc-number">7.8.</span> <span class="toc-text">8. JVM 参数配置不合理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%9C%BA%E6%99%AF%EF%BC%9A-6"><span class="toc-number">7.8.1.</span> <span class="toc-text">触发场景：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E9%A2%91%E7%B9%81%E7%9A%84-Full-GC%EF%BC%9F"><span class="toc-number">7.9.</span> <span class="toc-text">如何避免频繁的 Full GC？</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/20/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="算法学习笔记">算法学习笔记</a><time datetime="2024-09-21T02:41:32.000Z" title="Created 2024-09-20 22:41:32">2024-09-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/15/JAVA%E9%9D%A2%E8%AF%95Spring%E7%AF%87/" title="JAVA面试八股文Spring篇">JAVA面试八股文Spring篇</a><time datetime="2024-09-16T01:52:32.000Z" title="Created 2024-09-15 21:52:32">2024-09-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/15/JAVA%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/" title="JAVA面试八股文基础篇">JAVA面试八股文基础篇</a><time datetime="2024-09-16T01:52:32.000Z" title="Created 2024-09-15 21:52:32">2024-09-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/10/%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" title="鸟哥的Linux实战阅读笔记">鸟哥的Linux实战阅读笔记</a><time datetime="2024-08-10T21:46:35.000Z" title="Created 2024-08-10 17:46:35">2024-08-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/05/Linux%E5%85%A5%E9%97%A8/" title="Linux入门">Linux入门</a><time datetime="2024-08-05T18:33:56.000Z" title="Created 2024-08-05 14:33:56">2024-08-05</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2024 By DrJuly2333</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async src="/js/title.js"></script><script defer src="https://rmt.dogedoge.com/fetch/~/source/jsdelivr/npm/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="https://cdn.jsdelivr.net/gh/sirxemic/jquery.ripples/dist/jquery.ripples.js"></script><script defer data-pjax src="/js/ripples.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>