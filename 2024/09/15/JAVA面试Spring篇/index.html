<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JAVA面试八股文Spring篇 | DrJuly</title><meta name="author" content="DrJuly2333"><meta name="copyright" content="DrJuly2333"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[TOC]  什么是Spring框架，包含哪些模块Spring是一个轻量级的JavaEE框架，它主要解决企业应用中的复杂性问题。Spring框架有三个核心部分：IoC容器、AOP和数据访问&#x2F;集成层。Spring中的IoC容器提供了一种对象创建和对象之间关系管理的机制（没有容器之前需要手动创建对象，并且解决对象间的依赖关系），以实现松散耦合和可扩展性。AOP提供了一种很好的方式来实现横向关">
<meta property="og:type" content="article">
<meta property="og:title" content="JAVA面试八股文Spring篇">
<meta property="og:url" content="http://example.com/2024/09/15/JAVA%E9%9D%A2%E8%AF%95Spring%E7%AF%87/index.html">
<meta property="og:site_name" content="DrJuly">
<meta property="og:description" content="[TOC]  什么是Spring框架，包含哪些模块Spring是一个轻量级的JavaEE框架，它主要解决企业应用中的复杂性问题。Spring框架有三个核心部分：IoC容器、AOP和数据访问&#x2F;集成层。Spring中的IoC容器提供了一种对象创建和对象之间关系管理的机制（没有容器之前需要手动创建对象，并且解决对象间的依赖关系），以实现松散耦合和可扩展性。AOP提供了一种很好的方式来实现横向关">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/avatar.png">
<meta property="article:published_time" content="2024-09-16T01:52:32.000Z">
<meta property="article:modified_time" content="2024-09-19T12:23:43.000Z">
<meta property="article:author" content="DrJuly2333">
<meta property="article:tag" content="JAVA">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/avatar.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/09/15/JAVA%E9%9D%A2%E8%AF%95Spring%E7%AF%87/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?95d98ba73784092d75263482b3e4ecc4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JAVA面试八股文Spring篇',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-19 08:23:43'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="DrJuly"><span class="site-name">DrJuly</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JAVA面试八股文Spring篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-09-16T01:52:32.000Z" title="Created 2024-09-15 21:52:32">2024-09-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-09-19T12:23:43.000Z" title="Updated 2024-09-19 08:23:43">2024-09-19</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">13.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>54mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JAVA面试八股文Spring篇"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>[TOC] </p>
<h2 id="什么是Spring框架，包含哪些模块"><a href="#什么是Spring框架，包含哪些模块" class="headerlink" title="什么是Spring框架，包含哪些模块"></a>什么是Spring框架，包含哪些模块</h2><p>Spring是一个轻量级的JavaEE框架，它主要解决企业应用中的复杂性问题。Spring框架有三个核心部分：<strong>IoC容器</strong>、<strong>AOP</strong>和<strong>数据访问&#x2F;集成层</strong>。Spring中的IoC容器提供了一种对象创建和对象之间关系管理的机制（<code>没有容器之前需要手动创建对象，并且解决对象间的依赖关系</code>），以实现松散耦合和可扩展性。AOP提供了一种很好的方式来实现横向关注点的处理，如事务管理、安全检查、缓存等。数据访问&#x2F;集成层则提供了许多针对不同数据持久化技术的实现，如JDBC、ORM和NoSQL。</p>
<blockquote>
<p>假如有一百个方法，我需要在这些方法中添加某些固定逻辑，比如日志处理，不可能每个方法都去修改，这时候可以使用Spring AOP切面的方式，将每个方法都切入进去。</p>
<p>AOP使得开发者可以通过声明式的方式来处理切面逻辑，而不需要侵入业务代码</p>
</blockquote>
<p>Spring框架本身亦是按照<strong>设计模式</strong>精心打造，这使得我们可以在开发环境中安心的集成Spring框架，不必担心Spring是如何在后台进行工作的。Spring框架至今已集成了20多个模块。这些模块主要被分成核心容器、数据访问&#x2F;集成、Web、AOP、工具、消息和测试模块。</p>
<p><img src="https://www.helloimg.com/i/2024/09/18/66eab8dc30935.png"></p>
<p>Spring框架包含多个模块，覆盖了各个方面的开发需求。以下是Spring框架的主要模块：</p>
<h3 id="1-Core-Container（核心容器）"><a href="#1-Core-Container（核心容器）" class="headerlink" title="1. Core Container（核心容器）"></a>1. <strong>Core Container（核心容器）</strong></h3><ul>
<li><strong>Spring Core</strong>（重点）：提供依赖注入（DI）功能，是整个框架的基础。</li>
<li><strong>Spring Beans</strong>（重点）：负责管理Spring中的Bean（Java对象）的创建、配置和生命周期。</li>
<li><strong>Spring Context</strong>（重点）：是BeanFactory的扩展，提供更高级的容器功能，如国际化支持、事件传播、资源访问等。</li>
<li>**Spring Expression Language (SpEL)**：用于在XML或注解中动态解析表达式。</li>
</ul>
<h3 id="2-AOP-Aspect-Oriented-Programming"><a href="#2-AOP-Aspect-Oriented-Programming" class="headerlink" title="2. AOP (Aspect-Oriented Programming)"></a>2. <strong>AOP (Aspect-Oriented Programming)</strong></h3><ul>
<li><strong>Spring AOP</strong>（重点）：提供面向切面编程的支持，允许开发者通过横切关注点（如日志记录、事务管理）将功能与业务逻辑分离。</li>
<li><strong>AspectJ</strong>：Spring支持AspectJ作为AOP实现之一，提供了更强大的AOP功能。</li>
</ul>
<h3 id="3-Data-Access-Integration（数据访问和集成）"><a href="#3-Data-Access-Integration（数据访问和集成）" class="headerlink" title="3. Data Access&#x2F;Integration（数据访问和集成）"></a>3. <strong>Data Access&#x2F;Integration（数据访问和集成）</strong></h3><ul>
<li><strong>Spring JDBC</strong>（重点）：简化了JDBC操作，提供模板方法来减少样板代码。</li>
<li><strong>Spring ORM</strong>（重点）：为流行的ORM框架（如Hibernate、JPA、MyBatis）提供集成支持。</li>
</ul>
<h3 id="4-Web"><a href="#4-Web" class="headerlink" title="4. Web"></a>4. <strong>Web</strong></h3><ul>
<li><strong>Spring Web</strong>（重点）：为Web开发提供了基本的支持，包含了Servlet、WebSocket等功能。</li>
<li><strong>Spring MVC</strong>：提供了Model-View-Controller模式的Web框架，用于构建REST API和Web应用。</li>
</ul>
<blockquote>
<p>除了以上内容，为了对Spring有一个更广义的理解，还需要记住两个名词：生态和基石</p>
<p><strong>生态</strong>：现在企业开发过程中，可能很少会用原生的Spring或者原生的SSM框架这样的方式，更多的可能是SpringBoot或者Spring Cloud这些，包括Spring Data JPA和Spring Security等一系列Spring所延伸出来的一些组件，他们共同组成了Spring全家桶。</p>
<p><strong>基石</strong>：在Spring的整个生态体系里边，Spring体现了一个最基础的支撑作用。</p>
<p>源码阅读顺序：Spring、SpringMVC、SpringBoot、Spring Cloud、MyBatis</p>
</blockquote>
<hr>
<h2 id="Spring有哪些优点"><a href="#Spring有哪些优点" class="headerlink" title="Spring有哪些优点"></a>Spring有哪些优点</h2><p><strong>轻量级</strong>：Spring在大小和透明性方面绝对属于轻量级的，运行时占用资源较少，基础版本的Spring框架大约只有2MB。</p>
<p><strong>控制反转（IoC）</strong>：Spring使用控制反转技术实现了松耦合。依赖被注入到对象，而不是创建或寻找依赖对象。</p>
<p><strong>面向切面编程（AOP）</strong>：Spring的AOP支持可以将像日志记录、事务管理、安全性等与业务逻辑无关的代码从主业务逻辑中分离，使得代码更清晰，并且容易维护和扩展。</p>
<p><strong>容器</strong>：Spring包含并管理应用程序对象的配置及生命周期。</p>
<p><strong>MVC框架</strong>：提供强大的MVC框架，适用于构建RESTful API和Web应用。通过注解简化控制器、模型和视图的开发。</p>
<p><strong>事务管理</strong>：Spring提供了强大的事务管理支持，允许开发者通过简单的注解或XML配置来处理复杂的事务逻辑，而无需手动管理事务边界。支持JDBC、JPA、Hibernate等多种数据访问技术。</p>
<p><strong>扩展性</strong>：Spring框架提供了多种模块（如Spring MVC、Spring Data、Spring Security、Spring Batch等），覆盖了Web开发、数据访问、安全、事务、消息传递等多个领域，这些都是在Spring基础上扩展来的。</p>
<p><strong>灵活的持久化机制</strong>：Spring提供与各种持久化框架（如JPA、Hibernate、MyBatis、JDBC）的集成，简化了数据访问层的开发。</p>
<hr>
<h2 id="什么是控制反转（IoC）？什么是依赖注入？"><a href="#什么是控制反转（IoC）？什么是依赖注入？" class="headerlink" title="什么是控制反转（IoC）？什么是依赖注入？"></a>什么是控制反转（IoC）？什么是依赖注入？</h2><blockquote>
<p>控制反转不是一种技术，而是一种设计思想，依赖注入是控制反转的一种具体实现</p>
</blockquote>
<h3 id="控制反转（Inversion-of-Control，IoC）"><a href="#控制反转（Inversion-of-Control，IoC）" class="headerlink" title="控制反转（Inversion of Control，IoC）"></a>控制反转（Inversion of Control，IoC）</h3><p><strong>控制反转（IoC）</strong> 是一种设计原则，核心思想是将对象的创建和依赖关系的管理从程序代码中转移到外部系统或框架中。通常在传统编程中，应用程序代码是主动创建和管理依赖对象的，但在IoC中，这个控制权被<code>反转</code>给了外部框架（如Spring），应用程序只是声明自己需要哪些依赖，框架则负责这些依赖的创建和注入。</p>
<p>在<strong>IoC</strong>的模式下：</p>
<ul>
<li><strong>谁控制对象的创建</strong>：在传统编程中，应用程序本身负责创建对象，而在IoC中，Spring框架等容器负责对象的创建。</li>
<li><strong>何时创建对象</strong>：在传统编程中，应用程序主动在需要时创建对象，而在IoC中，框架在启动时就会创建和管理对象，并根据需要在适当时刻将其交给应用程序使用。</li>
</ul>
<p>IoC常用于解耦对象之间的关系，尤其在大型应用中，减少对象直接依赖彼此的细节，从而使得代码更加灵活和易维护。</p>
<h3 id="依赖注入（Dependency-Injection，DI）"><a href="#依赖注入（Dependency-Injection，DI）" class="headerlink" title="依赖注入（Dependency Injection，DI）"></a>依赖注入（Dependency Injection，DI）</h3><p><strong>依赖注入（DI）</strong> 是<strong>实现IoC的一种方式</strong>。在依赖注入中，应用程序通过外部框架（例如Spring）自动将所需的依赖对象注入到类中，而不是自己主动创建依赖对象。依赖注入可以通过<strong>构造器注入</strong>、<strong>Setter方法注入</strong>或<strong>字段注入</strong>来实现。</p>
<h4 id="依赖注入的几种方式："><a href="#依赖注入的几种方式：" class="headerlink" title="依赖注入的几种方式："></a>依赖注入的几种方式：</h4><ol>
<li><p><strong>构造器注入（Constructor Injection）</strong>：</p>
<ul>
<li>通过类的<strong>构造方法</strong>注入依赖。在对象创建时，将所需的依赖对象传递给构造器，这种方式适合强制性依赖，因为在类实例化时就必须提供所有依赖。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>强制依赖传递</strong>：所有必需的依赖在对象创建时被提供，确保依赖不会遗漏。</li>
<li><strong>不可变性</strong>：通过构造器注入的依赖可以设置为不可变，使对象的状态更加稳定。</li>
<li><strong>便于测试</strong>：通过构造器注入可以轻松模拟依赖，进行单元测试。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>       <span class="hljs-keyword">private</span> Engine engine;<br>   <br>       <span class="hljs-comment">// 通过构造器注入依赖</span><br>       <span class="hljs-keyword">public</span> <span class="hljs-title function_">Car</span><span class="hljs-params">(Engine engine)</span> &#123;<br>           <span class="hljs-built_in">this</span>.engine = engine;<br>       &#125;<br>       <br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span> &#123;<br>           System.out.println(<span class="hljs-string">&quot;Driving with engine: &quot;</span> + engine.getType());<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>

<p>在这个示例中，<code>Car</code> 类通过构造器接收 <code>Engine</code> 依赖。</p>
</li>
<li><p><strong>Setter方法注入（Setter Injection）</strong>：</p>
<ul>
<li>通过<strong>Setter方法</strong>注入依赖，外部框架在对象创建后通过调用Setter方法传递依赖对象。这种方式适合可选的依赖或不要求在对象创建时传递的依赖。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>灵活性高</strong>：可以在对象创建后随时注入依赖，允许可选的依赖。</li>
<li><strong>易于配置</strong>：可以根据具体情况使用配置文件或注解动态注入依赖。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>可能导致依赖不完整</strong>：由于依赖可以在对象创建后注入，可能存在依赖未注入就使用对象的风险。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>       <span class="hljs-keyword">private</span> Engine engine;<br>   <br>       <span class="hljs-comment">// 通过Setter方法注入依赖</span><br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setEngine</span><span class="hljs-params">(Engine engine)</span> &#123;<br>           <span class="hljs-built_in">this</span>.engine = engine;<br>       &#125;<br>       <br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span> &#123;<br>           System.out.println(<span class="hljs-string">&quot;Driving with engine: &quot;</span> + engine.getType());<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>

<p>在这个示例中，<code>Car</code> 类通过 <code>setEngine()</code> 方法接收 <code>Engine</code> 依赖。</p>
</li>
<li><p><strong>字段注入（Field Injection）</strong>：</p>
<ul>
<li>依赖直接通过<strong>字段</strong>注入，不需要构造器或Setter方法。通常使用框架提供的注解（如Spring中的<code>@Autowired</code>）来实现。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>简洁直观</strong>：无需构造器或Setter方法，注入方式简单。</li>
<li><strong>减少样板代码</strong>：不需要写构造器和Setter方法，简化代码。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>封装性差</strong>：打破了类的封装性，因为依赖直接注入到类的私有字段。</li>
<li><strong>不利于测试</strong>：字段注入在单元测试中很难进行依赖的模拟，不如构造器或Setter方法灵活。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>       <span class="hljs-meta">@Autowired</span><br>       <span class="hljs-keyword">private</span> Engine engine;  <span class="hljs-comment">// 直接通过字段注入依赖</span><br>   <br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span> &#123;<br>           System.out.println(<span class="hljs-string">&quot;Driving with engine: &quot;</span> + engine.getType());<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>

<p>在这个示例中，<code>Car</code> 类直接在 <code>engine</code> 字段上注入 <code>Engine</code> 依赖。</p>
</li>
<li><p><strong>接口注入（Interface Injection）</strong></p>
<p>在接口注入中，类通过实现一个特定的接口来接收依赖，外部框架会通过调用该接口的注入方法来传递依赖对象。尽管这种方式理论上可行，但在实际开发中很少使用，因为它增加了类与接口的耦合。</p>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>接口驱动的设计</strong>：使得依赖注入更加明确，表明某个类需要某个依赖。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>侵入性强</strong>：类需要实现特定的接口，增加了耦合，违反了单一职责原则。</li>
<li><strong>使用少</strong>：不如构造器注入或Setter注入常见，主流框架也较少推荐这种方式。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EngineAware</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setEngine</span><span class="hljs-params">(Engine engine)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">EngineAware</span> &#123;<br>    <span class="hljs-keyword">private</span> Engine engine;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setEngine</span><span class="hljs-params">(Engine engine)</span> &#123;<br>        <span class="hljs-built_in">this</span>.engine = engine;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Driving with engine: &quot;</span> + engine.getType());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个示例中，<code>Car</code> 类实现了 <code>EngineAware</code> 接口，通过接口方法 <code>setEngine</code> 来接收 <code>Engine</code> 依赖。</p>
</li>
</ol>
<h3 id="IoC和DI的关系"><a href="#IoC和DI的关系" class="headerlink" title="IoC和DI的关系"></a>IoC和DI的关系</h3><p><strong>IoC</strong> 是一个广义的概念，指的是将对象的控制权从应用程序反转给框架，而 <strong>DI</strong> 是实现IoC的一种方式。依赖注入是具体的实现机制，通过注入依赖对象的方式，减少了对象之间的耦合，从而实现了控制反转。</p>
<p>通过IoC和DI的使用，程序中对象的创建和依赖关系的管理可以由框架自动处理，开发者只需专注于业务逻辑，减少了代码的复杂性，并提升了代码的可测试性和可维护性。</p>
<hr>
<h2 id="谈一下你对Spring-IoC的理解"><a href="#谈一下你对Spring-IoC的理解" class="headerlink" title="谈一下你对Spring IoC的理解"></a>谈一下你对Spring IoC的理解</h2><p>Spring的IOC，即lnversion of Control，也就是控制反转，是Spring框架的核心特性之一。其主要思想是将原本在代码中直接操控的对象的调用权交给Spring容器来管理，从而降低了代码之间的耦合度，提高了程序的可维护性和可扩展性。</p>
<p>在传统的lava开发中，我们通常在代码中直接new一个对象来调用其方法。但这种方式会导致代码之间的耦合度过高，一旦某个类发生改变，可能会影响到很多其他的类。而Spring的I0C解决了这个问题，它将对象的创建和生命周期管理交给了Spring容器来负责。我们只需要在配置文件中配置好相应的Bean，然后就可以在需要的地方通过Spring容器来获取这个Bean，而不需要关心它的创建和销毁过程。</p>
<p>Spring IoC容器的主要接口是<code>BeanFactory</code>和它的子接口<code>ApplicationContext</code>。其中，<code>ApplicationContext</code>是功能更强大的容器，提供了更多的扩展功能，例如事件传播、国际化、Bean的自动扫描和Spring AOP的集成等。</p>
<blockquote>
<p><strong>简要回答：整个IOC容器创建的流程和步骤如下:</strong></p>
<p>1、一般聊ioc容器的时候要涉及到容器的创建过程（<code>beanFactory</code>，<code>DefaultListableBeanFactory</code>），向bean工厂中设置一些参数(<code>BeanPostProcessor</code>，<code>Aware</code>接囗的子类)等等属性。</p>
<p>2、加载解析bean对象，准备要创建的bean对象的定义对象beanDefinition（xml或者注解的解析过程）</p>
<p>3、beanFactoryPostProcessor的处理，此处是扩展点，PlaceHolderConfigurSupport，ConfigurationClassPostProcessor</p>
<p>4、BeanPostProcessor的注册功能，方便后续对bean对象完成具体的扩展功能</p>
<p>5、通过反射的方式讲BeanDefinition对象实例化成具体的bean对象</p>
<p>6、bean对象的初始化过程（填充属性，调用aware子类的方法，调用<code>BeanPostProcessor</code><strong>前置</strong>处理方法，调用<code>init-mehtod</code>方法，调用BeanPostProcessor的<strong>后置</strong>处理方法）</p>
<p>7、生成完整的bean对象，通过getBean方法可以直接获取</p>
<p>8、销毁过程</p>
</blockquote>
<h3 id="1-IoC容器的创建：BeanFactory-和-DefaultListableBeanFactory"><a href="#1-IoC容器的创建：BeanFactory-和-DefaultListableBeanFactory" class="headerlink" title="1. IoC容器的创建：BeanFactory 和 DefaultListableBeanFactory"></a>1. <strong>IoC容器的创建：<code>BeanFactory</code> 和 <code>DefaultListableBeanFactory</code></strong></h3><p>Spring IoC容器的创建通常始于 <code>BeanFactory</code> 接口的实现类。<code>DefaultListableBeanFactory</code> 是Spring框架中最常用的Bean工厂实现，它负责Bean的注册、管理和创建。</p>
<p>在容器创建时，Spring会实例化 <code>DefaultListableBeanFactory</code>，并设置一些关键的处理器和属性：</p>
<ul>
<li>**<code>BeanPostProcessor</code>**：用于在Bean实例化前后执行额外的处理逻辑。后面会在Bean的生命周期中详细介绍。</li>
<li><strong><code>Aware</code> 接口的子类</strong>：<code>Aware</code>接口允许Bean通过容器了解自己在Spring容器中的信息，如获取容器上下文、类加载器等。</li>
</ul>
<p><strong>关键点</strong>：</p>
<ul>
<li>创建 <code>DefaultListableBeanFactory</code> 实例。</li>
<li>向 <code>BeanFactory</code> 中注册各种配置和处理器，例如 <code>BeanPostProcessor</code> 和 <code>Aware</code> 子类。</li>
</ul>
<h3 id="2-加载和解析Bean定义：BeanDefinition"><a href="#2-加载和解析Bean定义：BeanDefinition" class="headerlink" title="2. 加载和解析Bean定义：BeanDefinition"></a>2. <strong>加载和解析Bean定义：<code>BeanDefinition</code></strong></h3><p>容器创建完成后，Spring会加载应用程序的Bean定义。这些Bean定义可以通过XML文件、注解、Java配置类等方式指定，解析后生成 <code>BeanDefinition</code> 对象。</p>
<p><code>BeanDefinition</code> 是一个描述Bean对象的配置元数据对象，包含Bean的类型、作用域、依赖关系、初始化方法、销毁方法等信息。Spring会根据这些定义对象来管理Bean的创建和生命周期。</p>
<p><strong>关键点</strong>：</p>
<ul>
<li>解析配置源（XML、注解、Java配置类等），生成 <code>BeanDefinition</code> 对象。</li>
<li><code>BeanDefinition</code> 包含了Bean的所有配置信息，后续步骤根据这些定义创建Bean。</li>
</ul>
<h3 id="3-处理-BeanFactoryPostProcessor"><a href="#3-处理-BeanFactoryPostProcessor" class="headerlink" title="3. 处理 BeanFactoryPostProcessor"></a>3. <strong>处理 <code>BeanFactoryPostProcessor</code></strong></h3><p><code>BeanFactoryPostProcessor</code> 是Spring IoC容器的扩展点，允许开发者在容器实例化Bean之前修改Bean的定义元数据。比如，Spring中常见的 <code>PropertyPlaceholderConfigurer</code> 就是一个典型的 <code>BeanFactoryPostProcessor</code>，用于解析占位符（如 <code>$&#123;&#125;</code>）并替换为配置中的实际值。</p>
<p>常见的 <code>BeanFactoryPostProcessor</code> 实现包括：</p>
<ul>
<li>**<code>PropertyPlaceholderConfigurer</code>**：解析占位符。</li>
<li>**<code>ConfigurationClassPostProcessor</code>**：处理<code>@Configuration</code>注解及相关的Java配置类。</li>
</ul>
<p><strong>关键点</strong>：</p>
<ul>
<li><code>BeanFactoryPostProcessor</code> 可以在Bean实例化之前修改 <code>BeanDefinition</code> 对象。</li>
<li>Spring会在这个阶段调用所有注册的 <code>BeanFactoryPostProcessor</code>。</li>
</ul>
<h3 id="4-注册-BeanPostProcessor"><a href="#4-注册-BeanPostProcessor" class="headerlink" title="4. 注册 BeanPostProcessor"></a>4. <strong>注册 <code>BeanPostProcessor</code></strong></h3><p><code>BeanPostProcessor</code> 是另一个扩展点，允许开发者在Bean实例化和初始化过程中对Bean进行增强。Spring会在这个阶段注册所有的 <code>BeanPostProcessor</code>，以便后续在Bean创建时执行它们。</p>
<p>常见的 <code>BeanPostProcessor</code> 包括：</p>
<ul>
<li><strong><code>@Autowired</code> 注解处理器</strong>：处理自动注入依赖。</li>
<li><strong>AOP 代理创建器</strong>：对Bean进行AOP代理，增强Bean的方法调用。</li>
</ul>
<p><strong>关键点</strong>：</p>
<ul>
<li>Spring在这个阶段注册所有 <code>BeanPostProcessor</code>，为后续的Bean生命周期阶段提供扩展支持。</li>
</ul>
<h3 id="5-实例化Bean：通过反射创建Bean对象"><a href="#5-实例化Bean：通过反射创建Bean对象" class="headerlink" title="5. 实例化Bean：通过反射创建Bean对象"></a>5. <strong>实例化Bean：通过反射创建Bean对象</strong></h3><p>在加载完 <code>BeanDefinition</code> 并注册了 <code>BeanPostProcessor</code> 之后，Spring容器会开始实例化Bean对象。Spring使用反射机制，根据 <code>BeanDefinition</code> 中的配置信息创建Bean实例。</p>
<p><strong>关键点</strong>：</p>
<ul>
<li>通过反射机制创建Bean实例。</li>
<li>如果Bean有构造函数注入（如构造器注入），Spring会根据构造函数参数创建依赖并注入。</li>
</ul>
<h3 id="6-Bean的初始化过程"><a href="#6-Bean的初始化过程" class="headerlink" title="6. Bean的初始化过程"></a>6. <strong>Bean的初始化过程</strong></h3><p>在Bean被实例化后，Spring还会执行一系列的初始化操作，这包括：</p>
<ul>
<li><strong>属性填充</strong>：通过依赖注入（Setter方法或字段注入），Spring将依赖对象注入到Bean中。</li>
<li><strong>调用 <code>Aware</code> 接口</strong>：如果Bean实现了Spring的 <code>Aware</code> 接口，Spring会注入相应的资源，比如 <code>ApplicationContextAware</code>、<code>BeanNameAware</code>等。</li>
<li><strong>调用 <code>BeanPostProcessor</code> 的前置处理方法</strong>：Spring会调用 <code>BeanPostProcessor</code> 的 <code>postProcessBeforeInitialization()</code> 方法，允许开发者在Bean初始化之前对其进行定制化处理。</li>
<li><strong>调用初始化方法</strong>：如果Bean定义了初始化方法（如 <code>init-method</code> 或实现 <code>InitializingBean</code> 接口），Spring会在这个阶段调用这些初始化方法。</li>
<li><strong>调用 <code>BeanPostProcessor</code> 的后置处理方法</strong>：Spring会调用 <code>BeanPostProcessor</code> 的 <code>postProcessAfterInitialization()</code> 方法，允许在Bean初始化之后进行进一步增强。</li>
</ul>
<p><strong>关键点</strong>：</p>
<ul>
<li>注入属性、依赖。</li>
<li>调用 <code>Aware</code> 接口。</li>
<li>调用 <code>BeanPostProcessor</code> 的前置和后置处理方法。</li>
<li>调用初始化方法（如 <code>init-method</code>）。</li>
</ul>
<h3 id="7-获取完整的Bean对象"><a href="#7-获取完整的Bean对象" class="headerlink" title="7. 获取完整的Bean对象"></a>7. <strong>获取完整的Bean对象</strong></h3><p>经过以上所有步骤之后，Bean已经完全初始化，Spring容器可以将这个完整的Bean交付给应用程序使用。应用程序可以通过 <code>getBean()</code> 方法获取Bean对象并使用它。</p>
<p><strong>关键点</strong>：</p>
<ul>
<li><code>getBean()</code> 方法返回已经完全初始化并可供使用的Bean实例。</li>
</ul>
<h3 id="8-Bean的销毁过程"><a href="#8-Bean的销毁过程" class="headerlink" title="8. Bean的销毁过程"></a>8. <strong>Bean的销毁过程</strong></h3><p>当Spring容器关闭时，所有作用域为 <code>singleton</code> 的Bean都会被销毁。Spring在销毁Bean时会调用预先定义的销毁方法（如 <code>destroy-method</code>）或 <code>DisposableBean</code> 接口的 <code>destroy()</code> 方法。</p>
<p><strong>关键点</strong>：</p>
<ul>
<li>容器关闭时，Spring会调用Bean的销毁方法，释放资源，完成Bean的生命周期。</li>
</ul>
<hr>
<h3 id="源码分析（可选）："><a href="#源码分析（可选）：" class="headerlink" title="源码分析（可选）："></a>源码分析（可选）：</h3><p><strong>整个容器启动的核心流程</strong></p>
<ul>
<li>org.springframework.context.support.AbstractApplicationContext#refresh()方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    *前戏，做容器删新前的准备工作</span><br><span class="hljs-comment">    *1、设置容器的启动时间</span><br><span class="hljs-comment">    *2、设置活跃状态为true</span><br><span class="hljs-comment">    *3、设置关闭状态为false</span><br><span class="hljs-comment">    *4、获取Environment对象，并加载当前系统的属性值到Environment对象中*5、准备监听器和事件的集合对象，默认为空的集合</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refresh</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException, IllegalStateException &#123;<br>    <span class="hljs-built_in">this</span>.startupShutdownLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">this</span>.startupShutdownThread = Thread.currentThread();<br><br>        <span class="hljs-type">StartupStep</span> <span class="hljs-variable">contextRefresh</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.applicationStartup.start(<span class="hljs-string">&quot;spring.context.refresh&quot;</span>);<br><br>        <span class="hljs-comment">// Prepare this context for refreshing.</span><br>        <span class="hljs-comment">// 准备刷新，创建容器之前做的一些最基本的操作</span><br>        prepareRefresh();<br><br>        <span class="hljs-comment">// Tell the subclass to refresh the internal bean factory.</span><br>        <span class="hljs-comment">// 创建容器对象：DefaultListableBeanFactory </span><br>        <span class="hljs-comment">// 价值XML配置文件的属性值到当前工厂中，最重要的属性就是 BeanDefinition</span><br>        <span class="hljs-type">ConfigurableListableBeanFactory</span> <span class="hljs-variable">beanFactory</span> <span class="hljs-operator">=</span> obtainFreshBeanFactory();<br><br>        <span class="hljs-comment">// Prepare the bean factory for use in this context.</span><br>        <span class="hljs-comment">// beanFactory的准备工作，对各种属性进行填充</span><br>        prepareBeanFactory(beanFactory);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// Allows post-processing of the bean factory in context subclasses.</span><br>            <span class="hljs-comment">// 空方法，子类覆盖方法做额外的处理，模板方法设计模式</span><br>            postProcessBeanFactory(beanFactory);<br><br>            <span class="hljs-type">StartupStep</span> <span class="hljs-variable">beanPostProcess</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.applicationStartup.start(<span class="hljs-string">&quot;spring.context.beans.post-process&quot;</span>);<br>            <span class="hljs-comment">// Invoke factory processors registered as beans in the context.</span><br>            <span class="hljs-comment">// 调用各种beanFactory处理器，可以做一些增强功能</span><br>            invokeBeanFactoryPostProcessors(beanFactory);<br>            <span class="hljs-comment">// Register bean processors that intercept bean creation.</span><br>            <span class="hljs-comment">// 注册bean处理器，这里只是注册功能，真正调用的是getBean方法</span><br>            <span class="hljs-comment">// 可以对Bean做一些增强，比如AOP</span><br>            registerBeanPostProcessors(beanFactory);<br>            beanPostProcess.end();<br><br>            <span class="hljs-comment">// Initialize message source for this context.</span><br>            <span class="hljs-comment">// 为上下文初始化message源，即不同语言的消息体，国际化处理</span><br>            initMessageSource();<br><br>            <span class="hljs-comment">// Initialize event multicaster for this context.</span><br>            <span class="hljs-comment">// 初始化事件监听多路广播器，结合下面的registerListeners()方法看，。观察者模式</span><br>            initApplicationEventMulticaster();<br><br>            <span class="hljs-comment">// Initialize other special beans in specific context subclasses.</span><br>            <span class="hljs-comment">// 留给子类来初始化其他Bean</span><br>            <span class="hljs-comment">// SpringBoot 内置Tomcat就是用这方法实现的</span><br>            onRefresh();<br><br>            <span class="hljs-comment">// Check for listener beans and register them.</span><br>            <span class="hljs-comment">// 在所有注册的bean中查找Listener bean，注册到消息广播器中</span><br>            registerListeners();<br><br>            <span class="hljs-comment">// Instantiate all remaining (non-lazy-init) singletons.</span><br>            <span class="hljs-comment">// 初始化剩下的单实例（非懒加载的）</span><br>            finishBeanFactoryInitialization(beanFactory);<br><br>            <span class="hljs-comment">// Last step: publish corresponding event.</span><br>            <span class="hljs-comment">// 完成刷新过程，通知生命周期处理器 lifecycleProcessor刷新过程，同时发出ContextRefreshEvent通知别人</span><br>            finishRefresh();<br>        &#125;<br><br>        <span class="hljs-keyword">catch</span> (RuntimeException | Error ex ) &#123;<br>            <span class="hljs-keyword">if</span> (logger.isWarnEnabled()) &#123;<br>                logger.warn(<span class="hljs-string">&quot;Exception encountered during context initialization - &quot;</span> +<br>                            <span class="hljs-string">&quot;cancelling refresh attempt: &quot;</span> + ex);<br>            &#125;<br><br>            <span class="hljs-comment">// Destroy already created singletons to avoid dangling resources.</span><br>            <span class="hljs-comment">// 异常时销毁已经生成的单例bean，防止资源占用</span><br>            destroyBeans();<br><br>            <span class="hljs-comment">// Reset &#x27;active&#x27; flag.</span><br>            <span class="hljs-comment">// 重置active标志</span><br>            cancelRefresh(ex);<br><br>            <span class="hljs-comment">// Propagate exception to caller.</span><br>            <span class="hljs-keyword">throw</span> ex;<br>        &#125;<br><br>        <span class="hljs-keyword">finally</span> &#123;<br>            contextRefresh.end();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-built_in">this</span>.startupShutdownThread = <span class="hljs-literal">null</span>;<br>        <span class="hljs-built_in">this</span>.startupShutdownLock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>prepareRefresh()方法</strong>：创建容器之前做的一些最基本的操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Prepare this context for refreshing, setting its startup date and</span><br><span class="hljs-comment"> * active flag as well as performing any initialization of property sources.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepareRefresh</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-comment">// Switch to active.</span><br>       <span class="hljs-comment">// 设置容器启动时间</span><br>       <span class="hljs-built_in">this</span>.startupDate = System.currentTimeMillis();<br>       <span class="hljs-comment">// 容器关闭标志位</span><br>       <span class="hljs-built_in">this</span>.closed.set(<span class="hljs-literal">false</span>);<br>       <span class="hljs-comment">// 容器激活标志位</span><br>       <span class="hljs-built_in">this</span>.active.set(<span class="hljs-literal">true</span>);<br><br>       <span class="hljs-comment">// 记录日志</span><br>       <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>           <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>               logger.trace(<span class="hljs-string">&quot;Refreshing &quot;</span> + <span class="hljs-built_in">this</span>);<br>           &#125;<br>           <span class="hljs-keyword">else</span> &#123;<br>               logger.debug(<span class="hljs-string">&quot;Refreshing &quot;</span> + getDisplayName());<br>           &#125;<br>       &#125;<br><br>       <span class="hljs-comment">// Initialize any placeholder property sources in the context environment.</span><br>       <span class="hljs-comment">// 留给子类覆盖，初始化属性资源</span><br>       initPropertySources();<br><br>       <span class="hljs-comment">// Validate that all properties marked as required are resolvable:</span><br>       <span class="hljs-comment">// see ConfigurablePropertyResolver#setRequiredProperties</span><br>       <span class="hljs-comment">// 创建并获取环境对象，验证需要的属性文件是否都已经放入环境中</span><br>       getEnvironment().validateRequiredProperties();<br><br>       <span class="hljs-comment">// Store pre-refresh ApplicationListeners...</span><br>       <span class="hljs-comment">// 判断刷新前的应用程序监听器集合是否为空，如果为空，则将监听器添加到集合中</span><br>       <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.earlyApplicationListeners == <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-built_in">this</span>.earlyApplicationListeners = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;(<span class="hljs-built_in">this</span>.applicationListeners);<br>       &#125;<br>       <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-comment">// Reset local application listeners to pre-refresh state.</span><br>           <span class="hljs-comment">// 如果不为空，则清空集合对象</span><br>           <span class="hljs-built_in">this</span>.applicationListeners.clear();<br>           <span class="hljs-built_in">this</span>.applicationListeners.addAll(<span class="hljs-built_in">this</span>.earlyApplicationListeners);<br>       &#125;<br><br>       <span class="hljs-comment">// Allow for the collection of early ApplicationEvents,</span><br>       <span class="hljs-comment">// to be published once the multicaster is available...</span><br>       <span class="hljs-comment">// 创建监听前的监听事件集合</span><br>       <span class="hljs-built_in">this</span>.earlyApplicationEvents = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;();<br>   &#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>obtainFreshBeanFactory()方法：获取bean工厂</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Tell the subclass to refresh the internal bean factory.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the fresh BeanFactory instance</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #refreshBeanFactory()</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #getBeanFactory()</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> ConfigurableListableBeanFactory <span class="hljs-title function_">obtainFreshBeanFactory</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-comment">// 初始化BeanFactory，并进行XML文件读取，并将得到的BeanFactory记录在当前实体的属性中</span><br>	refreshBeanFactory();<br>       <span class="hljs-comment">// 返回当前实体的beanFactory属性</span><br>	<span class="hljs-keyword">return</span> getBeanFactory();<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>org.springframework.context.support.AbstractRefreshableApplicationContext#**refreshBeanFactory()**方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * This implementation performs an actual refresh of this context&#x27;s underlying</span><br><span class="hljs-comment">	 * bean factory, shutting down the previous bean factory (if any) and</span><br><span class="hljs-comment">	 * initializing a fresh bean factory for the next phase of the context&#x27;s lifecycle.</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refreshBeanFactory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        <span class="hljs-comment">// 如果存在beanFactory，则销毁</span><br>		<span class="hljs-keyword">if</span> (hasBeanFactory()) &#123;<br>			destroyBeans();<br>			closeBeanFactory();<br>		&#125;<br>		<span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 创建 DefaultListableBeanFactory 对象，不是通过反射，而是new的方式</span><br>            <span class="hljs-comment">// new DefaultListableBeanFactory(getInternalParentBeanFactory());</span><br>            <span class="hljs-comment">// getInternalParentBeanFactory()一般是没有值的，所以创建出来是个空的对象，后面再进行赋值</span><br>			<span class="hljs-type">DefaultListableBeanFactory</span> <span class="hljs-variable">beanFactory</span> <span class="hljs-operator">=</span> createBeanFactory();<br>            <span class="hljs-comment">// 序列化和反序列化</span><br>			beanFactory.setSerializationId(getId());<br>			beanFactory.setApplicationStartup(getApplicationStartup());<br>            <span class="hljs-comment">// 定制beanFactory,设置相关属性，包括是否允许覆盖同名称的不同定义的对象以及循环依赖</span><br>			customizeBeanFactory(beanFactory);<br>            <span class="hljs-comment">// 初始化 documentReader，并进行XML文件读取及解析，默认命名空间和自定义标签的解析，告诉容器需要创建出哪些具体对象</span><br>			loadBeanDefinitions(beanFactory);<br>			<span class="hljs-built_in">this</span>.beanFactory = beanFactory;<br>		&#125;<br>		<span class="hljs-keyword">catch</span> (IOException ex) &#123;<br>			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApplicationContextException</span>(<span class="hljs-string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);<br>		&#125;<br>	&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>prepareBeanFactory(beanFactory)方法</strong>：对各种属性进行填充</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Configure the factory&#x27;s standard context characteristics,</span><br><span class="hljs-comment"> * such as the context&#x27;s ClassLoader and post-processors.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> beanFactory the BeanFactory to configure</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepareBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;<br>	<span class="hljs-comment">// Tell the internal bean factory to use the context&#x27;s class loader etc.</span><br>       <span class="hljs-comment">// 设置beanFactory的classloader为当前context的classloader</span><br>	beanFactory.setBeanClassLoader(getClassLoader());<br>       <span class="hljs-comment">// 设置beanfactory的表达式语言处理器</span><br>	beanFactory.setBeanExpressionResolver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StandardBeanExpressionResolver</span>(beanFactory.getBeanClassLoader()));<br>       <span class="hljs-comment">// 为beanFactory增加一个默认的propertyEditor，这个主要是对bean的属性等设置管理的一个工具类</span><br>	beanFactory.addPropertyEditorRegistrar(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourceEditorRegistrar</span>(<span class="hljs-built_in">this</span>, getEnvironment()));<br><br>	<span class="hljs-comment">// Configure the bean factory with context callbacks.</span><br>       <span class="hljs-comment">// 添加beanPostProcessor, ApplicationContextAwareProcessor类用来完成某些Aware对象的注入</span><br>	beanFactory.addBeanPostProcessor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ApplicationContextAwareProcessor</span>(<span class="hljs-built_in">this</span>));<br>       <span class="hljs-comment">// 设置要忽略自动装配的接口，这些接口是由容器通过set方法进行注入的，所以在使用autowire进行注入的时候需要将这些接口进行忽略</span><br>	beanFactory.ignoreDependencyInterface(EnvironmentAware.class);<br>	beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);<br>	beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);<br>	beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);<br>	beanFactory.ignoreDependencyInterface(MessageSourceAware.class);<br>	beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);<br>	beanFactory.ignoreDependencyInterface(ApplicationStartupAware.class);<br><br>	<span class="hljs-comment">// BeanFactory interface not registered as resolvable type in a plain factory.</span><br>	<span class="hljs-comment">// MessageSource registered (and found for autowiring) as a bean.</span><br>       <span class="hljs-comment">// 设置几个自动装配的特殊规则,当在进行 IoC 初始化的如果有多个实现，那么就使用指定的对象进行注入</span><br>	beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);<br>	beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="hljs-built_in">this</span>);<br>	beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="hljs-built_in">this</span>);<br>	beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="hljs-built_in">this</span>);<br><br>	<span class="hljs-comment">// Register early post-processor for detecting inner beans as ApplicationListeners.</span><br>       <span class="hljs-comment">// 注册 BPP</span><br>	beanFactory.addBeanPostProcessor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ApplicationListenerDetector</span>(<span class="hljs-built_in">this</span>));<br><br>	<span class="hljs-comment">// Detect a LoadTimeWeaver and prepare for weaving, if found.</span><br>       <span class="hljs-comment">// 增加对AspectJ的支持</span><br>       <br>       <span class="hljs-comment">// 在java中织入分为三种方式，分为编译器织入，类加载器织入，运行期织入，</span><br>       <span class="hljs-comment">// 编译期织入是在源代码编译时将切面代码织入到目标类中的。这种方式需要在编译过程中使用特定的编译器或工具，通常与AspectJ结合使用。</span><br>       <span class="hljs-comment">// 类加载期织入发生在类加载到JVM时，通过定制类加载器或使用JVM的类转换器，在类被加载的过程中织入切面代码。这种方式也常与AspectJ结合使用。</span><br>       <span class="hljs-comment">// 运行期织入是指在应用运行时，通过代理模式（如JDK动态代理或CGLIB代理）在目标类方法调用的前后织入切面逻辑。</span><br>       <span class="hljs-comment">// aspectj提供了两种织入方式，即编译器和类加载器。</span><br>	<span class="hljs-keyword">if</span> (!NativeDetector.inNativeImage() &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;<br>		beanFactory.addBeanPostProcessor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoadTimeWeaverAwareProcessor</span>(beanFactory));<br>		<span class="hljs-comment">// Set a temporary ClassLoader for type matching.</span><br>		beanFactory.setTempClassLoader(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ContextTypeMatchClassLoader</span>(beanFactory.getBeanClassLoader()));<br>	&#125;<br><br>	<span class="hljs-comment">// Register default environment beans.</span><br>       <span class="hljs-comment">// 注册默认的系统环境bean到一级缓存中</span><br>	<span class="hljs-keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;<br>		beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());<br>	&#125;<br>	<span class="hljs-keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;<br>		beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());<br>	&#125;<br>	<span class="hljs-keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;<br>		beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());<br>	&#125;<br>	<span class="hljs-keyword">if</span> (!beanFactory.containsLocalBean(APPLICATION_STARTUP_BEAN_NAME)) &#123;<br>		beanFactory.registerSingleton(APPLICATION_STARTUP_BEAN_NAME, getApplicationStartup());<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="描述下bean的生命周期"><a href="#描述下bean的生命周期" class="headerlink" title="描述下bean的生命周期"></a>描述下bean的生命周期</h2><p><img src="https://www.helloimg.com/i/2024/09/19/66ec08b667ce3.png" alt="Snipaste_2024-09-19_19-25-09.png"></p>
<p>1、实例化bean：反射的方式生成对象。<br>2、填充bean的属性：populateBean()，循环依赖的问题(三级缓存)<br>3、调用aware接口相关的方法：invokeAwareMethod（完成BeanName，BeanFactory，BeanClassLoader对象的属性设置）<br>4、调用BeanPostProcessor中的前置处理方法：使用比较多的有（ApplicationContextPostProcessor，设置ApplicationContext，Environment，ResourceLoader，EmbeddValueResolver等对象）<br>5、调用initmethod方法：invokelnitmethod()判断是否实现了initializingBean接口，如果有，调用afterPropertiesset方法，没有就不调用<br>6、调用BeanPostProcessor的后置处理方法：Spring的AOP就是在此处实现的，AbstractAutoProxyCreator注册Destuction相关的回调接口：钩子函数<br>7、获取到完整的对象，可以通过getBean的方式来进行对象的获取<br>8、销毁流程，1、判断是否实现了DispoableBean接口；2，调用destroyMethod方法</p>
<h3 id="源码分析（可选）"><a href="#源码分析（可选）" class="headerlink" title="源码分析（可选）"></a>源码分析（可选）</h3><ul>
<li>org.springframework.beans.factory.BeanFactory</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* &lt;p&gt;Bean factory implementations should support the standard bean lifecycle interfaces</span><br><span class="hljs-comment">* as far as possible. The full set of initialization methods and their standard order is:</span><br><span class="hljs-comment">* &lt;ol&gt;</span><br><span class="hljs-comment">* &lt;li&gt;BeanNameAware&#x27;s &#123;<span class="hljs-doctag">@code</span> setBeanName&#125;</span><br><span class="hljs-comment">* &lt;li&gt;BeanClassLoaderAware&#x27;s &#123;<span class="hljs-doctag">@code</span> setBeanClassLoader&#125;</span><br><span class="hljs-comment">* &lt;li&gt;BeanFactoryAware&#x27;s &#123;<span class="hljs-doctag">@code</span> setBeanFactory&#125;</span><br><span class="hljs-comment">* &lt;li&gt;EnvironmentAware&#x27;s &#123;<span class="hljs-doctag">@code</span> setEnvironment&#125;</span><br><span class="hljs-comment">* &lt;li&gt;EmbeddedValueResolverAware&#x27;s &#123;<span class="hljs-doctag">@code</span> setEmbeddedValueResolver&#125;</span><br><span class="hljs-comment">* &lt;li&gt;ResourceLoaderAware&#x27;s &#123;<span class="hljs-doctag">@code</span> setResourceLoader&#125;</span><br><span class="hljs-comment">* (only applicable when running in an application context)</span><br><span class="hljs-comment">* &lt;li&gt;ApplicationEventPublisherAware&#x27;s &#123;<span class="hljs-doctag">@code</span> setApplicationEventPublisher&#125;</span><br><span class="hljs-comment">* (only applicable when running in an application context)</span><br><span class="hljs-comment">* &lt;li&gt;MessageSourceAware&#x27;s &#123;<span class="hljs-doctag">@code</span> setMessageSource&#125;</span><br><span class="hljs-comment">* (only applicable when running in an application context)</span><br><span class="hljs-comment">* &lt;li&gt;ApplicationContextAware&#x27;s &#123;<span class="hljs-doctag">@code</span> setApplicationContext&#125;</span><br><span class="hljs-comment">* (only applicable when running in an application context)</span><br><span class="hljs-comment">* &lt;li&gt;ServletContextAware&#x27;s &#123;<span class="hljs-doctag">@code</span> setServletContext&#125;</span><br><span class="hljs-comment">* (only applicable when running in a web application context)</span><br><span class="hljs-comment">* &lt;li&gt;&#123;<span class="hljs-doctag">@code</span> postProcessBeforeInitialization&#125; methods of BeanPostProcessors</span><br><span class="hljs-comment">* &lt;li&gt;InitializingBean&#x27;s &#123;<span class="hljs-doctag">@code</span> afterPropertiesSet&#125;</span><br><span class="hljs-comment">* &lt;li&gt;a custom &#123;<span class="hljs-doctag">@code</span> init-method&#125; definition</span><br><span class="hljs-comment">* &lt;li&gt;&#123;<span class="hljs-doctag">@code</span> postProcessAfterInitialization&#125; methods of BeanPostProcessors</span><br><span class="hljs-comment">* &lt;/ol&gt;</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* &lt;p&gt;On shutdown of a bean factory, the following lifecycle methods apply:</span><br><span class="hljs-comment">* &lt;ol&gt;</span><br><span class="hljs-comment">* &lt;li&gt;&#123;<span class="hljs-doctag">@code</span> postProcessBeforeDestruction&#125; methods of DestructionAwareBeanPostProcessors</span><br><span class="hljs-comment">* &lt;li&gt;DisposableBean&#x27;s &#123;<span class="hljs-doctag">@code</span> destroy&#125;</span><br><span class="hljs-comment">* &lt;li&gt;a custom &#123;<span class="hljs-doctag">@code</span> destroy-method&#125; definition</span><br><span class="hljs-comment">* &lt;/ol&gt;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<p>这段注释详细说明了Bean工厂在Spring框架中应该支持的标准Bean生命周期接口，并且列出了初始化和销毁过程中的标准方法及其调用顺序。</p>
<p><strong>Bean工厂实现类应尽可能支持标准的Bean生命周期接口。</strong><br>完整的初始化方法及其标准执行顺序如下：</p>
<ol>
<li>调用 <code>BeanNameAware</code> 的 <code>setBeanName</code> 方法（设置Bean的名称）。</li>
<li>调用 <code>BeanClassLoaderAware</code> 的 <code>setBeanClassLoader</code> 方法（设置Bean的类加载器）。</li>
<li>调用 <code>BeanFactoryAware</code> 的 <code>setBeanFactory</code> 方法（设置BeanFactory实例）。</li>
<li>调用 <code>EnvironmentAware</code> 的 <code>setEnvironment</code> 方法（设置Spring环境配置）。</li>
<li>调用 <code>EmbeddedValueResolverAware</code> 的 <code>setEmbeddedValueResolver</code> 方法（设置嵌入值解析器）。</li>
<li>调用 <code>ResourceLoaderAware</code> 的 <code>setResourceLoader</code> 方法（仅适用于运行在应用上下文中的情况，设置资源加载器）。</li>
<li>调用 <code>ApplicationEventPublisherAware</code> 的 <code>setApplicationEventPublisher</code> 方法（仅适用于运行在应用上下文中的情况，设置事件发布者）。</li>
<li>调用 <code>MessageSourceAware</code> 的 <code>setMessageSource</code> 方法（仅适用于运行在应用上下文中的情况，设置消息源）。</li>
<li>调用 <code>ApplicationContextAware</code> 的 <code>setApplicationContext</code> 方法（仅适用于运行在应用上下文中的情况，设置应用上下文）。</li>
<li>调用 <code>ServletContextAware</code> 的 <code>setServletContext</code> 方法（仅适用于运行在Web应用上下文中的情况，设置Servlet上下文）。</li>
<li>调用 <code>BeanPostProcessor</code> 的 <code>postProcessBeforeInitialization</code> 方法（初始化前的处理）。</li>
<li>调用 <code>InitializingBean</code> 的 <code>afterPropertiesSet</code> 方法（属性设置完毕后的处理）。</li>
<li>调用自定义的 <code>init-method</code> 方法（如果定义了）。</li>
<li>调用 <code>BeanPostProcessor</code> 的 <code>postProcessAfterInitialization</code> 方法（初始化后的处理）。</li>
</ol>
<p><strong>在Bean工厂关闭时，应用以下生命周期方法：</strong></p>
<ol>
<li>调用 <code>DestructionAwareBeanPostProcessor</code> 的 <code>postProcessBeforeDestruction</code> 方法（销毁前的处理）。</li>
<li>调用 <code>DisposableBean</code> 的 <code>destroy</code> 方法（销毁Bean）。</li>
<li>调用自定义的 <code>destroy-method</code> 方法（如果定义了）。</li>
</ol>
<hr>
<ul>
<li><p>org.springframework.context.support.AbstractApplicationContext#refresh()方法中的**finishBeanFactoryInitialization(beanFactory)**，这个方法最后一行beanFactory.preInstantiateSingletons()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preInstantiateSingletons</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>    <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>        logger.trace(<span class="hljs-string">&quot;Pre-instantiating singletons in &quot;</span> + <span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span><br>    <span class="hljs-comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span><br>    <span class="hljs-comment">// 将所有 beanDefinition 的名字创建一个集合</span><br>    List&lt;String&gt; beanNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-built_in">this</span>.beanDefinitionNames);<br><br>    <span class="hljs-comment">// Trigger initialization of all non-lazy singleton beans...</span><br>    <span class="hljs-comment">// 触发所有非延迟加载单例bean的初始化，遍历集合的对象</span><br>    List&lt;CompletableFuture&lt;?&gt;&gt; futures = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-built_in">this</span>.preInstantiationPhase = <span class="hljs-literal">true</span>;<br>    <span class="hljs-built_in">this</span>.preInstantiationThread.set(PreInstantiation.MAIN);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (String beanName : beanNames) &#123;<br>            <span class="hljs-comment">// 合并父类 BeanDefinition</span><br>            <span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">mbd</span> <span class="hljs-operator">=</span> getMergedLocalBeanDefinition(beanName);<br>            <span class="hljs-comment">// 条件判断，抽象、单例</span><br>            <span class="hljs-keyword">if</span> (!mbd.isAbstract() &amp;&amp; mbd.isSingleton()) &#123;<br>                <span class="hljs-comment">// 实例化单例bean，分成异步和同步</span><br>                CompletableFuture&lt;?&gt; future = preInstantiateSingleton(beanName, mbd);<br>                <span class="hljs-keyword">if</span> (future != <span class="hljs-literal">null</span>) &#123;<br>                    futures.add(future);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-built_in">this</span>.preInstantiationThread.remove();<br>        <span class="hljs-built_in">this</span>.preInstantiationPhase = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!futures.isEmpty()) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            CompletableFuture.allOf(futures.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>&lt;?&gt;[<span class="hljs-number">0</span>])).join();<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (CompletionException ex) &#123;<br>            ReflectionUtils.rethrowRuntimeException(ex.getCause());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Trigger post-initialization callback for all applicable beans...</span><br>    <span class="hljs-keyword">for</span> (String beanName : beanNames) &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">singletonInstance</span> <span class="hljs-operator">=</span> getSingleton(beanName, <span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">if</span> (singletonInstance <span class="hljs-keyword">instanceof</span> SmartInitializingSingleton smartSingleton) &#123;<br>            <span class="hljs-type">StartupStep</span> <span class="hljs-variable">smartInitialize</span> <span class="hljs-operator">=</span> getApplicationStartup().start(<span class="hljs-string">&quot;spring.beans.smart-initialize&quot;</span>)<br>                .tag(<span class="hljs-string">&quot;beanName&quot;</span>, beanName);<br>            smartSingleton.afterSingletonsInstantiated();<br>            smartInitialize.end();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>实例化单例bean主要实现</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">instantiateSingleton</span><span class="hljs-params">(String beanName)</span> &#123;<br>       <span class="hljs-comment">// 判断是否实现了FactoryBean接口</span><br>	<span class="hljs-keyword">if</span> (isFactoryBean(beanName)) &#123;<br>           <span class="hljs-comment">// 根据 &amp; + beanName来获取具体对象</span><br>		<span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> getBean(FACTORY_BEAN_PREFIX + beanName);<br>           <span class="hljs-comment">// 类型转换 并 判断这个FactoryBean 是否立即初始化</span><br>		<span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> SmartFactoryBean&lt;?&gt; smartFactoryBean &amp;&amp; smartFactoryBean.isEagerInit()) &#123;<br>               <span class="hljs-comment">// 如果立即初始化，则通过beanName获取bean实例</span><br>			getBean(beanName);<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-comment">// 不是FactoryBaan，只是普通Bean，通过beanName获取实例</span><br>		getBean(beanName);<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">// getBean()方法</span><br><span class="hljs-comment">// 触发依赖注入的方法</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>	<span class="hljs-keyword">return</span> doGetBean(name, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>doGetBean方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Return an instance, which may be shared or independent, of the specified bean.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> name the name of the bean to retrieve</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> requiredType the required type of the bean to retrieve</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> args arguments to use when creating a bean instance using explicit arguments</span><br><span class="hljs-comment"> * (only applied when creating a new instance as opposed to retrieving an existing one)</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> typeCheckOnly whether the instance is obtained for a type check,</span><br><span class="hljs-comment"> * not for actual use</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> an instance of the bean</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> BeansException if the bean could not be created</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">protected</span> &lt;T&gt; T <span class="hljs-title function_">doGetBean</span><span class="hljs-params">(</span><br><span class="hljs-params">		String name, <span class="hljs-meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="hljs-meta">@Nullable</span> Object[] args, <span class="hljs-type">boolean</span> typeCheckOnly)</span><br>		<span class="hljs-keyword">throws</span> BeansException &#123;<br><br>       <span class="hljs-comment">// 提取对应的 beanName，原因是前面bean对象实现FactoryBean接口之后会变成&amp;beanName</span><br>	<span class="hljs-type">String</span> <span class="hljs-variable">beanName</span> <span class="hljs-operator">=</span> transformedBeanName(name);<br>	Object beanInstance;<br><br>	<span class="hljs-comment">// Eagerly check singleton cache for manually registered singletons.</span><br>       <span class="hljs-comment">// 提前检查单例缓存中是否有手动注册的单例对象，跟循环依赖有关联</span><br>	<span class="hljs-type">Object</span> <span class="hljs-variable">sharedInstance</span> <span class="hljs-operator">=</span> getSingleton(beanName);<br>       <span class="hljs-comment">// 如果bean的单例对象找到了，且没有创建bean实例时要使用的参数</span><br>	<span class="hljs-keyword">if</span> (sharedInstance != <span class="hljs-literal">null</span> &amp;&amp; args == <span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>			<span class="hljs-keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;<br>				logger.trace(<span class="hljs-string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName +<br>						<span class="hljs-string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);<br>			&#125;<br>			<span class="hljs-keyword">else</span> &#123;<br>				logger.trace(<span class="hljs-string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>			&#125;<br>		&#125;<br>		beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="hljs-literal">null</span>);<br>	&#125;<br><br>	<span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-comment">// Fail if we&#x27;re already creating this bean instance:</span><br>		<span class="hljs-comment">// We&#x27;re assumably within a circular reference.</span><br>           <span class="hljs-comment">// 当对象都是单例的时候会尝试解决循环依赖的问题</span><br>           <span class="hljs-comment">// 原型模式下如果存在循环依赖，直接抛异常</span><br>		<span class="hljs-keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;<br>			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCurrentlyInCreationException</span>(beanName);<br>		&#125;<br><br>		<span class="hljs-comment">// Check if bean definition exists in this factory.</span><br>           <span class="hljs-comment">// 如果bean定义不存在，就检查父工厂是否存在</span><br>		<span class="hljs-type">BeanFactory</span> <span class="hljs-variable">parentBeanFactory</span> <span class="hljs-operator">=</span> getParentBeanFactory();<br>           <span class="hljs-comment">// 所有已加载的类中不包含beanName，尝试从父容器中获取</span><br>		<span class="hljs-keyword">if</span> (parentBeanFactory != <span class="hljs-literal">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;<br>			<span class="hljs-comment">// Not found -&gt; check parent.</span><br>               <span class="hljs-comment">// 获取name对应的规范名[全类名]，如果name前有&amp;，则会返回&amp;规范名</span><br>			<span class="hljs-type">String</span> <span class="hljs-variable">nameToLookup</span> <span class="hljs-operator">=</span> originalBeanName(name);<br>               <span class="hljs-comment">// 如果父工厂是AbstractBeanFactory的实例</span><br>			<span class="hljs-keyword">if</span> (parentBeanFactory <span class="hljs-keyword">instanceof</span> AbstractBeanFactory abf) &#123;<br>                   <span class="hljs-comment">// 调用父工厂的 doGetBean方法，也就是当前方法，递归</span><br>				<span class="hljs-keyword">return</span> abf.doGetBean(nameToLookup, requiredType, args, typeCheckOnly);<br>			&#125;<br>			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (args != <span class="hljs-literal">null</span>) &#123;<br>				<span class="hljs-comment">// Delegation to parent with explicit args.</span><br>                   <span class="hljs-comment">// 使用父工厂获取该bean对象，通过bean全类名和创建bean实例时要使用的参数</span><br>				<span class="hljs-keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);<br>			&#125;<br>			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (requiredType != <span class="hljs-literal">null</span>) &#123;<br>				<span class="hljs-comment">// No args -&gt; delegate to standard getBean method.</span><br>                   <span class="hljs-comment">// 使用父工厂获取该bean对象，通过所需的bean类型</span><br>				<span class="hljs-keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);<br>			&#125;<br>			<span class="hljs-keyword">else</span> &#123;<br>                   <span class="hljs-comment">// 使用父工厂获取该bean对象，通过bean全类名</span><br>				<span class="hljs-keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup);<br>			&#125;<br>		&#125;<br><br>           <span class="hljs-comment">// 在集合中做一个记录，表示要创建bean</span><br>		<span class="hljs-keyword">if</span> (!typeCheckOnly) &#123;<br>               <span class="hljs-comment">// 标记为已经创建</span><br>			markBeanAsCreated(beanName);<br>		&#125;<br><br>		<span class="hljs-type">StartupStep</span> <span class="hljs-variable">beanCreation</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.applicationStartup.start(<span class="hljs-string">&quot;spring.beans.instantiate&quot;</span>)<br>				.tag(<span class="hljs-string">&quot;beanName&quot;</span>, name);<br>		<span class="hljs-keyword">try</span> &#123;<br>			<span class="hljs-keyword">if</span> (requiredType != <span class="hljs-literal">null</span>) &#123;<br>				beanCreation.tag(<span class="hljs-string">&quot;beanType&quot;</span>, requiredType::toString);<br>			&#125;<br>               <span class="hljs-comment">// 此处做了BeanDefinition对象的转换，当我们从xml文件中加载beandefinition对象的时候，封装对象是GenericBeanDefinition</span><br>               <span class="hljs-comment">// 此处要做类型转换，如果是子类bean的话，会合并父类的相关属性</span><br>			<span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">mbd</span> <span class="hljs-operator">=</span> getMergedLocalBeanDefinition(beanName);<br>               <span class="hljs-comment">// 检查mbd的合法性，不合格会引发验证异常</span><br>			checkMergedBeanDefinition(mbd, beanName, args);<br><br>			<span class="hljs-comment">// Guarantee initialization of beans that the current bean depends on.</span><br>               <span class="hljs-comment">// 如果存在依赖的bean的话，那么则优先实例依赖的bean</span><br>			String[] dependsOn = mbd.getDependsOn();<br>			<span class="hljs-keyword">if</span> (dependsOn != <span class="hljs-literal">null</span>) &#123;<br>                   <span class="hljs-comment">// 如果存在依赖，则需要递归实例化依赖的bean</span><br>				<span class="hljs-keyword">for</span> (String dep : dependsOn) &#123;<br>                       <span class="hljs-comment">// 如果beanName已注册依赖于dependentBeanName的关系</span><br>					<span class="hljs-keyword">if</span> (isDependent(beanName, dep)) &#123;<br>						<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,<br>								<span class="hljs-string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>					&#125;<br>                       <span class="hljs-comment">// 注册各个bean的依赖关系，方便进行销毁</span><br>					registerDependentBean(dep, beanName);<br>					<span class="hljs-keyword">try</span> &#123;<br>                           <span class="hljs-comment">// 递归优先实例化被依赖的Bean</span><br>						getBean(dep);<br>					&#125;<br>					<span class="hljs-keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;<br>						<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,<br>								<span class="hljs-string">&quot;&#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="hljs-string">&quot;&#x27;&quot;</span>, ex);<br>					&#125;<br>					<span class="hljs-keyword">catch</span> (BeanCreationException ex) &#123;<br>						<span class="hljs-keyword">if</span> (requiredType != <span class="hljs-literal">null</span>) &#123;<br>							<span class="hljs-comment">// Wrap exception with current bean metadata but only if specifically</span><br>							<span class="hljs-comment">// requested (indicated by required type), not for depends-on cascades.</span><br>							<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,<br>									<span class="hljs-string">&quot;Failed to initialize dependency &#x27;&quot;</span> + ex.getBeanName() + <span class="hljs-string">&quot;&#x27; of &quot;</span> +<br>											requiredType.getSimpleName() + <span class="hljs-string">&quot; bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;: &quot;</span> +<br>											ex.getMessage(), ex);<br>						&#125;<br>						<span class="hljs-keyword">throw</span> ex;<br>					&#125;<br>				&#125;<br>			&#125;<br><br>			<span class="hljs-comment">// Create bean instance.</span><br>               <span class="hljs-comment">// 创建bean的实例对象</span><br>			<span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;<br>                   <span class="hljs-comment">// 返回以beanName的(原始)单例对象，如果尚未注册，则使用singletonFactory创建并注册一个对象</span><br>				sharedInstance = getSingleton(beanName, () -&gt; &#123;<br>					<span class="hljs-keyword">try</span> &#123;<br>                           <span class="hljs-comment">// 为给定的合并后BeanDefini1ion(和参数)创建一个bean实例</span><br>						<span class="hljs-keyword">return</span> createBean(beanName, mbd, args);<br>					&#125;<br>					<span class="hljs-keyword">catch</span> (BeansException ex) &#123;<br>						<span class="hljs-comment">// Explicitly remove instance from singleton cache: It might have been put there</span><br>						<span class="hljs-comment">// eagerly by the creation process, to allow for circular reference resolution.</span><br>						<span class="hljs-comment">// Also remove any beans that received a temporary reference to the bean.</span><br>                           <span class="hljs-comment">// 显示的从单例缓存中删除实例，它可能是由创建过程急切地放在那里，以允许循环引用解析。</span><br>                           <span class="hljs-comment">// 还要删除接收到该Bean临时引用的任何Bean</span><br>                           <span class="hljs-comment">// 销毁给定的bean。如果找到相应的一次性Bean实例，则委托给destoryBean</span><br>						destroySingleton(beanName);<br>						<span class="hljs-keyword">throw</span> ex;<br>					&#125;<br>				&#125;);<br>				beanInstance = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);<br>			&#125;<br><br>			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mbd.isPrototype()) &#123;<br>				<span class="hljs-comment">// It&#x27;s a prototype -&gt; create a new instance.</span><br>				<span class="hljs-type">Object</span> <span class="hljs-variable">prototypeInstance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>				<span class="hljs-keyword">try</span> &#123;<br>					beforePrototypeCreation(beanName);<br>					prototypeInstance = createBean(beanName, mbd, args);<br>				&#125;<br>				<span class="hljs-keyword">finally</span> &#123;<br>					afterPrototypeCreation(beanName);<br>				&#125;<br>				beanInstance = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);<br>			&#125;<br><br>			<span class="hljs-keyword">else</span> &#123;<br>				<span class="hljs-type">String</span> <span class="hljs-variable">scopeName</span> <span class="hljs-operator">=</span> mbd.getScope();<br>				<span class="hljs-keyword">if</span> (!StringUtils.hasLength(scopeName)) &#123;<br>					<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;No scope name defined for bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>				&#125;<br>				<span class="hljs-type">Scope</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.scopes.get(scopeName);<br>				<span class="hljs-keyword">if</span> (scope == <span class="hljs-literal">null</span>) &#123;<br>					<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>				&#125;<br>				<span class="hljs-keyword">try</span> &#123;<br>					<span class="hljs-type">Object</span> <span class="hljs-variable">scopedInstance</span> <span class="hljs-operator">=</span> scope.get(beanName, () -&gt; &#123;<br>						beforePrototypeCreation(beanName);<br>						<span class="hljs-keyword">try</span> &#123;<br>							<span class="hljs-keyword">return</span> createBean(beanName, mbd, args);<br>						&#125;<br>						<span class="hljs-keyword">finally</span> &#123;<br>							afterPrototypeCreation(beanName);<br>						&#125;<br>					&#125;);<br>					beanInstance = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);<br>				&#125;<br>				<span class="hljs-keyword">catch</span> (IllegalStateException ex) &#123;<br>					<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScopeNotActiveException</span>(beanName, scopeName, ex);<br>				&#125;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">catch</span> (BeansException ex) &#123;<br>			beanCreation.tag(<span class="hljs-string">&quot;exception&quot;</span>, ex.getClass().toString());<br>			beanCreation.tag(<span class="hljs-string">&quot;message&quot;</span>, String.valueOf(ex.getMessage()));<br>			cleanupAfterBeanCreationFailure(beanName);<br>			<span class="hljs-keyword">throw</span> ex;<br>		&#125;<br>		<span class="hljs-keyword">finally</span> &#123;<br>			beanCreation.end();<br>			<span class="hljs-keyword">if</span> (!isCacheBeanMetadata()) &#123;<br>				clearMergedBeanDefinition(beanName);<br>			&#125;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> adaptBeanInstance(name, beanInstance, requiredType);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>createBean()：创建对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Central method of this class: creates a bean instance,</span><br><span class="hljs-comment"> * populates the bean instance, applies post-processors, etc.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #doCreateBean</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">createBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, <span class="hljs-meta">@Nullable</span> Object[] args)</span><br>		<span class="hljs-keyword">throws</span> BeanCreationException &#123;<br><br>	<span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>		logger.trace(<span class="hljs-string">&quot;Creating instance of bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>	&#125;<br>	<span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">mbdToUse</span> <span class="hljs-operator">=</span> mbd;<br><br>	<span class="hljs-comment">// Make sure bean class is actually resolved at this point, and</span><br>	<span class="hljs-comment">// clone the bean definition in case of a dynamically resolved Class</span><br>	<span class="hljs-comment">// which cannot be stored in the shared merged bean definition.</span><br>       <span class="hljs-comment">// 锁定class，根据设置的class属性或者根据className来解析class</span><br>	Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);<br>       <span class="hljs-comment">// 条件筛选，重新赋值RootBeanDefinition，并设置BeanClass属性</span><br>	<span class="hljs-keyword">if</span> (resolvedClass != <span class="hljs-literal">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="hljs-literal">null</span>) &#123;<br>		mbdToUse = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RootBeanDefinition</span>(mbd);<br>		mbdToUse.setBeanClass(resolvedClass);<br>		<span class="hljs-keyword">try</span> &#123;<br>               <span class="hljs-comment">// 验证及准备覆盖的方法</span><br>			mbdToUse.prepareMethodOverrides();<br>		&#125;<br>		<span class="hljs-keyword">catch</span> (BeanDefinitionValidationException ex) &#123;<br>			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionStoreException</span>(mbdToUse.getResourceDescription(),<br>					beanName, <span class="hljs-string">&quot;Validation of method overrides failed&quot;</span>, ex);<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-keyword">try</span> &#123;<br>		<span class="hljs-comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span><br>           <span class="hljs-comment">// 给BeanPostProcessors一个机会来返回代理来替代真正的实例</span><br>		<span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> resolveBeforeInstantiation(beanName, mbdToUse);<br>		<span class="hljs-keyword">if</span> (bean != <span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-keyword">return</span> bean;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>		<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(mbdToUse.getResourceDescription(), beanName,<br>				<span class="hljs-string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, ex);<br>	&#125;<br><br>	<span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-comment">// 实际创建bean的调用</span><br>		<span class="hljs-type">Object</span> <span class="hljs-variable">beanInstance</span> <span class="hljs-operator">=</span> doCreateBean(beanName, mbdToUse, args);<br>		<span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>			logger.trace(<span class="hljs-string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>		&#125;<br>		<span class="hljs-keyword">return</span> beanInstance;<br>	&#125;<br>	<span class="hljs-keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;<br>		<span class="hljs-comment">// A previously detected exception with proper bean creation context already,</span><br>		<span class="hljs-comment">// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.</span><br>		<span class="hljs-keyword">throw</span> ex;<br>	&#125;<br>	<span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>		<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(<br>				mbdToUse.getResourceDescription(), beanName, <span class="hljs-string">&quot;Unexpected exception during bean creation&quot;</span>, ex);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>doCreateBean()方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Actually create the specified bean. Pre-creation processing has already happened</span><br><span class="hljs-comment"> * at this point, e.g. checking &#123;<span class="hljs-doctag">@code</span> postProcessBeforeInstantiation&#125; callbacks.</span><br><span class="hljs-comment"> * &lt;p&gt;Differentiates between default bean instantiation, use of a</span><br><span class="hljs-comment"> * factory method, and autowiring a constructor.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> beanName the name of the bean</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> mbd the merged bean definition for the bean</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> args explicit arguments to use for constructor or factory method invocation</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> a new instance of the bean</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> BeanCreationException if the bean could not be created</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #instantiateBean</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #instantiateUsingFactoryMethod</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #autowireConstructor</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">doCreateBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, <span class="hljs-meta">@Nullable</span> Object[] args)</span><br>		<span class="hljs-keyword">throws</span> BeanCreationException &#123;<br><br>	<span class="hljs-comment">// Instantiate the bean.</span><br>       <span class="hljs-comment">// 用来持有创建出来的bean对象</span><br>	<span class="hljs-type">BeanWrapper</span> <span class="hljs-variable">instanceWrapper</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>       <span class="hljs-comment">// 获取factoryBean实例缓存</span><br>	<span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;<br>           <span class="hljs-comment">// 如果是单例对象，从factoryBean实例缓存中移除当前bean定义信息</span><br>		instanceWrapper = <span class="hljs-built_in">this</span>.factoryBeanInstanceCache.remove(beanName);<br>	&#125;<br>       <span class="hljs-comment">// 创建对象实例</span><br>	<span class="hljs-keyword">if</span> (instanceWrapper == <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-comment">// 根据执行bean使用对应的策略创建新实例，如工厂方法，构造函数自动注入，简单初始化</span><br>           <span class="hljs-comment">// 通过反射方式，1、获取Class；2、获取构造器；3、newInstance</span><br>		instanceWrapper = createBeanInstance(beanName, mbd, args);<br>	&#125;<br>       <span class="hljs-comment">// 从包装类中获取原始bean</span><br>	<span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> instanceWrapper.getWrappedInstance();<br>       <span class="hljs-comment">// 获取具体的bean对象的Class属性</span><br>	Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();<br>       <span class="hljs-comment">// 如果不等于NullBean类型，修改目标类型</span><br>	<span class="hljs-keyword">if</span> (beanType != NullBean.class) &#123;<br>		mbd.resolvedTargetType = beanType;<br>	&#125;<br><br>	<span class="hljs-comment">// Allow post-processors to modify the merged bean definition.</span><br>       <span class="hljs-comment">// 允许beanPostProcessor去修改合并的beanDefinition</span><br>	<span class="hljs-keyword">synchronized</span> (mbd.postProcessingLock) &#123;<br>		<span class="hljs-keyword">if</span> (!mbd.postProcessed) &#123;<br>			<span class="hljs-keyword">try</span> &#123;<br>				applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);<br>			&#125;<br>			<span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,<br>						<span class="hljs-string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);<br>			&#125;<br>			mbd.markAsPostProcessed();<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">// Eagerly cache singletons to be able to resolve circular references</span><br>	<span class="hljs-comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span><br>       <span class="hljs-comment">// 判断当前bean是否需要提前曝光：单例&amp;允许循环依赖&amp;当前bean正在创建中，检查循环依赖</span><br>	<span class="hljs-type">boolean</span> <span class="hljs-variable">earlySingletonExposure</span> <span class="hljs-operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="hljs-built_in">this</span>.allowCircularReferences &amp;&amp;<br>			isSingletonCurrentlyInCreation(beanName));<br>	<span class="hljs-keyword">if</span> (earlySingletonExposure) &#123;<br>		<span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>			logger.trace(<span class="hljs-string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +<br>					<span class="hljs-string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);<br>		&#125;<br>           <span class="hljs-comment">// 为避免后期循环依赖。可以在bean初始化完成前将创建实例的ObjectFactory加入工厂</span><br>		addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));<br>	&#125;<br><br>	<span class="hljs-comment">// Initialize the bean instance.</span><br>	<span class="hljs-type">Object</span> <span class="hljs-variable">exposedObject</span> <span class="hljs-operator">=</span> bean;<br>	<span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-comment">// 对bean的属性进行填充，将各个属性值注入，可能存在依赖其他bean的属性，会递归初始化依赖的bean</span><br>		populateBean(beanName, mbd, instanceWrapper);<br>           <span class="hljs-comment">// 执行初始化bean</span><br>		exposedObject = initializeBean(beanName, exposedObject, mbd);<br>	&#125;<br>	<span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>		<span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> BeanCreationException bce &amp;&amp; beanName.equals(bce.getBeanName())) &#123;<br>			<span class="hljs-keyword">throw</span> bce;<br>		&#125;<br>		<span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName, ex.getMessage(), ex);<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> (earlySingletonExposure) &#123;<br>           <span class="hljs-comment">// 从缓存中获取具体的对象</span><br>		<span class="hljs-type">Object</span> <span class="hljs-variable">earlySingletonReference</span> <span class="hljs-operator">=</span> getSingleton(beanName, <span class="hljs-literal">false</span>);<br>           <span class="hljs-comment">// 只有在检查到有循环依赖的时候才不为空</span><br>		<span class="hljs-keyword">if</span> (earlySingletonReference != <span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-keyword">if</span> (exposedObject == bean) &#123;<br>				exposedObject = earlySingletonReference;<br>			&#125;<br>			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;<br>				String[] dependentBeans = getDependentBeans(beanName);<br>				Set&lt;String&gt; actualDependentBeans = CollectionUtils.newLinkedHashSet(dependentBeans.length);<br>				<span class="hljs-keyword">for</span> (String dependentBean : dependentBeans) &#123;<br>					<span class="hljs-keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;<br>						actualDependentBeans.add(dependentBean);<br>					&#125;<br>				&#125;<br>				<span class="hljs-keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;<br>					<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCurrentlyInCreationException</span>(beanName,<br>							<span class="hljs-string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; has been injected into other beans [&quot;</span> +<br>							StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +<br>							<span class="hljs-string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +<br>							<span class="hljs-string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +<br>							<span class="hljs-string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +<br>							<span class="hljs-string">&quot;&#x27;getBeanNamesForType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">// Register bean as disposable.</span><br>	<span class="hljs-keyword">try</span> &#123;<br>		registerDisposableBeanIfNecessary(beanName, bean, mbd);<br>	&#125;<br>	<span class="hljs-keyword">catch</span> (BeanDefinitionValidationException ex) &#123;<br>		<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(<br>				mbd.getResourceDescription(), beanName, <span class="hljs-string">&quot;Invalid destruction signature&quot;</span>, ex);<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> exposedObject;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>createBeanInstance方法</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 确认需要创建的类可以实例化</span><br>Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);<br><span class="hljs-comment">// 获取构造器</span><br>Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);<br><span class="hljs-comment">// No special handling: simply use no-arg constructor.</span><br><span class="hljs-comment">// 使用默认无参构造函数创建对象，如果没有无参构造且存在多个有参构造且没有@Autowired注解构造，会报错</span><br><span class="hljs-keyword">return</span> instantiateBean(beanName, mbd);<br><br><br><span class="hljs-comment">// instantiateBean方法</span><br><span class="hljs-keyword">protected</span> BeanWrapper <span class="hljs-title function_">instantiateBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 获取实例化策略并且进行实例化操作</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">beanInstance</span> <span class="hljs-operator">=</span> getInstantiationStrategy().instantiate(mbd, beanName, <span class="hljs-built_in">this</span>);<br>        <span class="hljs-type">BeanWrapper</span> <span class="hljs-variable">bw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanWrapperImpl</span>(beanInstance);<br>        initBeanWrapper(bw);<br>        <span class="hljs-keyword">return</span> bw;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName, ex.getMessage(), ex);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">instantiate</span><span class="hljs-params">(RootBeanDefinition bd, <span class="hljs-meta">@Nullable</span> String beanName, BeanFactory owner)</span> &#123;<br>    <span class="hljs-comment">// Don&#x27;t override the class with CGLIB if no overrides.</span><br>    <span class="hljs-keyword">if</span> (!bd.hasMethodOverrides()) &#123;<br>        Constructor&lt;?&gt; constructorToUse;<br>        <span class="hljs-keyword">synchronized</span> (bd.constructorArgumentLock) &#123;<br>            constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;<br>            <span class="hljs-keyword">if</span> (constructorToUse == <span class="hljs-literal">null</span>) &#123;<br>                Class&lt;?&gt; clazz = bd.getBeanClass();<br>                <span class="hljs-keyword">if</span> (clazz.isInterface()) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanInstantiationException</span>(clazz, <span class="hljs-string">&quot;Specified class is an interface&quot;</span>);<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 获取默认的无参构造器</span><br>                    constructorToUse = clazz.getDeclaredConstructor();<br>                    bd.resolvedConstructorOrFactoryMethod = constructorToUse;<br>                &#125;<br>                <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanInstantiationException</span>(clazz, <span class="hljs-string">&quot;No default constructor found&quot;</span>, ex);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 通过反射生成具体的实例化对象</span><br>        <span class="hljs-keyword">return</span> BeanUtils.instantiateClass(constructorToUse);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Must generate CGLIB subclass.</span><br>        <span class="hljs-comment">// 必须生成cglib子类</span><br>        <span class="hljs-keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// instantiateClass方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">instantiateClass</span><span class="hljs-params">(Constructor&lt;T&gt; ctor, Object... args)</span> <span class="hljs-keyword">throws</span> BeanInstantiationException &#123;<br>    Assert.notNull(ctor, <span class="hljs-string">&quot;Constructor must not be null&quot;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        ReflectionUtils.makeAccessible(ctor);<br>        <span class="hljs-keyword">if</span> (KotlinDetector.isKotlinReflectPresent() &amp;&amp; KotlinDetector.isKotlinType(ctor.getDeclaringClass())) &#123;<br>            <span class="hljs-keyword">return</span> KotlinDelegate.instantiateClass(ctor, args);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">parameterCount</span> <span class="hljs-operator">=</span> ctor.getParameterCount();<br>            Assert.isTrue(args.length &lt;= parameterCount, <span class="hljs-string">&quot;Can&#x27;t specify more arguments than constructor parameters&quot;</span>);<br>            <span class="hljs-keyword">if</span> (parameterCount == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> ctor.newInstance();<br>            &#125;<br>            Class&lt;?&gt;[] parameterTypes = ctor.getParameterTypes();<br>            Object[] argsWithDefaultValues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[args.length];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; args.length; i++) &#123;<br>                <span class="hljs-keyword">if</span> (args[i] == <span class="hljs-literal">null</span>) &#123;<br>                    Class&lt;?&gt; parameterType = parameterTypes[i];<br>                    argsWithDefaultValues[i] = (parameterType.isPrimitive() ? DEFAULT_TYPE_VALUES.get(parameterType) : <span class="hljs-literal">null</span>);<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    argsWithDefaultValues[i] = args[i];<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// newInstance 实例化对象</span><br>            <span class="hljs-keyword">return</span> ctor.newInstance(argsWithDefaultValues);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (InstantiationException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanInstantiationException</span>(ctor, <span class="hljs-string">&quot;Is it an abstract class?&quot;</span>, ex);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (IllegalAccessException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanInstantiationException</span>(ctor, <span class="hljs-string">&quot;Is the constructor accessible?&quot;</span>, ex);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (IllegalArgumentException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanInstantiationException</span>(ctor, <span class="hljs-string">&quot;Illegal arguments for constructor&quot;</span>, ex);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (InvocationTargetException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanInstantiationException</span>(ctor, <span class="hljs-string">&quot;Constructor threw exception&quot;</span>, ex.getTargetException());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<ul>
<li>initializeBean方法：bean实例化</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">initializeBean</span><span class="hljs-params">(String beanName, Object bean, <span class="hljs-meta">@Nullable</span> RootBeanDefinition mbd)</span> &#123;<br>       <span class="hljs-comment">// Aware接口处理器，调用BeanNameAware、BeanClassLoaderAware、beanFactoryAware</span><br>	invokeAwareMethods(beanName, bean);<br><br>	<span class="hljs-type">Object</span> <span class="hljs-variable">wrappedBean</span> <span class="hljs-operator">=</span> bean;<br>       <span class="hljs-comment">// 如果mdb不为null或mbd不是&quot;synthetic&quot;，一般是指只有A0P相关的prointCut配置或者Advice配置才会将 synthetic设置为true</span><br>	<span class="hljs-keyword">if</span> (mbd == <span class="hljs-literal">null</span> || !mbd.isSynthetic()) &#123;<br>           <span class="hljs-comment">// 将BeanPostProcessors应用到给定的现有Bean实例，调用它们的postProcessBeforeInitialization初始化方法。</span><br>           <span class="hljs-comment">// 返回的Bean实例可能是原始Bean包装器</span><br>		wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);<br>	&#125;<br><br>	<span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-comment">// init-method，调用初始化方法，先调用bean的InitializngBean接口方法，后调用bean的自定义初始化方法</span><br>		invokeInitMethods(beanName, wrappedBean, mbd);<br>	&#125;<br>	<span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>		<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(<br>				(mbd != <span class="hljs-literal">null</span> ? mbd.getResourceDescription() : <span class="hljs-literal">null</span>), beanName, ex.getMessage(), ex);<br>	&#125;<br>	<span class="hljs-keyword">if</span> (mbd == <span class="hljs-literal">null</span> || !mbd.isSynthetic()) &#123;<br>           <span class="hljs-comment">// 将beanPostProcessors应用到现有的bean实例，调用他们的postProcessorsAfterInitialization方法</span><br>		wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> wrappedBean;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeAwareMethods</span><span class="hljs-params">(String beanName, Object bean)</span> &#123;<br>	<span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> Aware) &#123;<br>		<span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> BeanNameAware beanNameAware) &#123;<br>			beanNameAware.setBeanName(beanName);<br>		&#125;<br>		<span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> BeanClassLoaderAware beanClassLoaderAware) &#123;<br>			<span class="hljs-type">ClassLoader</span> <span class="hljs-variable">bcl</span> <span class="hljs-operator">=</span> getBeanClassLoader();<br>			<span class="hljs-keyword">if</span> (bcl != <span class="hljs-literal">null</span>) &#123;<br>				beanClassLoaderAware.setBeanClassLoader(bcl);<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> BeanFactoryAware beanFactoryAware) &#123;<br>			beanFactoryAware.setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="hljs-built_in">this</span>);<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>invokeInitMethods方法：afterPropertiesSet</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeInitMethods</span><span class="hljs-params">(String beanName, Object bean, <span class="hljs-meta">@Nullable</span> RootBeanDefinition mbd)</span><br>		<span class="hljs-keyword">throws</span> Throwable &#123;<br><br>       <span class="hljs-comment">// 如果实现了InitializingBean，就会调用afterPropertiesSet进行属性设置</span><br>	<span class="hljs-type">boolean</span> <span class="hljs-variable">isInitializingBean</span> <span class="hljs-operator">=</span> (bean <span class="hljs-keyword">instanceof</span> InitializingBean);<br>	<span class="hljs-keyword">if</span> (isInitializingBean &amp;&amp; (mbd == <span class="hljs-literal">null</span> || !mbd.hasAnyExternallyManagedInitMethod(<span class="hljs-string">&quot;afterPropertiesSet&quot;</span>))) &#123;<br>		<span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>			logger.trace(<span class="hljs-string">&quot;Invoking afterPropertiesSet() on bean with name &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>		&#125;<br>		((InitializingBean) bean).afterPropertiesSet();<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> (mbd != <span class="hljs-literal">null</span> &amp;&amp; bean.getClass() != NullBean.class) &#123;<br>		String[] initMethodNames = mbd.getInitMethodNames();<br>		<span class="hljs-keyword">if</span> (initMethodNames != <span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-keyword">for</span> (String initMethodName : initMethodNames) &#123;<br>				<span class="hljs-keyword">if</span> (StringUtils.hasLength(initMethodName) &amp;&amp;<br>						!(isInitializingBean &amp;&amp; <span class="hljs-string">&quot;afterPropertiesSet&quot;</span>.equals(initMethodName)) &amp;&amp;<br>						!mbd.hasAnyExternallyManagedInitMethod(initMethodName)) &#123;<br>					invokeCustomInitMethod(beanName, bean, mbd, initMethodName);<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h2 id="解释下自动装配的各种模式"><a href="#解释下自动装配的各种模式" class="headerlink" title="解释下自动装配的各种模式"></a>解释下自动装配的各种模式</h2><p>自动装配提供五种不同的模式供Spring容器用来自动装配beans之间的依赖注入：<br>no：默认的方式是不进行自动装配，通过手工设置ref属性来进行装配bean。</p>
<p>byName：通过参数名自动装配，Spring容器查找beans的属性，这些beans在XML配置文件中被设置为byName。之后容器试图匹配、装配和该bean的属性具有相同名字的bean。</p>
<p>byType：通过参数的数据类型自动自动装配，Spring容器查找beans的属性，这些beans在XML配置文件中被设置为byType。之后容器试图匹配和装配和该bean的属性类型一样的bean。如果有多个bean符合条件，则抛出错误。<br>constructor：这个同byType类似，不过是应用于构造函数的参数。如果在BeanFactory中不是恰好有一个bean与构造函数参数相同类型，则抛出一个严重的错误。<br>autodetect：如果有默认的构造方法，通过 construct的方式自动装配，否则使用 byType的方式自动装配。</p>
<hr>
<h2 id="BeanFactory和Applicationcontext有什么区别"><a href="#BeanFactory和Applicationcontext有什么区别" class="headerlink" title="BeanFactory和Applicationcontext有什么区别?"></a>BeanFactory和Applicationcontext有什么区别?</h2><p>1、加载方式：BeanFactory采用的是延迟加载（<code>lazy-oading</code>）的方式，即只有在使用到某个Bean时才会对该Bean进行加载和实例化。这种方式可以减少程序启动时的内存消耗，但如果在使用Bean之前没有对其进行正确的配置，可能会导致运行时错误。而ApplicationContext则是在容器启动时，一次性创建所有的Bean。这样做的好处是可以在容器启动时就发现Spring配置中的错误，但可能会增加程序启动时的内存消耗。<br>2.创建方式：BeanFactory通常以编程的方式创建，需要手动编写代码来配置和获取Bean。而ApplicationContext除了支持编程方式创建外，还支持声明方式创建，如使用XML配置文件或注解来配置Bean。这使得ApplicationContext的配置更加灵活和方便。<br>3.功能：<strong>ApplicationContext接口作为BeanFactory的派生</strong>，不仅提供了BeanFactory所具有的功能，还提供了更完整的框架功能。例如，它继承了MessageSource，支持国际化，统一资源文件访问的方式。此外ApplicationContext还支持在监听器中注册bean事件，同时加载多个配置文件和载入多个上下文。</p>
<hr>
<h2 id="谈一下你对Spring-AOP的理解"><a href="#谈一下你对Spring-AOP的理解" class="headerlink" title="谈一下你对Spring AOP的理解"></a>谈一下你对Spring AOP的理解</h2><p>面向切面编程（AOP）：允许程序员模块化横向业务逻辑或定义核心部分的功能，例如日志管理和事务管理。<br><strong>切面（Aspect）</strong>：AOP的核心，它将多个类的<strong>通用行为</strong>封装为可重用的模块。该模块含有一组API提供cross-cutting功能。例如日志模块称为日志的AOP切面。根据需求的不同，一个应用程序可以有若干切面。在Spring AOP中，切面通过带有@Aspect注解的类实现。<br><strong>通知（Advice）</strong>：通知表示在方法执行前后需要执行的动作。实际上它是Spring AOP框架在程序执行过程中触发的一些代码。Spring切面可以执行一下五种类型的通知:</p>
<ul>
<li>before(前置通知)：在一个方法之前执行的通知。</li>
<li>after(最终通知)：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。</li>
<li>after-returning(后置通知)：在某连接点正常完成后执行的通知。</li>
<li>after-throwing(异常通知)：在方法抛出异常退出时执行的通知。</li>
<li>around(环绕通知)：在方法调用前后触发的通知。</li>
</ul>
<p><strong>切入点(Pointcut)<strong>：切入点是一个或一组连接点，</strong>通知将在这些位置执行</strong>。可以通过表达式或匹配的方式指明切入点。<br><strong>引入</strong>：引入允许我们在已有的类上添加新的方法或属性<br><strong>目标对象</strong>：被一个或者多个切面所通知的对象。它通常是一个代理对象。也被称做被<strong>通知（advised）对象</strong>。<br><strong>代理</strong>：代理是将通知应用到目标对象后创建的对象。从客户端的角度看，代理对象和目标对象是一样的。有以下几种代理：</p>
<ul>
<li>BeanNameAutoProxyCreator：bean名称自动代理创建器</li>
<li>DefaultAdvisorAutoProxyCreator：默认通知者自动代理创建器</li>
<li>Metadata autoproxying：元数据自动代理</li>
</ul>
<p><strong>织入</strong>：将切面和其他应用类型或对象连接起来创建一个通知对象的过程。织入可以在编译、加载或运行时完成。</p>
<blockquote>
<p>AOP的实现是需要通过动态代理对象来完成的，而动态代理对象的创建有两种方式，分别是jdk和cglib。（Spring声明式事务）</p>
</blockquote>
<p>源码位置：</p>
<p>org.springframework.beans.factory.config.BeanPostProcessor#postProcessAfterInitialization</p>
<p>实现类：org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * Create a proxy with the configured interceptors if the bean is</span><br><span class="hljs-comment">	 * identified as one to proxy by the subclass.</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@see</span> #getAdvicesAndAdvisorsForBean</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-meta">@Nullable</span><br>	<span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessAfterInitialization</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Object bean, String beanName)</span> &#123;<br>		<span class="hljs-keyword">if</span> (bean != <span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-type">Object</span> <span class="hljs-variable">cacheKey</span> <span class="hljs-operator">=</span> getCacheKey(bean.getClass(), beanName);<br>			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.earlyBeanReferences.remove(cacheKey) != bean) &#123;<br>                <span class="hljs-comment">// 重点，如果它需要被代理，则需要封装指定的bean</span><br>				<span class="hljs-keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">return</span> bean;<br>	&#125;<br><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">wrapIfNecessary</span><span class="hljs-params">(Object bean, String beanName, Object cacheKey)</span> &#123;<br>    ...<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> createProxy(<br>                        bean.getClass(), beanName, specificInterceptors, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingletonTargetSource</span>(bean));<br>    ...<br>&#125;<br><br><span class="hljs-comment">// 创建代理对象</span><br><span class="hljs-keyword">return</span> (classOnly ? proxyFactory.getProxyClass(classLoader) : proxyFactory.getProxy(classLoader));<br></code></pre></td></tr></table></figure>

<ul>
<li>org.springframework.aop.framework.DefaultAopProxyFactory#createAopProxy方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> AopProxy <span class="hljs-title function_">createAopProxy</span><span class="hljs-params">(AdvisedSupport config)</span> <span class="hljs-keyword">throws</span> AopConfigException &#123;<br>	<span class="hljs-keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;<br>		Class&lt;?&gt; targetClass = config.getTargetClass();<br>		<span class="hljs-keyword">if</span> (targetClass == <span class="hljs-literal">null</span>) &#123;<br>			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AopConfigException</span>(<span class="hljs-string">&quot;TargetSource cannot determine target class: &quot;</span> +<br>					<span class="hljs-string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);<br>		&#125;<br>		<span class="hljs-keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass) || ClassUtils.isLambdaClass(targetClass)) &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JdkDynamicAopProxy</span>(config);<br>		&#125;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjenesisCglibAopProxy</span>(config);<br>	&#125;<br>	<span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JdkDynamicAopProxy</span>(config);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://www.helloimg.com/i/2024/09/19/66ec163a81840.png" alt="Snipaste_2024-09-19_20-22-44.png"></p>
<hr>
<h2 id="Lazy注解实现原理"><a href="#Lazy注解实现原理" class="headerlink" title="@Lazy注解实现原理"></a>@Lazy注解实现原理</h2><p><code>@Lazy</code> 注解的实现原理在Spring框架中涉及到Bean的生命周期管理，主要依赖于Spring的IoC容器和代理机制。为了深入理解<code>@Lazy</code>的实现原理，我们需要分析Spring框架中的几个关键组件和类的源码。</p>
<h3 id="1-注解处理"><a href="#1-注解处理" class="headerlink" title="1. 注解处理"></a>1. <strong>注解处理</strong></h3><p>首先，<code>@Lazy</code> 是一个注解，定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD, ElementType.FIELD, ElementType.PARAMETER&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Lazy &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>它可以应用于类、方法、字段、参数上，用来标记懒加载的Bean。默认情况下，<code>value</code> 为 <code>true</code>，表示启用懒加载。</p>
<h3 id="2-如何处理-Lazy-注解"><a href="#2-如何处理-Lazy-注解" class="headerlink" title="2. 如何处理 @Lazy 注解"></a>2. <strong>如何处理 <code>@Lazy</code> 注解</strong></h3><p>在Spring框架中，<code>@Lazy</code> 注解的解析主要通过 <code>ConfigurationClassPostProcessor</code> 和 <code>AutowiredAnnotationBeanPostProcessor</code> 进行处理，分别用于 <code>@Bean</code> 方法和依赖注入字段上的 <code>@Lazy</code>。</p>
<h4 id="2-1-Lazy-在-Bean-方法上的处理"><a href="#2-1-Lazy-在-Bean-方法上的处理" class="headerlink" title="2.1 @Lazy 在 @Bean 方法上的处理"></a>2.1 <code>@Lazy</code> 在 <code>@Bean</code> 方法上的处理</h4><p>当我们在 <code>@Configuration</code> 类的 <code>@Bean</code> 方法上使用 <code>@Lazy</code> 注解时，Spring通过 <code>ConfigurationClassPostProcessor</code> 类来解析和处理这个注解。</p>
<ul>
<li><strong><code>ConfigurationClassPostProcessor</code></strong> 是一个 <code>BeanFactoryPostProcessor</code>，它负责处理配置类（<code>@Configuration</code>）中的 <code>@Bean</code> 方法。当它解析 <code>@Bean</code> 方法时，如果检测到 <code>@Lazy</code> 注解，则会将该 <code>BeanDefinition</code> 标记为懒加载。</li>
</ul>
<p><code>ConfigurationClassPostProcessor</code> 的 <code>processConfigBeanDefinitions</code> 方法负责将<code>@Bean</code> 方法转化为 <code>BeanDefinition</code>，并将 <code>Lazy</code> 属性标记到这些 <code>BeanDefinition</code> 中。具体源码（简化）如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;<br>    <span class="hljs-keyword">for</span> (BeanDefinitionHolder holder : beanDefinitions) &#123;<br>        <span class="hljs-keyword">if</span> (holder.getBeanDefinition() <span class="hljs-keyword">instanceof</span> AbstractBeanDefinition) &#123;<br>            <span class="hljs-type">AbstractBeanDefinition</span> <span class="hljs-variable">beanDef</span> <span class="hljs-operator">=</span> (AbstractBeanDefinition) holder.getBeanDefinition();<br>            <span class="hljs-comment">// 处理 @Lazy 注解</span><br>            <span class="hljs-keyword">if</span> (beanDef.getSource() <span class="hljs-keyword">instanceof</span> MethodMetadata &amp;&amp; ((MethodMetadata) beanDef.getSource()).isAnnotated(Lazy.class.getName())) &#123;<br>                beanDef.setLazyInit(<span class="hljs-literal">true</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里，<code>beanDef.setLazyInit(true)</code> 表示将该Bean设置为懒加载。</p>
<h4 id="2-2-Lazy-在依赖注入中的处理"><a href="#2-2-Lazy-在依赖注入中的处理" class="headerlink" title="2.2 @Lazy 在依赖注入中的处理"></a>2.2 <code>@Lazy</code> 在依赖注入中的处理</h4><p>当我们在字段或构造函数参数上使用 <code>@Lazy</code> 注解时，Spring通过 <code>AutowiredAnnotationBeanPostProcessor</code> 进行处理。<code>@Lazy</code> 在依赖注入场景下的实现是通过代理机制来实现的。</p>
<ul>
<li><strong><code>AutowiredAnnotationBeanPostProcessor</code></strong> 是一个 <code>BeanPostProcessor</code>，用于处理 <code>@Autowired</code> 和其他注入相关的注解。在处理依赖注入时，如果发现某个依赖项带有 <code>@Lazy</code> 注解，它会创建一个懒加载代理对象，而不是立即注入真实的依赖对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">buildLazyResolutionProxy</span><span class="hljs-params">(<span class="hljs-keyword">final</span> DependencyDescriptor descriptor, <span class="hljs-keyword">final</span> String beanName)</span> &#123;<br>    <span class="hljs-keyword">return</span> Proxy.newProxyInstance(<br>        descriptor.getDependencyType().getClassLoader(),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>&lt;?&gt;[] &#123;descriptor.getDependencyType()&#125;,<br>        (proxy, method, args) -&gt; &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> descriptor.resolveDependency(beanFactory, beanName);<br>            <span class="hljs-keyword">return</span> method.invoke(target, args);<br>        &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个 <code>buildLazyResolutionProxy</code> 方法创建了一个代理对象，当调用代理对象上的方法时，才会真正解析并注入目标依赖（通过反射调用 <code>resolveDependency</code> 来进行依赖解析）。这就是依赖注入懒加载的实现方式。</p>
<h3 id="3-懒加载的触发时机"><a href="#3-懒加载的触发时机" class="headerlink" title="3. 懒加载的触发时机"></a>3. <strong>懒加载的触发时机</strong></h3><p>懒加载的核心是：Spring容器不会在容器初始化阶段创建 <code>@Lazy</code> 注解的 Bean，而是在它被第一次访问时（例如通过 <code>getBean</code> 或者注入时）才进行实例化。</p>
<p>对于 <code>@Bean</code> 方法上的懒加载，Spring会将 <code>LazyInit</code> 属性设为 <code>true</code>，在 <code>DefaultListableBeanFactory</code> 中，懒加载的Bean只有在调用 <code>getBean</code> 方法时才会被实例化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">sharedInstance</span> <span class="hljs-operator">=</span> getSingleton(beanName);<br>    <span class="hljs-keyword">if</span> (sharedInstance == <span class="hljs-literal">null</span> &amp;&amp; containsBeanDefinition(beanName)) &#123;<br>        <span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">mbd</span> <span class="hljs-operator">=</span> getMergedLocalBeanDefinition(beanName);<br>        <span class="hljs-keyword">if</span> (mbd.isLazyInit() &amp;&amp; !isAllowEagerClassLoading()) &#123;<br>            <span class="hljs-keyword">return</span> createBean(beanName, mbd, args);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sharedInstance;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个代码片段中，如果 <code>mbd.isLazyInit()</code> 返回 <code>true</code>，Spring就会在 <code>getBean</code> 时调用 <code>createBean</code> 方法，创建这个Bean的实例。</p>
<h3 id="4-代理机制"><a href="#4-代理机制" class="headerlink" title="4. 代理机制"></a>4. <strong>代理机制</strong></h3><p>懒加载的依赖注入通过代理实现。代理对象会延迟实际Bean的创建，直到调用某个方法时才触发Bean的实例化。Spring使用了JDK动态代理或CGLIB代理来实现这一功能。</p>
<ul>
<li><strong>JDK动态代理</strong>：适用于接口代理。如果懒加载的依赖实现了某个接口，Spring会生成一个实现该接口的代理对象。</li>
<li><strong>CGLIB代理</strong>：适用于没有实现接口的类。Spring会生成目标类的子类来实现代理功能。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li><strong><code>@Lazy</code> 注解</strong> 在 <code>@Bean</code> 方法或 <code>@Component</code> 类上用于延迟Bean的实例化，直到被需要时才进行初始化。</li>
<li><strong>依赖注入中的懒加载</strong> 通过动态代理实现，依赖只有在被调用时才会真正初始化。</li>
<li>Spring通过 <code>BeanPostProcessor</code> 和 <code>BeanFactoryPostProcessor</code> 来处理 <code>@Lazy</code> 注解，实现懒加载的功能。</li>
<li>在 <code>getBean</code> 方法第一次访问时触发懒加载Bean的初始化，而代理机制确保了依赖注入的延迟解析。</li>
</ol>
<p>这一机制确保了应用程序在启动时的资源使用更加灵活，特别是在处理大量单例Bean时可以显著优化启动时间和内存使用。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">DrJuly2333</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2024/09/15/JAVA%E9%9D%A2%E8%AF%95Spring%E7%AF%87/">http://example.com/2024/09/15/JAVA%E9%9D%A2%E8%AF%95Spring%E7%AF%87/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JAVA/">JAVA</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/09/15/JAVA%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/" title="JAVA面试八股文基础篇"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">JAVA面试八股文基础篇</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2024/09/15/JAVA%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/" title="JAVA面试八股文基础篇"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-15</div><div class="title">JAVA面试八股文基础篇</div></div></a></div><div><a href="/2024/07/24/Java%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/" title="JAVA工作总结和面试"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-24</div><div class="title">JAVA工作总结和面试</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">DrJuly2333</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/DrJuly2333" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:HTTTS2022@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">欢迎光临小站，这里是我日常收集和整理的总结，希望能对您有所帮助：）<br/><br/>本站的内容经过个人加工总结而来，也参考了网友们分享的资料，如有侵权，请第一时间联系我，我将及时进行修改和删除</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFSpring%E6%A1%86%E6%9E%B6%EF%BC%8C%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E6%A8%A1%E5%9D%97"><span class="toc-number">1.</span> <span class="toc-text">什么是Spring框架，包含哪些模块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Core-Container%EF%BC%88%E6%A0%B8%E5%BF%83%E5%AE%B9%E5%99%A8%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">1. Core Container（核心容器）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-AOP-Aspect-Oriented-Programming"><span class="toc-number">1.2.</span> <span class="toc-text">2. AOP (Aspect-Oriented Programming)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Data-Access-Integration%EF%BC%88%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E5%92%8C%E9%9B%86%E6%88%90%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">3. Data Access&#x2F;Integration（数据访问和集成）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Web"><span class="toc-number">1.4.</span> <span class="toc-text">4. Web</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%82%B9"><span class="toc-number">2.</span> <span class="toc-text">Spring有哪些优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%EF%BC%88IoC%EF%BC%89%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%9F"><span class="toc-number">3.</span> <span class="toc-text">什么是控制反转（IoC）？什么是依赖注入？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%EF%BC%88Inversion-of-Control%EF%BC%8CIoC%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">控制反转（Inversion of Control，IoC）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%88Dependency-Injection%EF%BC%8CDI%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">依赖注入（Dependency Injection，DI）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">3.2.1.</span> <span class="toc-text">依赖注入的几种方式：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IoC%E5%92%8CDI%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">3.3.</span> <span class="toc-text">IoC和DI的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%AF%B9Spring-IoC%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">4.</span> <span class="toc-text">谈一下你对Spring IoC的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-IoC%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%9B%E5%BB%BA%EF%BC%9ABeanFactory-%E5%92%8C-DefaultListableBeanFactory"><span class="toc-number">4.1.</span> <span class="toc-text">1. IoC容器的创建：BeanFactory 和 DefaultListableBeanFactory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8A%A0%E8%BD%BD%E5%92%8C%E8%A7%A3%E6%9E%90Bean%E5%AE%9A%E4%B9%89%EF%BC%9ABeanDefinition"><span class="toc-number">4.2.</span> <span class="toc-text">2. 加载和解析Bean定义：BeanDefinition</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A4%84%E7%90%86-BeanFactoryPostProcessor"><span class="toc-number">4.3.</span> <span class="toc-text">3. 处理 BeanFactoryPostProcessor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%B3%A8%E5%86%8C-BeanPostProcessor"><span class="toc-number">4.4.</span> <span class="toc-text">4. 注册 BeanPostProcessor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%AE%9E%E4%BE%8B%E5%8C%96Bean%EF%BC%9A%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E5%88%9B%E5%BB%BABean%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.5.</span> <span class="toc-text">5. 实例化Bean：通过反射创建Bean对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Bean%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="toc-number">4.6.</span> <span class="toc-text">6. Bean的初始化过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%8E%B7%E5%8F%96%E5%AE%8C%E6%95%B4%E7%9A%84Bean%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.7.</span> <span class="toc-text">7. 获取完整的Bean对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-Bean%E7%9A%84%E9%94%80%E6%AF%81%E8%BF%87%E7%A8%8B"><span class="toc-number">4.8.</span> <span class="toc-text">8. Bean的销毁过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%8F%AF%E9%80%89%EF%BC%89%EF%BC%9A"><span class="toc-number">4.9.</span> <span class="toc-text">源码分析（可选）：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%E4%B8%8Bbean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">5.</span> <span class="toc-text">描述下bean的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%8F%AF%E9%80%89%EF%BC%89"><span class="toc-number">5.1.</span> <span class="toc-text">源码分析（可选）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E4%B8%8B%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84%E5%90%84%E7%A7%8D%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.</span> <span class="toc-text">解释下自动装配的各种模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BeanFactory%E5%92%8CApplicationcontext%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">7.</span> <span class="toc-text">BeanFactory和Applicationcontext有什么区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E4%B8%80%E4%B8%8B%E4%BD%A0%E5%AF%B9Spring-AOP%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">8.</span> <span class="toc-text">谈一下你对Spring AOP的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lazy%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">9.</span> <span class="toc-text">@Lazy注解实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86"><span class="toc-number">9.1.</span> <span class="toc-text">1. 注解处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86-Lazy-%E6%B3%A8%E8%A7%A3"><span class="toc-number">9.2.</span> <span class="toc-text">2. 如何处理 @Lazy 注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-Lazy-%E5%9C%A8-Bean-%E6%96%B9%E6%B3%95%E4%B8%8A%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">9.2.1.</span> <span class="toc-text">2.1 @Lazy 在 @Bean 方法上的处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-Lazy-%E5%9C%A8%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E4%B8%AD%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">9.2.2.</span> <span class="toc-text">2.2 @Lazy 在依赖注入中的处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%87%92%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%A7%A6%E5%8F%91%E6%97%B6%E6%9C%BA"><span class="toc-number">9.3.</span> <span class="toc-text">3. 懒加载的触发时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">9.4.</span> <span class="toc-text">4. 代理机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">9.5.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/15/JAVA%E9%9D%A2%E8%AF%95Spring%E7%AF%87/" title="JAVA面试八股文Spring篇">JAVA面试八股文Spring篇</a><time datetime="2024-09-16T01:52:32.000Z" title="Created 2024-09-15 21:52:32">2024-09-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/15/JAVA%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/" title="JAVA面试八股文基础篇">JAVA面试八股文基础篇</a><time datetime="2024-09-16T01:52:32.000Z" title="Created 2024-09-15 21:52:32">2024-09-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/10/%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" title="鸟哥的Linux实战阅读笔记">鸟哥的Linux实战阅读笔记</a><time datetime="2024-08-10T21:46:35.000Z" title="Created 2024-08-10 17:46:35">2024-08-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/05/Linux%E5%85%A5%E9%97%A8/" title="Linux入门">Linux入门</a><time datetime="2024-08-05T18:33:56.000Z" title="Created 2024-08-05 14:33:56">2024-08-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/30/MiniKube%E5%AE%9E%E6%88%98/" title="Kubernetes实战">Kubernetes实战</a><time datetime="2024-07-30T20:03:35.000Z" title="Created 2024-07-30 16:03:35">2024-07-30</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2024 By DrJuly2333</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async src="/js/title.js"></script><script defer src="https://rmt.dogedoge.com/fetch/~/source/jsdelivr/npm/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="https://cdn.jsdelivr.net/gh/sirxemic/jquery.ripples/dist/jquery.ripples.js"></script><script defer data-pjax src="/js/ripples.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>