<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="[TOC]   本文内容参考：https:&#x2F;&#x2F;github.com&#x2F;whx123&#x2F;JavaHome  if-else代码优化优化方案一：提前return，去除不必要的else优化前： 12345if (condition) &#123;    &#x2F;&#x2F;doSomething&#125; else &#123;    return;&#125; 优化后： 1234if（!condition）&#123;">
<meta property="og:type" content="article">
<meta property="og:title" content="JAVA工作总结和面试">
<meta property="og:url" content="http://example.com/2024/07/24/Java%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="DrJuly2333‘s Blog">
<meta property="og:description" content="[TOC]   本文内容参考：https:&#x2F;&#x2F;github.com&#x2F;whx123&#x2F;JavaHome  if-else代码优化优化方案一：提前return，去除不必要的else优化前： 12345if (condition) &#123;    &#x2F;&#x2F;doSomething&#125; else &#123;    return;&#125; 优化后： 1234if（!condition）&#123;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/823a548cf6d64cedb1dd507c5234788f~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7175534-4ee3a40841c582ec?imageMogr2/auto-orient/strip%7CimageView2/2/w/680/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7175534-897b99e555c1d84e?imageMogr2/auto-orient/strip%7CimageView2/2/w/499/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7175534-b5cf53782e14ae69?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7175534-abebcf2aa87680e3?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7175534-3a68c160832ae950?imageMogr2/auto-orient/strip%7CimageView2/2/w/823/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7175534-e2e338ea3a1479a4?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7175534-ee60659c09771e96?imageMogr2/auto-orient/strip%7CimageView2/2/w/323/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7175534-006823b924ef3772?imageMogr2/auto-orient/strip%7CimageView2/2/w/1020/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7175534-f65917a3e25fb3a2?imageMogr2/auto-orient/strip%7CimageView2/2/w/821/format/webp">
<meta property="og:image" content="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5177218cf2b491da99d43392c7bd271~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f995fb284a7241b9b95431e79a1c37b0~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05fa9ff22d7f42ae82122bfc6c233bd9~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6ca8c98a8cc42c998dd4fe3324ded79~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0abe171336e4f89a58722a1569d64ce~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87387195b86749ddbe1f36582a562988~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/093c6e37453c462985bed78c4d239979~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8a24934eab24bf9b80c402039371aa2~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ddbe230c8dc4501a77ffbe0587b5ba6~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc065cf75803496aa1efafd6d68ba968~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27e9e195810a4a71bdeb38dd128b27e4~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e67dcdfe9d9412dab89961bf92b5b53~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a85eff53f99f420c8139bb69b2d4f6ae~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e624231e978455ebec33c7380ffba0d~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="article:published_time" content="2024-07-24T01:15:32.000Z">
<meta property="article:modified_time" content="2024-09-05T02:40:59.000Z">
<meta property="article:author" content="Dr July">
<meta property="article:tag" content="JAVA">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/823a548cf6d64cedb1dd507c5234788f~tplv-k3u1fbpfcp-zoom-1.image">

<link rel="canonical" href="http://example.com/2024/07/24/Java%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JAVA工作总结和面试 | DrJuly2333‘s Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">DrJuly2333‘s Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/07/24/Java%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dr July">
      <meta itemprop="description" content="一个练习两年半的实习生">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DrJuly2333‘s Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JAVA工作总结和面试
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-07-24 09:15:32" itemprop="dateCreated datePublished" datetime="2024-07-24T09:15:32+08:00">2024-07-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-05 10:40:59" itemprop="dateModified" datetime="2024-09-05T10:40:59+08:00">2024-09-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>[TOC] </p>
<blockquote>
<p>本文内容参考：<a target="_blank" rel="noopener" href="https://github.com/whx123/JavaHome">https://github.com/whx123/JavaHome</a></p>
</blockquote>
<h2 id="if-else代码优化"><a href="#if-else代码优化" class="headerlink" title="if-else代码优化"></a>if-else代码优化</h2><h3 id="优化方案一：提前return，去除不必要的else"><a href="#优化方案一：提前return，去除不必要的else" class="headerlink" title="优化方案一：提前return，去除不必要的else"></a>优化方案一：提前return，去除不必要的else</h3><p><strong>优化前：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="comment">//doSomething</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优化后：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>（!condition）&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//doSomething</span></span><br></pre></td></tr></table></figure>

<h3 id="优化方案二：使用条件三目运算符"><a href="#优化方案二：使用条件三目运算符" class="headerlink" title="优化方案二：使用条件三目运算符"></a>优化方案二：使用条件三目运算符</h3><p><strong>优化前：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> price;</span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    price = <span class="number">80</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    price = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优化后：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">price</span> <span class="operator">=</span> condition ? <span class="number">80</span> : <span class="number">100</span>;</span><br></pre></td></tr></table></figure>


<h3 id="优化方案三：使用枚举"><a href="#优化方案三：使用枚举" class="headerlink" title="优化方案三：使用枚举"></a>优化方案三：使用枚举</h3><p><strong>优化前：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String OrderStatusDes;</span><br><span class="line"><span class="keyword">if</span> (orderStatus == <span class="number">0</span>) &#123;</span><br><span class="line">    OrderStatusDes = <span class="string">&quot;订单未支付&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (OrderStatus == <span class="number">1</span>) &#123;</span><br><span class="line">    OrderStatusDes = <span class="string">&quot;订单已支付&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (OrderStatus == <span class="number">2</span>) &#123;</span><br><span class="line">    OrderStatusDes = <span class="string">&quot;已发货&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><strong>优化后：</strong></p>
<p>定义一个枚举</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">OrderStatusEnum</span> &#123;</span><br><span class="line">    UN_PAID(<span class="number">0</span>, <span class="string">&quot;订单未支付&quot;</span>),</span><br><span class="line">    PAIDED(<span class="number">1</span>, <span class="string">&quot;订单已支付&quot;</span>),</span><br><span class="line">    SENDED(<span class="number">2</span>, <span class="string">&quot;已发货&quot;</span>),</span><br><span class="line">    ;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> index;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OrderStatusEnum(<span class="type">int</span> index, String desc)&#123;</span><br><span class="line">        <span class="built_in">this</span>.index = index;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OrderStatusEnum <span class="title function_">of</span><span class="params">(<span class="type">int</span> orderStatus)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (OrderStatusEnum temp : OrderStatusEnum.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.getIndex() == orderStatus) &#123;</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用枚举</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">OrderStatusDes</span> <span class="operator">=</span> OrderStatusEnum.of(orderStatus).getDesc();</span><br></pre></td></tr></table></figure>
<h3 id="优化方案四：合并条件表达式"><a href="#优化方案四：合并条件表达式" class="headerlink" title="优化方案四：合并条件表达式"></a>优化方案四：合并条件表达式</h3><p><strong>优化前</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">getVipDiscount</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (age &lt; <span class="number">18</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;深圳&quot;</span>.equals(city)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isStudent) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//do somethig</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优化后</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">getVipDiscount</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (age &lt; <span class="number">18</span> || <span class="string">&quot;深圳&quot;</span>.equals(city) || isStudent) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//doSomthing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优化方案五：使用-Optional"><a href="#优化方案五：使用-Optional" class="headerlink" title="优化方案五：使用 Optional"></a>优化方案五：使用 Optional</h3><p>如果if-else比较多是因为<strong>非空判断</strong>导致的，可以使用java8的Optional进行优化。</p>
<p><strong>优化前：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;testOptional&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (str != <span class="literal">null</span>) &#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Null&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优化后：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; strOptional = Optional.of(<span class="string">&quot;testOptional&quot;</span>);</span><br><span class="line">strOptional.ifPresentOrElse(System.out::println, () -&gt; System.out.println(<span class="string">&quot;Null&quot;</span>));</span><br></pre></td></tr></table></figure>


<h3 id="优化方案六：表驱动法"><a href="#优化方案六：表驱动法" class="headerlink" title="优化方案六：表驱动法"></a>优化方案六：表驱动法</h3><p>表驱动法是一种在表(map)中查找信息，省去不必要的逻辑语句。</p>
<p><strong>优化前：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (param.equals(value1)) &#123;</span><br><span class="line">    doAction1(someParams);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (param.equals(value2)) &#123;</span><br><span class="line">    doAction2(someParams);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (param.equals(value3)) &#123;</span><br><span class="line">    doAction3(someParams);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p><strong>优化后：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型 ? 方便演示，可替换为你需要的类型</span></span><br><span class="line">Map&lt;?, Function&lt;?&gt; action&gt; actionMappings = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">actionMappings.put(value1, (someParams) -&gt; &#123; doAction1(someParams)&#125;);</span><br><span class="line">actionMappings.put(value2, (someParams) -&gt; &#123; doAction2(someParams)&#125;);</span><br><span class="line">actionMappings.put(value3, (someParams) -&gt; &#123; doAction3(someParams)&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略多余逻辑语句</span></span><br><span class="line">actionMappings.get(param).apply(someParams);</span><br></pre></td></tr></table></figure>

<h3 id="优化方案七：优化逻辑结构，让正常流程走主干"><a href="#优化方案七：优化逻辑结构，让正常流程走主干" class="headerlink" title="优化方案七：优化逻辑结构，让正常流程走主干"></a>优化方案七：优化逻辑结构，让正常流程走主干</h3><p><strong>优化前：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getAdjustedCapital</span><span class="params">(<span class="type">double</span> capital, <span class="type">double</span> income, <span class="type">int</span> intRate, <span class="type">int</span> duration)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (capital &lt;= <span class="number">0.0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (intRate &gt; <span class="number">0</span> &amp;&amp; duration &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (income / duration) * ADJ_FACTOR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优化后：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getAdjustedCapital</span><span class="params">(<span class="type">double</span> capital, <span class="type">double</span> income, <span class="type">int</span> intRate, <span class="type">int</span> duration)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (capital &lt;= <span class="number">0.0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将条件反转使异常情况先退出</span></span><br><span class="line">    <span class="keyword">if</span> (intRate &lt;= <span class="number">0</span> || duration &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 让正常流程维持在主干流程，可以让代码结构更加清晰</span></span><br><span class="line">    <span class="keyword">return</span> (income / duration) * ADJ_FACTOR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优化方案八：策略模式-工厂方法消除if-else"><a href="#优化方案八：策略模式-工厂方法消除if-else" class="headerlink" title="优化方案八：策略模式+工厂方法消除if else"></a>优化方案八：策略模式+工厂方法消除if else</h3><p>假设需求为：根据不同勋章类型，处理相对应的勋章服务</p>
<p><strong>优化前：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">medalType</span> <span class="operator">=</span> <span class="string">&quot;guest&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;guest&quot;</span>.equals(medalType)) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;嘉宾勋章&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;vip&quot;</span>.equals(medalType)) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;会员勋章&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;guard&quot;</span>.equals(medalType)) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;展示守护勋章&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><strong>优化后：</strong></p>
<ol>
<li>把每个条件逻辑代码块，抽象成一个公共的接口：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 勋章接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IMedalService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">showMedal</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>根据每个逻辑条件，定义相对应的策略实现类：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 守护勋章策略实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuardMedalServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IMedalService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showMedal</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;展示守护勋章&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 嘉宾勋章策略实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuestMedalServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IMedalService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showMedal</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;嘉宾勋章&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// VIP勋章策略实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VipMedalServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IMedalService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showMedal</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;会员勋章&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>定义策略工厂类，用来管理这些勋章实现策略类：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//勋章服务工产类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MedalServicesFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, IMedalService&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        map.put(<span class="string">&quot;guard&quot;</span>, <span class="keyword">new</span> <span class="title class_">GuardMedalServiceImpl</span>());</span><br><span class="line">        map.put(<span class="string">&quot;vip&quot;</span>, <span class="keyword">new</span> <span class="title class_">VipMedalServiceImpl</span>());</span><br><span class="line">        map.put(<span class="string">&quot;guest&quot;</span>, <span class="keyword">new</span> <span class="title class_">GuestMedalServiceImpl</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> IMedalService <span class="title function_">getMedalService</span><span class="params">(String medalType)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(medalType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>使用了策略+工厂模式之后，代码变得简洁多了：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">medalType</span> <span class="operator">=</span> <span class="string">&quot;guest&quot;</span>;</span><br><span class="line">        <span class="type">IMedalService</span> <span class="variable">medalService</span> <span class="operator">=</span> MedalServicesFactory.getMedalService(medalType);</span><br><span class="line">        medalService.showMedal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java异常处理的十个建议"><a href="#Java异常处理的十个建议" class="headerlink" title="Java异常处理的十个建议"></a>Java异常处理的十个建议</h2><h3 id="一、使用log打印，尽量不要使用e-printStackTrace"><a href="#一、使用log打印，尽量不要使用e-printStackTrace" class="headerlink" title="一、使用log打印，尽量不要使用e.printStackTrace()"></a>一、使用log打印，尽量不要使用e.printStackTrace()</h3><p><strong>反例:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>正例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.info(<span class="string">&quot;运行出错,&#123;&#125;&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>理由：</strong></p>
<ul>
<li>printStackTrace()打印出的堆栈日志跟业务代码日志是混合在一起的，通常排查异常日志不太方便</li>
<li>e.printStackTrace()语句产生的字符串记录的是堆栈信息，如果信息太多，字符串常量池没有空间，导致用户请求卡住</li>
</ul>
<h3 id="二、catch了异常，但是没有打印出具体的exception，无法更好定位问题"><a href="#二、catch了异常，但是没有打印出具体的exception，无法更好定位问题" class="headerlink" title="二、catch了异常，但是没有打印出具体的exception，无法更好定位问题"></a>二、catch了异常，但是没有打印出具体的exception，无法更好定位问题</h3><p><strong>反例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.info(<span class="string">&quot;运行出错&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>正例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.info(<span class="string">&quot;运行出错，&#123;&#125;&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>理由：</strong></p>
<ul>
<li>没有把exception打印出来，排查问题困难，不知道是SQl异常、IO异常还是其他异常</li>
</ul>
<h3 id="三、不要用一个Exception捕捉所有可能的异常"><a href="#三、不要用一个Exception捕捉所有可能的异常" class="headerlink" title="三、不要用一个Exception捕捉所有可能的异常"></a>三、不要用一个Exception捕捉所有可能的异常</h3><p><strong>反例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 抛出 IOException 的代码调用</span></span><br><span class="line">        <span class="comment">// 抛出 SQLException 的代码调用</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">//用基类 Exception 捕捉的所有可能的异常，如果多个层次都这样捕捉，会丢失原始异常的有效信息哦</span></span><br><span class="line">        log.info(<span class="string">&quot;运行出错:&#123;&#125;&quot;</span>,e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>正例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 抛出 IOException 的代码调用</span></span><br><span class="line">        <span class="comment">// 抛出 SQLException 的代码调用</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">//仅仅捕捉 IOException</span></span><br><span class="line">        log.info(<span class="string">&quot;IOException in test,exception:&#123;&#125;&quot;</span>, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        <span class="comment">//仅仅捕捉 SQLException</span></span><br><span class="line">        log.info(<span class="string">&quot;SQLException in test,exception:&#123;&#125;&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>理由：</p>
<ul>
<li>捕获和处理异常时，尽可能保留原始异常作为新的异常的原因</li>
<li>在每个层次记录详细的异常信息和堆栈跟踪</li>
<li>避免在捕获异常时过于宽泛，尽量捕获具体的异常类型，以便更精确地处理</li>
</ul>
<h3 id="四、使用finally或直接try-with-resource关闭流资源"><a href="#四、使用finally或直接try-with-resource关闭流资源" class="headerlink" title="四、使用finally或直接try-with-resource关闭流资源"></a>四、使用finally或直接try-with-resource关闭流资源</h3><p><strong>反例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fdIn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    fdIn = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/jay.txt&quot;</span>));</span><br><span class="line">    <span class="comment">// 在这里关闭流资源？有没有问题呢？如果发生异常了呢？</span></span><br><span class="line">    fdIn.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>正例1：</strong>使用finally关闭流资源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fdIn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    fdIn = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;/jay.txt&quot;</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fdIn != <span class="literal">null</span>) &#123;</span><br><span class="line">            fdIn.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>正例2：</strong>使用JDK7的新特性try-with-resource来处理，它用于自动资源管理</p>
<ul>
<li>资源是指在程序用完了之后必须要关闭的对象</li>
<li>try-with-resources保证了每个声明了的资源在语句结束的时候会被关闭</li>
<li>什么样的对象才能当做资源使用呢？只要实现了java.lang.AutoCloseable接口或者java.io.Closeable接口的对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;jay.txt&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// use resources   </span></span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>理由：</strong></p>
<ul>
<li>如果不使用finally或者try-with-resource，当程序发生异常，IO资源流没关闭，那么这个IO资源就会一直占着，别人没法使用，造成资源浪费</li>
</ul>
<h3 id="五、捕获异常与抛出异常必须是完全匹配，或者捕获异常是抛异常的父类"><a href="#五、捕获异常与抛出异常必须是完全匹配，或者捕获异常是抛异常的父类" class="headerlink" title="五、捕获异常与抛出异常必须是完全匹配，或者捕获异常是抛异常的父类"></a>五、捕获异常与抛出异常必须是完全匹配，或者捕获异常是抛异常的父类</h3><p><strong>反例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BizException 是 Exception 的子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BizException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 抛出父类Exception</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    test(); <span class="comment">// 编译错误</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (BizException e) &#123; <span class="comment">// 捕获异常子类是没法匹配的</span></span><br><span class="line">    log.error(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>正例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抛出子类Exception</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> BizException &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    test();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="六、注意异常对代码层次结构的侵染（早发现早处理）"><a href="#六、注意异常对代码层次结构的侵染（早发现早处理）" class="headerlink" title="六、注意异常对代码层次结构的侵染（早发现早处理）"></a>六、注意异常对代码层次结构的侵染（早发现早处理）</h3><p><strong>反例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> UserInfo <span class="title function_">queryUserInfoByUserId</span><span class="params">(Long userid)</span> <span class="keyword">throw</span> SQLException &#123;</span><br><span class="line">    <span class="comment">// 根据用户Id查询数据库</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>正例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> UserInfo <span class="title function_">queryUserInfoByUserId</span><span class="params">(Long userid)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 根据用户Id查询数据库</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;查询数据库异常，&#123;&#125;&quot;</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//关闭连接，清理资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>理由：</strong></p>
<ul>
<li>我们的项目，一般都会把代码分 Action、Service、Dao 等不同的层次结构，如果你是DAO层处理的异常，尽早处理，如果往上 throw SQLException，上层代码还是要try catch处理，这就污染了你的代码</li>
</ul>
<h3 id="七、自定义封装异常，不要丢弃原始异常的信息Throwable-cause"><a href="#七、自定义封装异常，不要丢弃原始异常的信息Throwable-cause" class="headerlink" title="七、自定义封装异常，不要丢弃原始异常的信息Throwable cause"></a>七、自定义封装异常，不要丢弃原始异常的信息Throwable cause</h3><p>我们常常会想要在捕获一个异常后抛出另一个异常，并且希望把原始异常的信息保存下来，这被称为异常链。公司的框架提供统一异常处理就用到异常链，我们自定义封装异常，不要丢弃原始异常的信息，否则排查问题很头疼</p>
<p><strong>反例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestChainException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> <span class="keyword">throws</span> MyException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;jay.txt&quot;</span>);</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(is);</span><br><span class="line">            <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">                System.out.println(in.next());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// e 保存异常信息</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;文件在哪里呢&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invokeReadFile</span><span class="params">()</span> <span class="keyword">throws</span> MyException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            readFile();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">            <span class="comment">// e 保存异常信息</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;文件找不到&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TestChainException</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestChainException</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t.invokeReadFile();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyException 构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>正例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestChainException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span> <span class="keyword">throws</span> MyException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;jay.txt&quot;</span>);</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(is);</span><br><span class="line">            <span class="keyword">while</span> (in.hasNext()) &#123;</span><br><span class="line">                System.out.println(in.next());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// e 保存异常信息</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;文件在哪里呢&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invokeReadFile</span><span class="params">()</span> <span class="keyword">throws</span> MyException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            readFile();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">            <span class="comment">// e 保存异常信息</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;文件找不到&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TestChainException</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestChainException</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t.invokeReadFile();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyException 构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String message, Throwable cause)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(message, cause);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="八、运行时异常RuntimeException-，不应该通过catch-的方式来处理，而是先预检查，比如：NullPointerException处理"><a href="#八、运行时异常RuntimeException-，不应该通过catch-的方式来处理，而是先预检查，比如：NullPointerException处理" class="headerlink" title="八、运行时异常RuntimeException ，不应该通过catch 的方式来处理，而是先预检查，比如：NullPointerException处理"></a>八、运行时异常RuntimeException ，不应该通过catch 的方式来处理，而是先预检查，比如：NullPointerException处理</h3><p><strong>反例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    obj.method();</span><br><span class="line">&#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>正例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="九、注意异常匹配的顺序，优先捕获具体的异常"><a href="#九、注意异常匹配的顺序，优先捕获具体的异常" class="headerlink" title="九、注意异常匹配的顺序，优先捕获具体的异常"></a>九、注意异常匹配的顺序，优先捕获具体的异常</h3><p>注意异常的匹配顺序，因为只有第一个匹配到异常的catch块才会被执行。</p>
<p><strong>反例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    doSomething(<span class="string">&quot;test exception&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;       </span><br><span class="line">    log.error(e);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>正例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    doSomething(<span class="string">&quot;test exception&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;       </span><br><span class="line">    log.error(e);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>理由：</strong></p>
<ul>
<li>因为NumberFormatException是IllegalArgumentException 的子类，反例中，不管是哪个异常，都会匹配到IllegalArgumentException，就不会再往下执行，因此不知道是否是NumberFormatException。所以需要优先捕获具体的异常，把NumberFormatException放前面</li>
</ul>
<h2 id="Java序列化"><a href="#Java序列化" class="headerlink" title="Java序列化"></a>Java序列化</h2><p>在日常开发中，经常看到Java对象<code>implements Serializable</code>。那么，它到底有什么用呢？</p>
<h3 id="一、什么是Java序列化"><a href="#一、什么是Java序列化" class="headerlink" title="一、什么是Java序列化"></a>一、什么是Java序列化</h3><ul>
<li><strong>序列化</strong>：把Java对象转换为字节数组的过程</li>
<li><strong>反序列化</strong>：把字节数组恢复为Java对象的过程</li>
</ul>
<h3 id="二、为什么需要序列化？"><a href="#二、为什么需要序列化？" class="headerlink" title="二、为什么需要序列化？"></a>二、为什么需要序列化？</h3><p>Java对象是运行在JVM堆内存的，JVM停止后，它的生命也就结束了。</p>
<p>如果想在JVM停止后，把这些对象保存到磁盘或者通过网络传输到另一远程机器，怎么办呢？磁盘可不认识Java对象，它只认识二进制，所以就要把这些对象转化为字节数组，这个过程就是序列化</p>
<blockquote>
<p>打个比喻，作为大城市漂泊的码农，搬家是常态。当我们搬书桌时，桌子太大了就通不过比较小的门，因此我们需要把它拆开再搬过去，这个拆桌子的过程就是序列化。 而我们把书桌复原回来（安装）的过程就是反序列化</p>
</blockquote>
<h3 id="三、序列化用途"><a href="#三、序列化用途" class="headerlink" title="三、序列化用途"></a>三、序列化用途</h3><p>序列化使得对象可以脱离程序运行而独立存在，它主要有两种用途：</p>
<ul>
<li>1） 序列化机制可以让对象保存到硬盘上，减轻内存压力的同时，也起了持久化的作用</li>
</ul>
<blockquote>
<p>比如 Web服务器中的Session对象，当有 10+万用户并发访问时，就有可能出现10万个Session对象，内存可能消化不了，于是Web容器就会把一些seesion先序列化到硬盘中，等要用了，再把保存在硬盘中的对象还原到内存中。</p>
</blockquote>
<ul>
<li>2） 序列化机制让Java对象在网络传输不再是天方夜谭<blockquote>
<p>我们在使用Dubbo远程调用服务框架时，需要把传输的Java对象实现Serializable接口，即让Java对象序列化，这样才能让对象在网络上传输。</p>
</blockquote>
</li>
</ul>
<h3 id="四、Java序列化常用API"><a href="#四、Java序列化常用API" class="headerlink" title="四、Java序列化常用API"></a>四、Java序列化常用API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.io.ObjectOutputStream</span><br><span class="line">java.io.ObjectInputStream</span><br><span class="line">java.io.Serializable</span><br><span class="line">java.io.Externalizable</span><br></pre></td></tr></table></figure>
<h4 id="Serializable-接口"><a href="#Serializable-接口" class="headerlink" title="Serializable 接口"></a>Serializable 接口</h4><p>Serializable接口是一个<strong>标记接口</strong>，没有方法或字段。一旦实现了此接口，就标志该类的对象就是可序列化的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Serializable</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Externalizable-接口"><a href="#Externalizable-接口" class="headerlink" title="Externalizable 接口"></a>Externalizable 接口</h4><p>Externalizable继承了Serializable接口，还定义了两个抽象方法：<code>writeExternal()</code>和<code>readExternal()</code>，如果开发人员使用Externalizable来实现序列化和反序列化，需要重写writeExternal()和readExternal()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Externalizable</span> <span class="keyword">extends</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="java-io-ObjectOutputStream类"><a href="#java-io-ObjectOutputStream类" class="headerlink" title="java.io.ObjectOutputStream类"></a>java.io.ObjectOutputStream类</h4><p>ObjectOutputStream：对象输出流，它的<code>writeObject(Object obj)</code>方法可以对指定obj对象参数进行序列化，再把得到的字节序列写到一个目标输出流中</p>
<h4 id="java-io-ObjectInputStream"><a href="#java-io-ObjectInputStream" class="headerlink" title="java.io.ObjectInputStream"></a>java.io.ObjectInputStream</h4><p>ObjectInputStream：对象输入流，它的<code>readObject()</code>方法，从输入流中读取到字节序列，反序列化成为一个对象，最后将其返回</p>
<h3 id="五、序列化的使用"><a href="#五、序列化的使用" class="headerlink" title="五、序列化的使用"></a>五、序列化的使用</h3><p>序列化的使用的几个关键点：</p>
<ul>
<li>声明一个实体类，实现Serializable接口</li>
<li>使用ObjectOutputStream类的writeObject方法，实现序列化</li>
<li>使用ObjectInputStream类的readObject方法，实现反序列化</li>
</ul>
<h4 id="声明一个Student类，实现Serializable"><a href="#声明一个Student类，实现Serializable" class="headerlink" title="声明一个Student类，实现Serializable"></a>声明一个Student类，实现Serializable</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    -- getter and setter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用ObjectOutputStream类的writeObject方法，对Student对象实现序列化"><a href="#使用ObjectOutputStream类的writeObject方法，对Student对象实现序列化" class="headerlink" title="使用ObjectOutputStream类的writeObject方法，对Student对象实现序列化"></a>使用ObjectOutputStream类的writeObject方法，对Student对象实现序列化</h4><p>把Student对象设置值后，写入一个文件，即序列化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>( <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:\\text.out&quot;</span>));</span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">student.setAge(<span class="number">25</span>);</span><br><span class="line">student.setName(<span class="string">&quot;jay&quot;</span>);</span><br><span class="line">os.writeObject(student);</span><br><span class="line"></span><br><span class="line">os.flush();</span><br><span class="line">os.close();</span><br></pre></td></tr></table></figure>
<h4 id="使用ObjectInputStream类的readObject方法，实现反序列化，重新生成Student对象"><a href="#使用ObjectInputStream类的readObject方法，实现反序列化，重新生成Student对象" class="headerlink" title="使用ObjectInputStream类的readObject方法，实现反序列化，重新生成Student对象"></a>使用ObjectInputStream类的readObject方法，实现反序列化，重新生成Student对象</h4><p>再把test.out文件读取出来，反序列化为Student对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\text.out&quot;</span>));</span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) is.readObject();</span><br><span class="line">System.out.println(<span class="string">&quot;name = &quot;</span> + student.getName());</span><br></pre></td></tr></table></figure>
<h3 id="六、序列化底层"><a href="#六、序列化底层" class="headerlink" title="六、序列化底层"></a>六、序列化底层</h3><h4 id="Serializable底层"><a href="#Serializable底层" class="headerlink" title="Serializable底层"></a>Serializable底层</h4><p>Serializable接口，只是一个空接口，没有方法或字段，为什么这么神奇，实现了它就可以让对象序列化了？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Serializable</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>为了验证Serializable的作用，把以上demo的Student对象，去掉实现Serializable接口，序列化过程就抛出异常了，堆栈信息如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.io.NotSerializableException: com.example.demo.Student</span><br><span class="line">    at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:<span class="number">1184</span>)</span><br><span class="line">    at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:<span class="number">348</span>)</span><br><span class="line">    at com.example.demo.Test.main(Test.java:<span class="number">13</span>)</span><br></pre></td></tr></table></figure>
<p><strong>原来底层是这样：</strong></p>
<blockquote>
<p>ObjectOutputStream#writeObject(Object obj)中的writeObject0(obj, false);</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// remaining cases</span></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    writeString((String) obj, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">    writeArray(obj, desc, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;</span><br><span class="line">    writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">    writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotSerializableException</span>(</span><br><span class="line">            cl.getName() + <span class="string">&quot;\n&quot;</span> + debugInfoStack.toString());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotSerializableException</span>(cl.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ObjectOutputStream 在序列化的时候，会判断被序列化的Object是哪一种类型，<code>String | array | enum | Serializable</code>，如果都不是的话，抛出 NotSerializableException异常。所以<strong>Serializable真的只是一个标志，一个序列化标志</strong></p>
<h4 id="writeObject（Object）"><a href="#writeObject（Object）" class="headerlink" title="writeObject（Object）"></a>writeObject（Object）</h4><p>序列化的方法就是writeObject，基于以上的demo，我们来分析一波它的核心方法调用链吧</p>
<ul>
<li>writeObject直接调用的就是writeObject0方法，</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    ......</span><br><span class="line">    writeObject0(obj, <span class="literal">false</span>);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>writeObject0 主要实现是对象的不同类型，调用不同的方法写入序列化数据，这里面如果对象实现了Serializable接口，就调用writeOrdinaryObject()方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject0</span><span class="params">(Object obj, <span class="type">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// String类型</span></span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        writeString((String) obj, unshared);</span><br><span class="line">        <span class="comment">// 数组类型</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">        writeArray(obj, desc, unshared);</span><br><span class="line">        <span class="comment">// 枚举类型</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;</span><br><span class="line">        writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line">        <span class="comment">// Serializable实现序列化接口</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">        writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 其他情况会抛异常~</span></span><br><span class="line">        <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotSerializableException</span>(</span><br><span class="line">                cl.getName() + <span class="string">&quot;\n&quot;</span> + debugInfoStack.toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NotSerializableException</span>(cl.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>

<ul>
<li>writeOrdinaryObject()会先调用writeClassDesc(desc)，写入该类的生成信息，然后调用writeSerialData方法,写入序列化数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeOrdinaryObject</span><span class="params">(Object obj,</span></span><br><span class="line"><span class="params">                                     ObjectStreamClass desc,</span></span><br><span class="line"><span class="params">                                     <span class="type">boolean</span> unshared)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException</span><br><span class="line">    &#123;</span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// 调用ObjectStreamClass的写入方法</span></span><br><span class="line">    writeClassDesc(desc, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 判断是否实现了Externalizable接口</span></span><br><span class="line">    <span class="keyword">if</span> (desc.isExternalizable() &amp;&amp; !desc.isProxy()) &#123;</span><br><span class="line">        writeExternalData((Externalizable) obj);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 写入序列化数据</span></span><br><span class="line">        writeSerialData(obj, desc);</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>writeSerialData()实现的就是写入被序列化对象的字段数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeSerialData</span><span class="params">(Object obj, ObjectStreamClass desc)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; slots.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (slotDesc.hasWriteObjectMethod()) &#123;</span><br><span class="line">            <span class="comment">// 如果被序列化的对象自定义实现了writeObject()方法，则执行这个代码块</span></span><br><span class="line">            slotDesc.invokeWriteObject(obj, <span class="built_in">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 调用默认的方法写入实例数据</span></span><br><span class="line">            defaultWriteFields(obj, slotDesc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>defaultWriteFields()方法，获取类的基本数据类型数据，直接写入底层字节容器；获取类的obj类型数据，循环递归调用writeObject0()方法，写入数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">defaultWriteFields</span><span class="params">(Object obj, ObjectStreamClass desc)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">// 获取类的基本数据类型数据，保存到primVals字节数组</span></span><br><span class="line">    desc.getPrimFieldValues(obj, primVals);</span><br><span class="line">    <span class="comment">// primVals的基本类型数据写到底层字节容器</span></span><br><span class="line">    bout.write(primVals, <span class="number">0</span>, primDataSize, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取对应类的所有字段对象</span></span><br><span class="line">    ObjectStreamField[] fields = desc.getFields(<span class="literal">false</span>);</span><br><span class="line">    Object[] objVals = <span class="keyword">new</span> <span class="title class_">Object</span>[desc.getNumObjFields()];</span><br><span class="line">    <span class="type">int</span> <span class="variable">numPrimFields</span> <span class="operator">=</span> fields.length - objVals.length;</span><br><span class="line">    <span class="comment">// 获取类的obj类型数据，保存到objVals字节数组</span></span><br><span class="line">    desc.getObjFieldValues(obj, objVals);</span><br><span class="line">    <span class="comment">// 对所有Object类型的字段,循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; objVals.length; i++) &#123;</span><br><span class="line">        ......</span><br><span class="line">            <span class="comment">// 递归调用writeObject0()方法，写入对应的数据</span></span><br><span class="line">            writeObject0(objVals[i],</span><br><span class="line">                         fields[numPrimFields + i].isUnshared());</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="七、日常开发序列化的一些注意点"><a href="#七、日常开发序列化的一些注意点" class="headerlink" title="七、日常开发序列化的一些注意点"></a>七、日常开发序列化的一些注意点</h3><ul>
<li><strong><code>static</code><strong>静态变量和</strong><code>transient</code></strong> 修饰的字段不会被序列化</li>
<li><code>serialVersionUID</code>问题</li>
<li>如果某个序列化类的成员变量是对象类型，则该对象类型的类必须实现序列化</li>
<li>子类实现了序列化，父类没有实现序列化，父类中的字段丢失问题</li>
</ul>
<h4 id="static静态变量和transient-修饰的字段不会被序列化"><a href="#static静态变量和transient-修饰的字段不会被序列化" class="headerlink" title="static静态变量和transient 修饰的字段不会被序列化"></a>static静态变量和transient 修饰的字段不会被序列化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">gender</span> <span class="operator">=</span> <span class="string">&quot;男&quot;</span>;</span><br><span class="line">    <span class="comment">// transient修饰</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">String</span> <span class="variable">specialty</span> <span class="operator">=</span> <span class="string">&quot;计算机专业&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSpecialty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> specialty;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSpecialty</span><span class="params">(String specialty)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.specialty = specialty;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> + <span class="string">&quot;age=&quot;</span> + age + <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&quot;, gender=&#x27;&quot;</span> + gender + <span class="string">&#x27;\&#x27;&#x27;</span> + <span class="string">&quot;, specialty=&#x27;&quot;</span> + specialty + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>
<p>打印学生对象，序列化到文件，接着修改静态变量的值，再反序列化，输出反序列化后的对象，运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">序列化前：Student&#123;age=<span class="number">25</span>, name=<span class="string">&#x27;jay&#x27;</span>, gender=<span class="string">&#x27;男&#x27;</span>, specialty=<span class="string">&#x27;计算机专业&#x27;</span>&#125;</span><br><span class="line">序列化后：Student&#123;age=<span class="number">25</span>, name=<span class="string">&#x27;jay&#x27;</span>, gender=<span class="string">&#x27;女&#x27;</span>, specialty=<span class="string">&#x27;null&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>对比结果可以发现：</p>
<ul>
<li>1）序列化前的静态变量性别明明是‘男’，序列化后再在程序中修改，反序列化后却变成‘女’了，显然这个静态属性并没有进行序列化。其实，<strong>静态（static）成员变量是属于类级别的，而序列化是针对对象的~所以不能序列化</strong></li>
<li>2）经过序列化和反序列化过程后，specialty字段变量值由’计算机专业’变为<code>null</code>了，因为transient关键字，<strong>它可以阻止修饰的字段被序列化到文件中</strong>，在被反序列化后，transient 字段的值被设为初始值</li>
</ul>
<h4 id="serialVersionUID问题"><a href="#serialVersionUID问题" class="headerlink" title="serialVersionUID问题"></a>serialVersionUID问题</h4><p>serialVersionUID 表面意思就是<strong>序列化版本号ID</strong>，其实每一个实现Serializable接口的类，都有一个表示序列化版本标识符的静态变量，或者默认等于1L，或者等于对象的哈希码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">6384871967268653799L</span>;</span><br></pre></td></tr></table></figure>
<h5 id="serialVersionUID有什么用？"><a href="#serialVersionUID有什么用？" class="headerlink" title="serialVersionUID有什么用？"></a><strong>serialVersionUID有什么用？</strong></h5><p>JAVA序列化的机制是通过判断类的serialVersionUID来验证版本是否一致的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID和本地相应实体类的serialVersionUID进行比较，如果相同，反序列化成功，如果不相同，就抛出<code>InvalidClassException</code>异常。</p>
<ul>
<li>修改一下Student类，再反序列化操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.io.InvalidClassException: com.example.demo.Student;</span><br><span class="line">local <span class="keyword">class</span> <span class="title class_">incompatible</span>: stream <span class="type">classdesc</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">3096644667492403394</span>,</span><br><span class="line">local <span class="keyword">class</span> <span class="title class_">serialVersionUID</span> = <span class="number">4429793331949928814</span></span><br><span class="line">    at java.io.ObjectStreamClass.initNonProxy(ObjectStreamClass.java:<span class="number">687</span>)</span><br><span class="line">    at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:<span class="number">1876</span>)</span><br><span class="line">    at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:<span class="number">1745</span>)</span><br><span class="line">    at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:<span class="number">2033</span>)</span><br><span class="line">    at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:<span class="number">1567</span>)</span><br><span class="line">    at java.io.ObjectInputStream.readObject(ObjectInputStream.java:<span class="number">427</span>)</span><br><span class="line">    at com.example.demo.Test.main(Test.java:<span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<p>从日志堆栈异常信息可以看到，文件流中的class和当前类路径中的class不同了，它们的serialVersionUID不相同，所以反序列化抛出InvalidClassException异常。那么，如果确实需要修改Student类，又想反序列化成功，怎么办呢？可以手动指定serialVersionUID的值，一般可以设置为1L或者让IDE生成</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">6564022808907262054L</span>;</span><br></pre></td></tr></table></figure>
<p>实际上，阿里开发手册，强制要求序列化类新增属性时，不能修改serialVersionUID字段</p>
<h4 id="如果某个序列化类的成员变量是对象类型，则该对象类型的类必须实现序列化"><a href="#如果某个序列化类的成员变量是对象类型，则该对象类型的类必须实现序列化" class="headerlink" title="如果某个序列化类的成员变量是对象类型，则该对象类型的类必须实现序列化"></a>如果某个序列化类的成员变量是对象类型，则该对象类型的类必须实现序列化</h4><ul>
<li>给Student类添加一个Teacher类型的成员变量，其中Teacher是没有实现序列化接口的</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Teacher teacher;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Teacher 没有实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span>  &#123;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>序列化运行，报<code>NotSerializableException</code>异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.io.NotSerializableException: com.example.demo.Teacher</span><br><span class="line">    at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:<span class="number">1184</span>)</span><br><span class="line">    at java.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:<span class="number">1548</span>)</span><br><span class="line">    at java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:<span class="number">1509</span>)</span><br><span class="line">    at java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:<span class="number">1432</span>)</span><br><span class="line">    at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:<span class="number">1178</span>)</span><br><span class="line">    at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:<span class="number">348</span>)</span><br><span class="line">    at com.example.demo.Test.main(Test.java:<span class="number">16</span>)</span><br></pre></td></tr></table></figure>
<p>一个对象序列化过程，会循环获取它的Object类型字段进行递归调用来序列化的，也就是说，序列化Student类的时候，会对Teacher类进行序列化，但是对Teacher没有实现序列化接口，因此抛出<code>NotSerializableException</code>异常。所以如果某个实例化类的成员变量是对象类型，则该对象类型的类必须实现序列化</p>
<h4 id="子类实现了Serializable，父类没有实现Serializable接口的话，父类不会被序列化"><a href="#子类实现了Serializable，父类没有实现Serializable接口的话，父类不会被序列化" class="headerlink" title="子类实现了Serializable，父类没有实现Serializable接口的话，父类不会被序列化"></a>子类实现了Serializable，父类没有实现Serializable接口的话，父类不会被序列化</h4><ul>
<li>子类Student实现了Serializable接口，父类User没有实现Serializable接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类实现了Serializable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父类没有实现Serializable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    String userId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">student.setAge(<span class="number">25</span>);</span><br><span class="line">student.setName(<span class="string">&quot;jayWei&quot;</span>);</span><br><span class="line">student.setUserId(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:\\text.out&quot;</span>));</span><br><span class="line">objectOutputStream.writeObject(student);</span><br><span class="line"></span><br><span class="line">objectOutputStream.flush();</span><br><span class="line">objectOutputStream.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化结果</span></span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\text.out&quot;</span>));</span><br><span class="line"><span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> (Student) objectInputStream.readObject();</span><br><span class="line">System.out.println(student1.getUserId());	<span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p>从反序列化结果，可以发现，父类属性值丢失了。因此子类实现了Serializable接口，父类没有实现Serializable接口的话，父类不会被序列化。</p>
<h3 id="八、序列化常见面试题"><a href="#八、序列化常见面试题" class="headerlink" title="八、序列化常见面试题"></a>八、序列化常见面试题</h3><ul>
<li><p>序列化的底层是怎么实现的？</p>
</li>
<li><p>序列化时，如何让某些成员不要序列化？</p>
</li>
<li><p>在 Java 中,Serializable 和 Externalizable 有什么区别</p>
<blockquote>
<p>Externalizable继承了Serializable，给我们提供 writeExternal() 和 readExternal() 方法, 让我们可以控制 Java的序列化机制, 不依赖于Java的默认序列化。正确实现 Externalizable 接口可以显著提高应用程序的性能。</p>
</blockquote>
</li>
<li><p>serialVersionUID有什么用？</p>
</li>
<li><p>是否可以自定义序列化过程, 或者是否可以覆盖 Java 中的默认序列化过程？</p>
<blockquote>
<p>可以。我们都知道,对于序列化一个对象需调用 ObjectOutputStream.writeObject(saveThisObject), 并用 ObjectInputStream.readObject() 读取对象, 但 Java 虚拟机为你提供的还有一件事, 是定义这两个方法。如果在类中定义这两种方法, 则 JVM 将调用这两种方法, 而不是应用默认序列化机制。同时，可以声明这些方法为私有方法，以避免被继承、重写或重载。 </p>
</blockquote>
</li>
<li><p>在 Java 序列化期间,哪些变量未序列化？</p>
<blockquote>
<p>static静态变量和transient 修饰的字段是不会被序列化的。静态（static）成员变量是属于类级别的，而序列化是针对对象的。transient关键字修字段饰，可以阻止该字段被序列化到文件中</p>
</blockquote>
</li>
</ul>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xdp-gacl/p/3777987.html">Java基础学习总结——Java对象的序列化和反序列化</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000019962661">10个艰难的Java面试题与答案</a></li>
</ul>
<h2 id="Fork-join-框架"><a href="#Fork-join-框架" class="headerlink" title="Fork&#x2F;join 框架"></a>Fork&#x2F;join 框架</h2><p>Java7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。 <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/823a548cf6d64cedb1dd507c5234788f~tplv-k3u1fbpfcp-zoom-1.image" alt="img"></p>
<ul>
<li>Fork&#x2F;join计算1-1000累加值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.pdf_test.pdftest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForkJoinPoolTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">DURATION_VALUE</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ForkJoinSubTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 子任务开始计算的值</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Integer startValue;</span><br><span class="line">        <span class="comment">// 子任务结束计算的值</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Integer endValue;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">ForkJoinSubTask</span><span class="params">(Integer startValue, Integer endValue)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.startValue = startValue;</span><br><span class="line">            <span class="built_in">this</span>.endValue = endValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 小于一定值DURATION,才开始计算</span></span><br><span class="line">            <span class="keyword">if</span> (endValue - startValue &lt; DURATION_VALUE) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;执行子任务计算：开始值 = &quot;</span> + startValue + <span class="string">&quot;;结束值 = &quot;</span> + endValue);</span><br><span class="line">                <span class="type">int</span> <span class="variable">totalValue</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="built_in">this</span>.startValue; index &lt;= <span class="built_in">this</span>.endValue; index++) &#123;</span><br><span class="line">                    totalValue += index;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> totalValue;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 将任务拆分，拆分成两个任务</span></span><br><span class="line">                <span class="comment">// 0-500</span></span><br><span class="line">                <span class="type">ForkJoinSubTask</span> <span class="variable">subTask1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinSubTask</span>(startValue, (startValue + endValue) / <span class="number">2</span>);</span><br><span class="line">                subTask1.fork();</span><br><span class="line">                <span class="comment">// 501-1000</span></span><br><span class="line">                <span class="type">ForkJoinSubTask</span> <span class="variable">subTask2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinSubTask</span>((startValue + endValue) / <span class="number">2</span> + <span class="number">1</span>, endValue);</span><br><span class="line">                subTask2.fork();</span><br><span class="line">                <span class="keyword">return</span> subTask1.join() + subTask2.join();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// Fork/Join框架的线程池</span></span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        ForkJoinTask&lt;Integer&gt; taskFuture = pool.submit(<span class="keyword">new</span> <span class="title class_">ForkJoinSubTask</span>(<span class="number">1</span>, <span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> taskFuture.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;累加结果是:&quot;</span> + result);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">执行子任务计算：开始值 = <span class="number">501</span>;结束值 = <span class="number">563</span></span><br><span class="line">执行子任务计算：开始值 = <span class="number">626</span>;结束值 = <span class="number">688</span></span><br><span class="line">执行子任务计算：开始值 = <span class="number">689</span>;结束值 = <span class="number">750</span></span><br><span class="line">执行子任务计算：开始值 = <span class="number">126</span>;结束值 = <span class="number">188</span></span><br><span class="line">执行子任务计算：开始值 = <span class="number">189</span>;结束值 = <span class="number">250</span></span><br><span class="line">执行子任务计算：开始值 = <span class="number">751</span>;结束值 = <span class="number">813</span></span><br><span class="line">执行子任务计算：开始值 = <span class="number">814</span>;结束值 = <span class="number">875</span></span><br><span class="line">执行子任务计算：开始值 = <span class="number">876</span>;结束值 = <span class="number">938</span></span><br><span class="line">执行子任务计算：开始值 = <span class="number">939</span>;结束值 = <span class="number">1000</span></span><br><span class="line">执行子任务计算：开始值 = <span class="number">439</span>;结束值 = <span class="number">500</span></span><br><span class="line">执行子任务计算：开始值 = <span class="number">564</span>;结束值 = <span class="number">625</span></span><br><span class="line">执行子任务计算：开始值 = <span class="number">376</span>;结束值 = <span class="number">438</span></span><br><span class="line">执行子任务计算：开始值 = <span class="number">314</span>;结束值 = <span class="number">375</span></span><br><span class="line">执行子任务计算：开始值 = <span class="number">64</span>;结束值 = <span class="number">125</span></span><br><span class="line">执行子任务计算：开始值 = <span class="number">251</span>;结束值 = <span class="number">313</span></span><br><span class="line">执行子任务计算：开始值 = <span class="number">1</span>;结束值 = <span class="number">63</span></span><br><span class="line">累加结果是:<span class="number">500500</span></span><br></pre></td></tr></table></figure>

<p>异步执行计算：ForkJoinTask#doExec()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任务的主要执行方法。除非完成，否则调用exec()并记录状态（如果已完成），但不等待，否则完成。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 退出此方法时的状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">doExec</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> s; <span class="type">boolean</span> completed;</span><br><span class="line">        <span class="keyword">if</span> ((s = status) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 执行RecursiveTask#exec()</span></span><br><span class="line">                completed = exec();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line">                <span class="keyword">return</span> setExceptionalCompletion(rex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (completed)</span><br><span class="line">                s = setCompletion(NORMAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行RecursiveTask</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">exec</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// compute()方法在 ForkJoinSubTask进行了重写</span></span><br><span class="line">    result = compute();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Java基础流程"><a href="#Java基础流程" class="headerlink" title="Java基础流程"></a>Java基础流程</h2><h3 id="1-spring的生命周期"><a href="#1-spring的生命周期" class="headerlink" title="1.spring的生命周期"></a>1.spring的生命周期</h3><p>Spring作为当前Java最流行、最强大的轻量级容器框架，了解熟悉spring的生命周期非常有必要；</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7175534-4ee3a40841c582ec?imageMogr2/auto-orient/strip%7CimageView2/2/w/680/format/webp"></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33732195/article/details/123837864">https://blog.csdn.net/qq_33732195/article/details/123837864</a></p>
</blockquote>
<ul>
<li>首先容器启动后，对bean进行初始化</li>
<li>按照bean的定义，注入属性</li>
<li>检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给bean，如BeanNameAware等</li>
<li>以上步骤，bean对象已正确构造，通过实现BeanPostProcessor接口，可以再进行一些自定义方法处理。<br>如:postProcessBeforeInitialzation</li>
<li>BeanPostProcessor的前置处理完成后，可以实现postConstruct，afterPropertiesSet，init-method等方法，<br>增加我们自定义的逻辑</li>
<li>通过实现BeanPostProcessor接口，进行postProcessAfterInitialzation后置处理</li>
<li>接着Bean准备好被使用</li>
<li>容器关闭后，如果Bean实现了DisposableBean接口，则会回调该接口的destroy()方法</li>
<li>通过给destroy-method指定函数，就可以在bean销毁前执行指定的逻辑</li>
</ul>
<h3 id="2-TCP三次握手，四次挥手"><a href="#2-TCP三次握手，四次挥手" class="headerlink" title="2.TCP三次握手，四次挥手"></a>2.TCP三次握手，四次挥手</h3><p><img src="https://upload-images.jianshu.io/upload_images/7175534-897b99e555c1d84e?imageMogr2/auto-orient/strip%7CimageView2/2/w/499/format/webp"></p>
<h4 id="三次握手："><a href="#三次握手：" class="headerlink" title="三次握手："></a>三次握手：</h4><ul>
<li>第一次握手(SYN&#x3D;1, seq&#x3D;x)，发送完毕后，客户端进入 SYN_SEND 状态</li>
<li>第二次握手(SYN&#x3D;1, ACK&#x3D;1, seq&#x3D;y, ACKnum&#x3D;x+1)， 发送完毕后，服务器端进入 SYN_RCVD 状态。</li>
<li>第三次握手(ACK&#x3D;1，ACKnum&#x3D;y+1)，发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手，即可以开始数据传输。</li>
</ul>
<h4 id="四次挥手："><a href="#四次挥手：" class="headerlink" title="四次挥手："></a>四次挥手：</h4><ul>
<li>第一次挥手(FIN&#x3D;1，seq&#x3D;a)，发送完毕后，客户端进入 FIN_WAIT_1 状态</li>
<li>第二次挥手(ACK&#x3D;1，ACKnum&#x3D;a+1)，发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态</li>
<li>第三次挥手(FIN&#x3D;1，seq&#x3D;b)，发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。</li>
<li>第四次挥手(ACK&#x3D;1，ACKnum&#x3D;b+1)，客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。</li>
</ul>
<h3 id="3-线程池执行流程图"><a href="#3-线程池执行流程图" class="headerlink" title="3.线程池执行流程图"></a>3.线程池执行流程图</h3><p>线程池：一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务，这避免了在处理短时间任务时创建与销毁线程的代价。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7175534-b5cf53782e14ae69?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp"></p>
<h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><ul>
<li>提交一个任务，线程池里存活的核心线程数小于线程数corePoolSize时，线程池会创建一个核心线程去处理提交的任务。</li>
<li>如果线程池核心线程数已满，即线程数已经等于corePoolSize，一个新提交的任务，会被放进任务队列workQueue排队等待执行。</li>
<li>当线程池里面存活的线程数已经等于corePoolSize了,并且任务队列workQueue也满，判断线程数是否达到maximumPoolSize，即最大线程数是否已满，如果没到达，创建一个非核心线程执行提交的任务。</li>
<li>如果当前的线程数达到了maximumPoolSize，还有新的任务过来的话，直接采用拒绝策略处理。</li>
</ul>
<h4 id="JDK提供了四种拒绝策略处理类"><a href="#JDK提供了四种拒绝策略处理类" class="headerlink" title="JDK提供了四种拒绝策略处理类"></a>JDK提供了四种拒绝策略处理类</h4><ul>
<li>AbortPolicy(抛出一个异常，默认的)</li>
<li>DiscardPolicy(直接丢弃任务)</li>
<li>DiscardOldestPolicy（丢弃队列里最老的任务，将当前这个任务继续提交给线程池）</li>
<li>CallerRunsPolicy（交给线程池调用所在的线程进行处理)</li>
</ul>
<h3 id="4-JVM内存结构"><a href="#4-JVM内存结构" class="headerlink" title="4.JVM内存结构"></a>4.JVM内存结构</h3><p><img src="https://upload-images.jianshu.io/upload_images/7175534-abebcf2aa87680e3?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp"></p>
<h4 id="程序计数器（PC-寄存器）"><a href="#程序计数器（PC-寄存器）" class="headerlink" title="程序计数器（PC 寄存器）"></a>程序计数器（PC 寄存器）</h4><p>程序计数器是一块较小的内存空间，可以看作当前线程所执行的字节码的行号指示器。在虚拟机的模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、异常处理、线程恢复等基础功能都需要依赖计数器完成。</p>
<h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><ul>
<li>与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期与线程相同</li>
<li>每个方法被执行的时候都会创建一个”栈帧”,用于存储局部变量表(包括参数)、操作数栈、动态链接、方法出口等信息。每个方法被调用到执行完的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</li>
<li>局部变量表存放各种基本数据类型boolean、byte、char、short等</li>
</ul>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>与虚拟机栈基本类似，区别在于虚拟机栈为虚拟机执行的java方法服务，而本地方法栈则是为Native方法服务。</p>
<h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><ul>
<li>GC堆是java虚拟机所管理的内存中最大的一块内存区域，也是被各个线程共享的内存区域，在JVM启动时创建。</li>
<li>其大小通过-Xms(最小值)和-Xmx(最大值)参数设置，-Xms为JVM启动时申请的最小内存，-Xmx为JVM可申请的最大内存。</li>
<li>由于现在收集器都是采用分代收集算法，堆被划分为新生代和老年代。新生代由S0和S1构成，可通过-Xmn参数来指定新生代的大小。</li>
<li>所有对象实例以及数组都在堆上分配。</li>
<li>Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种符号引用，这部分内容将在类加载后放到方法区的运行时常量池中。</li>
</ul>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><ul>
<li>也称”永久代” ，它用于存储虚拟机加载的类信息、常量、静态变量、是各个线程共享的内存区域。可以通过-XX:PermSize 和 -XX:MaxPermSize 参数限制方法区的大小。</li>
<li>运行时常量池：是方法区的一部分，其中的主要内容来自于JVM对Class的加载。（<strong>JDK8后在堆中</strong>）</li>
<li>Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种符号引用，这部分内容将在类加载后放到方法区的运行时常量池中。</li>
</ul>
<h3 id="5-Java内存模型"><a href="#5-Java内存模型" class="headerlink" title="5.Java内存模型"></a>5.Java内存模型</h3><p><img src="https://upload-images.jianshu.io/upload_images/7175534-3a68c160832ae950?imageMogr2/auto-orient/strip%7CimageView2/2/w/823/format/webp"></p>
<ul>
<li><p>Java的多线程之间是通过共享内存进行通信的，在通信过程中会存在一系列如可见性、原子性、顺序性等问题，而JMM就是围绕着多线程通信以及与其相关的一系列特性而建立的模型。JMM定义了一些语法集，这些语法集映射到Java语言中就是volatile、synchronized等关键字</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/3c1691aed1a5">https://www.jianshu.com/p/3c1691aed1a5</a></p>
</blockquote>
</li>
<li><p>Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。</p>
</li>
</ul>
<h3 id="6-springMVC执行流程"><a href="#6-springMVC执行流程" class="headerlink" title="6.springMVC执行流程"></a>6.springMVC执行流程</h3><p><img src="https://upload-images.jianshu.io/upload_images/7175534-e2e338ea3a1479a4?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp"></p>
<ul>
<li>User向服务器发送request,前端控制Servelt DispatcherServlet捕获;</li>
<li>DispatcherServlet对请求URL进行解析，调用HandlerMapping获得该Handler配置的所有相关的对象，最后以HandlerExecutionChain对象的形式返回.</li>
<li>DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter.</li>
<li>提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)</li>
<li>Handler执行完成后，返回一个ModelAndView对象到DispatcherServlet </li>
<li>根据返回的ModelAndView，选择一个适合的ViewResolver</li>
<li>ViewResolver 结合Model和View，来渲染视图</li>
<li>将渲染结果返回给客户端。</li>
</ul>
<h3 id="7-JDBC执行流程"><a href="#7-JDBC执行流程" class="headerlink" title="7.JDBC执行流程"></a>7.JDBC执行流程</h3><p><img src="https://upload-images.jianshu.io/upload_images/7175534-ee60659c09771e96?imageMogr2/auto-orient/strip%7CimageView2/2/w/323/format/webp"></p>
<h4 id="JDBC执行流程："><a href="#JDBC执行流程：" class="headerlink" title="JDBC执行流程："></a>JDBC执行流程：</h4><ul>
<li>连接数据源</li>
<li>为数据库传递查询和更新指令</li>
<li>处理数据库响应并返回的结果</li>
</ul>
<h3 id="8-spring-cloud组件架构"><a href="#8-spring-cloud组件架构" class="headerlink" title="8.spring cloud组件架构"></a>8.spring cloud组件架构</h3><p>Spring Cloud是一个基于Spring Boot实现的云原生应用开发工具，它为基于JVM的云原生应用开发中涉及的配置管理、服务发现、熔断器、智能路由、微代理、控制总线、分布式会话和集群状态管理等操作提供了一种简单的开发方式。<br><img src="https://upload-images.jianshu.io/upload_images/7175534-006823b924ef3772?imageMogr2/auto-orient/strip%7CimageView2/2/w/1020/format/webp"></p>
<ul>
<li>Eureka 负责服务的注册与发现。</li>
<li>Hystrix 负责监控服务之间的调用情况，起到熔断,降级作用。</li>
<li>Spring Cloud Config 提供了统一的配置中心服务。</li>
<li>所有对外的请求和服务，我们都通过Zuul来进行转发，起到 API 网关的作用</li>
<li>最后我们使用 Sleuth+Zipkin 将所有的请求数据记录下来，方便我们进行后续分析。</li>
<li>Spring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端负载均衡的工具。<br>它是一个基于HTTP和TCP的客户端负载均衡器。</li>
<li>Feign是一个声明式的Web Service客户端，它的目的就是让Web Service调用更加简单。</li>
</ul>
<h3 id="9-dubbo-调用"><a href="#9-dubbo-调用" class="headerlink" title="9.dubbo 调用"></a>9.dubbo 调用</h3><p>Dubbo是一个分布式服务框架，致力于提供高性能和透明化的远程服务调用方案，这容易和负载均衡弄混，负载均衡是对外提供一个公共地址，请求过来时通过轮询、随机等，路由到不同server<br><img src="https://upload-images.jianshu.io/upload_images/7175534-f65917a3e25fb3a2?imageMogr2/auto-orient/strip%7CimageView2/2/w/821/format/webp"></p>
<ul>
<li>Provider: 暴露服务的服务提供方。</li>
<li>Consumer: 调用远程服务的服务消费方。</li>
<li>Registry: 服务注册与发现的注册中心。</li>
<li>Monitor: 统计服务的调用次调和调用时间的监控中心。</li>
<li>Container: 服务运行容器。</li>
</ul>
<h2 id="volatile解析"><a href="#volatile解析" class="headerlink" title="volatile解析"></a>volatile解析</h2><h3 id="1-volatile的用法"><a href="#1-volatile的用法" class="headerlink" title="1.volatile的用法"></a>1.volatile的用法</h3><p>volatile关键字是Java虚拟机提供的的<strong>最轻量级的同步机制</strong>，它作为一个修饰符出现，用来<strong>修饰变量</strong>（不包括局部变量）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileTest</span>  &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Task</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;线程t1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;开始通知线程停止&quot;</span>);</span><br><span class="line">                <span class="comment">// 修改stop变量值</span></span><br><span class="line">                task.stop = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程t2&quot;</span>);</span><br><span class="line">        t1.start();  <span class="comment">// 开启线程t1</span></span><br><span class="line">        t2.start();  <span class="comment">// 开启线程t2</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">stop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">s</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程退出&quot;</span> + (System.currentTimeMillis() - s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台输出</span></span><br><span class="line">开始通知线程停止</span><br></pre></td></tr></table></figure>


<blockquote>
<p>线程t1对t2的<strong>stop变量视而不可见</strong>，因此，它一直在死循环running中。如果给变量stop加上volatile修饰，线程t1是可以停下来的：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">stop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">开始通知线程停止</span><br><span class="line">线程退出<span class="number">1002</span></span><br></pre></td></tr></table></figure>

<h3 id="2-vlatile修饰变量的作用"><a href="#2-vlatile修饰变量的作用" class="headerlink" title="2. vlatile修饰变量的作用"></a>2. vlatile修饰变量的作用</h3><p>从以上例子，我们可以发现变量stop，加了vlatile修饰之后，线程t1对stop就可见了。其实，vlatile的作用就是：<strong>保证变量对所有线程可见性</strong>。当然，vlatile还有个作用就是，<strong>禁止指令重排</strong>，但是它<strong>不保证原子性</strong>。<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5177218cf2b491da99d43392c7bd271~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>所以当面试官问你<strong>volatile的作用或者特性</strong>，都可以这么回答：</p>
<ul>
<li>保证变量对所有线程可见性;</li>
<li>禁止指令重排序</li>
<li>不保证原子性</li>
</ul>
<h3 id="3-现代计算机的内存模型（计算机模型，MESI协议，嗅探技术，总线）"><a href="#3-现代计算机的内存模型（计算机模型，MESI协议，嗅探技术，总线）" class="headerlink" title="3. 现代计算机的内存模型（计算机模型，MESI协议，嗅探技术，总线）"></a>3. 现代计算机的内存模型（计算机模型，MESI协议，嗅探技术，总线）</h3><p>为了更好理解volatile，先回顾一下计算机的内存模型与JMM（Java内存模型）吧</p>
<h4 id="计算机模型"><a href="#计算机模型" class="headerlink" title="计算机模型"></a>计算机模型</h4><p>计算机执行程序时，指令是由CPU处理器执行的，而打交道的数据是在主内存当中的。</p>
<p>由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统加入一层读写速度接近处理器运算速度的高速缓存（Cache），以作为来作为内存与处理器之间的缓冲。</p>
<p>在多路处理器系统中，每个处理器都有自己的高速缓存，而它们共享同一主内存。<strong>计算机抽象内存模型</strong>如下：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f995fb284a7241b9b95431e79a1c37b0~tplv-k3u1fbpfcp-zoom-1.image"></p>
<ul>
<li>程序执行时，把需要用到的数据，从主内存拷贝一份到高速缓存。</li>
<li>CPU处理器计算时，从它的高速缓存中读取，把计算完的数据写入高速缓存。</li>
<li>当程序运算结束，把高速缓存的数据刷新会主内存。</li>
</ul>
<p>随着科学技术的发展，为了效率，高速缓存又衍生出一级缓存（L1），二级缓存（L2），甚至三级缓存(L3);<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05fa9ff22d7f42ae82122bfc6c233bd9~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>当多个处理器的运算任务都涉及同一块主内存区域，可能导致<strong>缓存数据不一致</strong>问题。如何解决这个问题呢？有两种方案</p>
<ul>
<li>1、通过在总线加LOCK锁的方式。</li>
<li>2、通过缓存一致性协议（Cache Coherence Protocol）</li>
</ul>
<h4 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h4><blockquote>
<p>总线（Bus）是计算机各种功能部件之间传送信息的公共通信干线，它是由导线组成的传输线束， 按照计算机所传输的信息种类，计算机的总线可以划分为数据总线、地址总线和控制总线，分别用来传输数据、数据地址和控制信号。</p>
</blockquote>
<p>CPU和其他功能部件是通过总线通信的，如果在总线加LOCK锁，那么在锁住总线期间，其他CPU是无法访问内存，这样一来，<strong>效率就比较低了</strong>。</p>
<h4 id="MESI协议"><a href="#MESI协议" class="headerlink" title="MESI协议"></a>MESI协议</h4><p>为了解决一致性问题，还可以通过<strong>缓存一致性协议</strong>。即各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI（IllinoisProtocol）、MOSI、Synapse、Firefly及DragonProtocol等。比较著名的就是Intel的MESI（Modified Exclusive Shared Or Invalid）协议，它的核心思想是：</p>
<blockquote>
<p> 当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p>
</blockquote>
<p>CPU中每个缓存行标记的4种状态（M、E、S、I）,也了解一下吧:</p>
<table>
<thead>
<tr>
<th>缓存状态</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>M，被修改（Modified)</td>
<td>该缓存行只被该CPU缓存，与主存的值不同，会在它被其他CPU读取之前写入内存，并设置为Shared</td>
</tr>
<tr>
<td>E，独享的（Exclusive)</td>
<td>该缓存行只被该CPU缓存，与主存的值相同，被其他CPU读取时置为Shared，被其他CPU写时置为Modified</td>
</tr>
<tr>
<td>S，共享的（Shared)</td>
<td>该缓存行可能被多个CPU缓存，各个缓存中的数据与主存数据相同</td>
</tr>
<tr>
<td>I，无效的（Invalid）</td>
<td>该缓存行数据是无效，需要时需重新从主存载入</td>
</tr>
</tbody></table>
<p>MESI协议是如何实现的？如何保证当前处理器的内部缓存、主内存和其他处理器的缓存数据在总线上保持一致的？</p>
<p><strong>多处理器总线嗅探</strong></p>
<h4 id="嗅探技术"><a href="#嗅探技术" class="headerlink" title="嗅探技术"></a>嗅探技术</h4><blockquote>
<p>在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己的缓存值是不是过期了，如果处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据库读到处理器缓存中。</p>
</blockquote>
<h3 id="4-Java内存模型（JMM）"><a href="#4-Java内存模型（JMM）" class="headerlink" title="4. Java内存模型（JMM）"></a>4. Java内存模型（JMM）</h3><ul>
<li>Java虚拟机规范试图定义一种Java内存模型,来<strong>屏蔽掉各种硬件和操作系统的内存访问差异</strong>，以实现让Java程序在各种平台上都能达到一致的内存访问效果。</li>
<li>Java内存模型<strong>类比</strong>于计算机内存模型。</li>
<li>为了更好的执行性能，Java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存打交道，也没有限制编译器进行调整代码顺序优化。所以Java内存模型<strong>会存在缓存一致性问题和指令重排序问题的</strong>。</li>
<li>Java内存模型规定所有的变量都是存在主内存当中（类似于计算机模型中的物理内存），每个线程都有自己的工作内存（类似于计算机模型的高速缓存）。这里的<strong>变量</strong>包括实例变量和静态变量，但是<strong>不包括局部变量</strong>，因为局部变量是线程私有的。</li>
<li>线程的工作内存保存了被该线程使用的变量的主内存副本，<strong>线程对变量的所有操作都必须在工作内存中进行</strong>，而不能直接操作操作主内存。并且每个线程不能访问其他线程的工作内存。</li>
</ul>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6ca8c98a8cc42c998dd4fe3324ded79~tplv-k3u1fbpfcp-zoom-1.image"></p>
<ul>
<li><p>举个例子，假设i的初始值是0，执行以下语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = i + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>首先，执行线程t1从主内存中读取到 <code>i=0</code> 到工作内存。然后在工作内存中，赋值 <code>i+1</code> ，工作内存就得到 <code>i=1</code>，最后把结果写回主内存。因此，如果是单线程的话，该语句执行是没问题的。但是呢，线程t2的本地工作内存还没过期，那么它读到的数据就是脏数据了。如图：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0abe171336e4f89a58722a1569d64ce~tplv-k3u1fbpfcp-zoom-1.image"></p>
</li>
</ul>
<p>Java内存模型是围绕着如何在并发过程中如何处理<strong>原子性、可见性和有序性</strong>这3个特征来建立的，我们再来一起回顾一下</p>
<h3 id="5-并发编程的3个特性（原子性、可见性、有序性）"><a href="#5-并发编程的3个特性（原子性、可见性、有序性）" class="headerlink" title="5.并发编程的3个特性（原子性、可见性、有序性）"></a>5.并发编程的3个特性（原子性、可见性、有序性）</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>原子性：指操作是不可中断的，要么执行完成，要么不执行，基本数据类型的访问和读写都是具有原子性（long和double的非原子性协定除外）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">666</span>; <span class="comment">// 语句1</span></span><br><span class="line">i = j;   <span class="comment">// 语句2</span></span><br><span class="line">i = i + <span class="number">1</span>;  <span class="comment">//语句 3</span></span><br><span class="line">i++;   <span class="comment">// 语句4</span></span><br></pre></td></tr></table></figure>
<ul>
<li>语句1操作显然是原子性的，将数值 666 赋值给 i，即线程执行这个语句时，直接将数值 666 写入到工作内存中</li>
<li>语句2操作看起来也是原子性的，但是它实际上涉及两个操作，先去读 <strong>j</strong> 的值，再把 <strong>j</strong> 的值写入工作内存，两个操作分开都是原子操作，但是合起来就不满足原子性了</li>
<li>语句3读取 <strong>i</strong> 的值，加 1，再写回主存，不是原子性操作</li>
<li>语句4 等同于语句3，也是非原子性操作</li>
</ul>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><ul>
<li>可见性：当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改</li>
<li>Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是volatile变量都是如此</li>
<li>volatile变量，保证新值能立即同步回主内存，以及每次使用前立即从主内存刷新，所以说volatile保证了多线程操作变量的可见性</li>
<li><strong>synchronized</strong>和<strong>Lock</strong>也能够保证可见性，线程在释放锁之前，会把共享变量值都刷回主存。<strong>final</strong>也可以实现可见性。</li>
</ul>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>Java虚拟机这样描述Java程序的有序性：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中，观察另一个线程，所有的操作都是无序的。</p>
<blockquote>
<p>后半句意思就是，在Java内存模型中，<strong>允许编译器和处理器对指令进行重排序</strong>，会影响到多线程并发执行的正确性；前半句意思就是 <strong><code>as-if-serial</code></strong> 的语义，即不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不会被改变。</p>
</blockquote>
<ul>
<li>比如以下程序代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">pi</span> <span class="operator">=</span> <span class="number">3.14</span>;    <span class="comment">// A</span></span><br><span class="line"><span class="type">double</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">1.0</span>;     <span class="comment">// B</span></span><br><span class="line"><span class="type">double</span> <span class="variable">area</span> <span class="operator">=</span> pi * r * r; <span class="comment">// C</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>步骤C依赖于步骤A和B，因为指令重排的存在，程序执行顺序可能是A-&gt;B-&gt;C，也可能是B-&gt;A-&gt;C，但是C不能在A或者B前面执行，这将违反as-if-serial语义<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87387195b86749ddbe1f36582a562988~tplv-k3u1fbpfcp-zoom-1.image"></p>
</li>
<li><p>假设程序先执行 <code>read</code> 方法，再执行 <code>add</code> 方法，结果一定是输出sum&#x3D;2吗？</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span> <span class="params">()</span> &#123;</span><br><span class="line">    b = <span class="number">1</span>;              <span class="comment">// 1</span></span><br><span class="line">    flag = <span class="literal">true</span>;        <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;         <span class="comment">// 3</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> b + b;   <span class="comment">// 4</span></span><br><span class="line">        System.out.println(<span class="string">&quot;bb sum is&quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果是单线程，结果应该没问题，如果是多线程，线程t1对步骤1和2进行了<strong>指令重排序</strong>呢？结果sum就不是2了，而是0，如下图所示：<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/093c6e37453c462985bed78c4d239979~tplv-k3u1fbpfcp-zoom-1.image"></li>
</ul>
<p>这是为啥呢？<strong>指令重排序</strong>了解一下，指令重排是指在程序执行过程中,<strong>为了提高性能</strong>, <strong>编译器和CPU可能会对指令进行重新排序</strong>。CPU重排序包括指令并行重排序和内存系统重排序，重排序类型和重排序执行过程如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8a24934eab24bf9b80c402039371aa2~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>实际上，可以给flag加上volatile关键字，来保证有序性。当然，也可以通过synchronized和Lock来保证有序性。synchronized和Lock保证某一时刻是只有一个线程执行同步代码，相当于是让线程顺序执行程序代码了，自然就保证了有序性。</p>
<p>实际上Java内存模型的有序性并不是仅靠volatile、synchronized和Lock来保证有序性的。这是因为Java语言中，有一个<strong>先行发生原则（happens-before）</strong>：</p>
<ul>
<li><strong>程序次序规则</strong>：在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作</li>
<li><strong>管程锁定规则</strong>：一个<code>unLock</code> 操作先行发生于后面对同一个锁的 lock 操作</li>
<li><strong>volatile变量规则</strong>：对一个变量的写操作先行发生于后面对这个变量的读操作</li>
<li><strong>线程启动规则</strong>：Thread对象的start()方法先行发生于此线程的每个动作</li>
<li><strong>线程终止规则</strong>：线程中所有的操作都先行发生于线程的终止检测，可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</li>
<li><strong>线程中断规则</strong>：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li>
<li><strong>对象终结规则</strong>：一个对象的初始化完成先行发生于它的finalize()方法的开始</li>
<li><strong>传递性</strong>：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li>
</ul>
<p>根据happens-before的八大规则，我们回到刚的例子，一起分析一下。给flag加上volatile关键字，look look它是如何保证有序性的，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span> <span class="params">()</span> &#123;</span><br><span class="line">    b = <span class="number">1</span>;              <span class="comment">// 1</span></span><br><span class="line">    flag = <span class="literal">true</span>;        <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span> <span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;         <span class="comment">// 3</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> b + b;   <span class="comment">// 4</span></span><br><span class="line">        System.out.println(<span class="string">&quot;bb sum is&quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先，flag加上volatile关键字，那就禁止了指令重排，也就是1 happens-before 2了</li>
<li>根据<strong>volatile变量规则</strong>，2 happens-before 3</li>
<li>由<strong>程序次序规则</strong>，得出 3 happens-before 4</li>
<li>最后由<strong>传递性</strong>，得出1 happens-before 4，因此妥妥的输出sum&#x3D;2</li>
</ul>
<h3 id="6-volatile底层原理"><a href="#6-volatile底层原理" class="headerlink" title="6.volatile底层原理"></a>6.volatile底层原理</h3><p>我们知道volatile的语义就是保证变量对所有线程可见性以及禁止指令重排优化。那么，它的底层是如何保证可见性和禁止指令重排的呢？</p>
<h4 id="图解volatile是如何保证可见性的"><a href="#图解volatile是如何保证可见性的" class="headerlink" title="图解volatile是如何保证可见性的"></a>图解volatile是如何保证可见性的</h4><p>假设flag变量的初始值false，现在有两条线程t1和t2要访问它，就可以简化为以下图：<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ddbe230c8dc4501a77ffbe0587b5ba6~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>如果线程t1执行以下代码语句，并且flag没有volatile修饰的话；t1刚修改完flag的值，还没来得及刷新到主内存，t2又跑过来读取了，很容易就数据flag不一致了，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc065cf75803496aa1efafd6d68ba968~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>如果flag变量是由volatile修饰的话，就不一样了，如果线程t1修改了flag值，volatile能保证修饰的flag变量后，可以<strong>立即同步回主内存</strong>。如图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27e9e195810a4a71bdeb38dd128b27e4~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>细心的朋友会发现，线程t2不还是flag旧的值吗，这不还有问题嘛？其实volatile还有一个保证，就是<strong>每次使用前立即先从主内存刷新最新的值</strong>，线程t1修改完后，线程t2的变量副本会过期了，如图：<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e67dcdfe9d9412dab89961bf92b5b53~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>显然，这里还不是底层，实际上volatile保证可见性和禁止指令重排都跟<strong>内存屏障</strong>有关，我们编译volatile相关代码看看</p>
<h4 id="DCL单例模式（volatile）-编译对比"><a href="#DCL单例模式（volatile）-编译对比" class="headerlink" title="DCL单例模式（volatile）&amp;编译对比"></a>DCL单例模式（volatile）&amp;编译对比</h4><p>DCL单例模式（Double Check Lock，双重检查锁）比较常用，它是需要volatile修饰的，所以就拿这段代码编译</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译这段代码后，观察有volatile关键字和没有volatile关键字时的instance所生成的汇编代码发现，有volatile关键字修饰时，会多出一个lock addl $0x0,(%esp)，即多出一个lock前缀指令</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x01a3de0f</span>: mov    $<span class="number">0x3375cdb0</span>,%esi   ;...beb0cd75 <span class="number">33</span>  </span><br><span class="line">                                        ;   &#123;oop(<span class="string">&#x27;Singleton&#x27;</span>)&#125;  </span><br><span class="line"><span class="number">0x01a3de14</span>: mov    %eax,<span class="number">0x150</span>(%esi)   ;..<span class="number">.89865001</span> <span class="number">0000</span>  </span><br><span class="line"><span class="number">0x01a3de1a</span>: shr    $<span class="number">0x9</span>,%esi          ;...c1ee09  </span><br><span class="line"><span class="number">0x01a3de1d</span>: movb   $<span class="number">0x0</span>,<span class="number">0x1104800</span>(%esi)  ;...c6860048 <span class="number">100100</span></span><br><span class="line"><span class="comment">// volatile关键字多了这个lock</span></span><br><span class="line"><span class="number">0x01a3de24</span>: lock addl $<span class="number">0x0</span>,(%esp)     ;...f0830424 <span class="number">00</span>  </span><br><span class="line">                                        ;*putstatic instance  </span><br><span class="line">                                        ; - Singleton::getInstance@<span class="number">24</span> </span><br></pre></td></tr></table></figure>
<p> lock指令相当于一个<strong>内存屏障</strong>，它保证以下这几点：</p>
<ul>
<li>重排序时不能把后面的指令重排序到内存屏障之前的位置</li>
<li>将本处理器的缓存写入内存</li>
<li>如果是写入动作，会导致其他处理器中对应的缓存无效</li>
</ul>
<p>显然，第2、3点是volatile保证可见性的体现，第1点是禁止指令重排列的体现。</p>
<h4 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h4><p>内存屏障四大分类：（Load 代表读取指令，Store代表写入指令）</p>
<table>
<thead>
<tr>
<th>内存屏障类型</th>
<th>抽象场景</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>LoadLoad屏障</td>
<td>Load1; LoadLoad; Load2</td>
<td>在Load2要读取的数据被访问前，保证Load1要读取的数据被读取完毕</td>
</tr>
<tr>
<td>StoreStore屏障</td>
<td>Store1; StoreStore; Store2</td>
<td>在Store2写入执行前，保证Store1的写入操作对其它处理器可见</td>
</tr>
<tr>
<td>LoadStore屏障</td>
<td>Load1; LoadStore; Store2</td>
<td>在Store2被写入前，保证Load1要读取的数据被读取完毕</td>
</tr>
<tr>
<td>StoreLoad屏障</td>
<td>Store1; StoreLoad; Load2</td>
<td>在Load2读取操作执行前，保证Store1的写入对所有处理器可见</td>
</tr>
</tbody></table>
<p>为了实现volatile的内存语义，Java内存模型采取以下的保守策略</p>
<ul>
<li>在每个volatile写操作的前面插入一个StoreStore屏障</li>
<li>在每个volatile写操作的后面插入一个StoreLoad屏障</li>
<li>在每个volatile读操作的后面插入一个LoadLoad屏障</li>
<li>在每个volatile读操作的后面插入一个LoadStore屏障</li>
</ul>
<p>内存屏障这玩意太抽象了，我们照着代码看下：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a85eff53f99f420c8139bb69b2d4f6ae~tplv-k3u1fbpfcp-zoom-1.image"></p>
<p>内存屏障保证前面的指令先执行，所以这就保证了禁止了指令重排，同时内存屏障保证缓存写入内存和其他处理器缓存失效，这也就保证了可见性</p>
<h3 id="7-volatile的典型场景"><a href="#7-volatile的典型场景" class="headerlink" title="7.volatile的典型场景"></a>7.volatile的典型场景</h3><p>通常来说，使用volatile必须具备以下2个条件：</p>
<ul>
<li>1）对变量的写操作不依赖于当前值</li>
<li>2）该变量没有包含在具有其他变量的不变式中</li>
</ul>
<p>实际上，volatile场景一般就是<strong>状态标志</strong>，以及<strong>DCL单例模式</strong>。</p>
<h4 id="7-1-状态标志"><a href="#7-1-状态标志" class="headerlink" title="7.1 状态标志"></a>7.1 状态标志</h4><p>《深入理解Java虚拟机》书中的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Map configOptions;</span><br><span class="line"><span class="type">char</span>[] configText;</span><br><span class="line"><span class="comment">// 此变量必须定义为 volatile</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">initialized</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设以下代码在线程 A 中运行</span></span><br><span class="line"><span class="comment">// 模拟读取配置信息, 当读取完成后将 initialized 设置为 true 以告知其他线程配置可用</span></span><br><span class="line">configOptions = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">configText = readConfigFile(fileName);</span><br><span class="line">processConfigOptions(configText, configOptions);</span><br><span class="line">initialized = <span class="literal">true</span>;</span><br><span class="line">      </span><br><span class="line"><span class="comment">// 假设以下代码在线程 B 中运行</span></span><br><span class="line"><span class="comment">// 等待 initialized 为 true, 代表线程 A 已经把配置信息初始化完成</span></span><br><span class="line"><span class="keyword">while</span>(!initialized) &#123;</span><br><span class="line">   sleep();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用线程 A 中初始化好的配置信息</span></span><br><span class="line">doSomethingWithConfig();</span><br></pre></td></tr></table></figure>
<h4 id="7-2-DCL单例模式"><a href="#7-2-DCL单例模式" class="headerlink" title="7.2 DCL单例模式"></a>7.2 DCL单例模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;   </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="literal">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="8-volatile相关经典面试题"><a href="#8-volatile相关经典面试题" class="headerlink" title="8. volatile相关经典面试题"></a>8. volatile相关经典面试题</h3><ul>
<li>谈谈volatile的特性</li>
<li>volatile的内存语义  </li>
<li>说说并发编程的3大特性</li>
<li>什么是内存可见性，什么是指令重排序？</li>
<li>volatile是如何解决java并发中可见性的问题</li>
<li>volatile如何防止指令重排</li>
<li>volatile可以解决原子性嘛？为什么？</li>
<li>volatile底层的实现机制</li>
<li>volatile和synchronized的区别？</li>
</ul>
<h4 id="8-1-谈谈volatile的特性"><a href="#8-1-谈谈volatile的特性" class="headerlink" title="8.1 谈谈volatile的特性"></a>8.1 谈谈volatile的特性</h4><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e624231e978455ebec33c7380ffba0d~tplv-k3u1fbpfcp-zoom-1.image"></p>
<h4 id="8-2-volatile的内存语义"><a href="#8-2-volatile的内存语义" class="headerlink" title="8.2  volatile的内存语义"></a>8.2  volatile的内存语义</h4><ul>
<li>当写一个 volatile 变量时，JMM 会把该线程对应的本地内存中的共享变量值刷新到主内存。</li>
<li>当读一个 volatile 变量时，JMM 会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</li>
</ul>
<h4 id="8-3-说说并发编程的3大特性"><a href="#8-3-说说并发编程的3大特性" class="headerlink" title="8.3 说说并发编程的3大特性"></a>8.3 说说并发编程的3大特性</h4><ul>
<li>原子性</li>
<li>可见性</li>
<li>有序性</li>
</ul>
<h4 id="8-4-什么是内存可见性，什么是指令重排序？"><a href="#8-4-什么是内存可见性，什么是指令重排序？" class="headerlink" title="8.4 什么是内存可见性，什么是指令重排序？"></a>8.4 什么是内存可见性，什么是指令重排序？</h4><ul>
<li>可见性就是指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改</li>
<li>指令重排是指JVM在编译Java代码的时候，或者CPU在执行JVM字节码的时候，对现有的指令顺序进行重新排序</li>
</ul>
<h4 id="8-5-volatile是如何解决java并发中可见性的问题"><a href="#8-5-volatile是如何解决java并发中可见性的问题" class="headerlink" title="8.5 volatile是如何解决java并发中可见性的问题"></a>8.5 volatile是如何解决java并发中可见性的问题</h4><p>底层是通过内存屏障实现的，volatile能保证修饰的变量后，可以立即同步回主内存，每次使用前立即先从主内存刷新最新的值</p>
<h4 id="8-6-volatile如何防止指令重排"><a href="#8-6-volatile如何防止指令重排" class="headerlink" title="8.6 volatile如何防止指令重排"></a>8.6 volatile如何防止指令重排</h4><p>也是内存屏障，跟面试官讲下Java内存的保守策略：</p>
<ul>
<li>在每个volatile写操作的前面插入一个StoreStore屏障</li>
<li>在每个volatile写操作的后面插入一个StoreLoad屏障</li>
<li>在每个volatile读操作的后面插入一个LoadLoad屏障</li>
<li>在每个volatile读操作的后面插入一个LoadStore屏障</li>
</ul>
<p>再讲下volatile的语义，重排序时不能把内存屏障后面的指令重排序到内存屏障之前的位置</p>
<h4 id="8-7-volatile可以解决原子性嘛？为什么？"><a href="#8-7-volatile可以解决原子性嘛？为什么？" class="headerlink" title="8.7 volatile可以解决原子性嘛？为什么？"></a>8.7 volatile可以解决原子性嘛？为什么？</h4><p>不可以，可以直接举i++那个例子，原子性需要synchronzied或者lock保证</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">race</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">        race++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">100</span>; j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待所有累加线程结束</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">1</span>)</span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line">        System.out.println(test.race);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-8-volatile底层的实现机制"><a href="#8-8-volatile底层的实现机制" class="headerlink" title="8.8 volatile底层的实现机制"></a>8.8 volatile底层的实现机制</h4><p>可以看本文的第六小节，volatile底层原理哈，主要你要跟面试官讲述，volatile如何保证可见性和禁止指令重排，需要讲到内存屏障</p>
<h4 id="8-9-volatile和synchronized的区别？"><a href="#8-9-volatile和synchronized的区别？" class="headerlink" title="8.9 volatile和synchronized的区别？"></a>8.9 volatile和synchronized的区别？</h4><ul>
<li>volatile修饰的是变量，synchronized一般修饰代码块或者方法</li>
<li>volatile保证可见性、禁止指令重排，但是不保证原子性；synchronized可以保证原子性</li>
<li>volatile不会造成线程阻塞，synchronized可能会造成线程的阻塞，所以后面才有锁优化那么多故事~</li>
<li>哈哈，你还有补充嘛~</li>
</ul>
<blockquote>
<p> <a target="_blank" rel="noopener" href="https://juejin.im/post/6844903918653145102">Synchronized解析——如果你愿意一层一层剥开我的心</a></p>
</blockquote>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li>&lt;&lt;深入理解Java虚拟机&gt;&gt;</li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dolphin0520/p/3920373.html">Java并发编程：volatile关键字解析</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903520760496141">面试官最爱的volatile关键字</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/6844904149536997384"> 面试官没想到一个Volatile，我都能跟他扯半小时</a></li>
<li><a target="_blank" rel="noopener" href="http://47.103.216.138/archives/2550">再有人问你Java内存模型是什么，就把这篇文章发给他。</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/z00377750/p/9180644.html">【并发编程】MESI–CPU缓存一致性协议</a></li>
<li><a target="_blank" rel="noopener" href="https://www.sohu.com/a/211287207_684445">漫画：volatile对指令重排的影响 </a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/765e3abbe89a">volatile三大特性详解</a></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JAVA/" rel="tag"># JAVA</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2024/07/24/Typora%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/" rel="next" title="Typora使用教程">
      Typora使用教程 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#if-else%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96"><span class="nav-number">1.</span> <span class="nav-text">if-else代码优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88%E4%B8%80%EF%BC%9A%E6%8F%90%E5%89%8Dreturn%EF%BC%8C%E5%8E%BB%E9%99%A4%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84else"><span class="nav-number">1.1.</span> <span class="nav-text">优化方案一：提前return，去除不必要的else</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88%E4%BA%8C%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.2.</span> <span class="nav-text">优化方案二：使用条件三目运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88%E4%B8%89%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE"><span class="nav-number">1.3.</span> <span class="nav-text">优化方案三：使用枚举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88%E5%9B%9B%EF%BC%9A%E5%90%88%E5%B9%B6%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.4.</span> <span class="nav-text">优化方案四：合并条件表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88%E4%BA%94%EF%BC%9A%E4%BD%BF%E7%94%A8-Optional"><span class="nav-number">1.5.</span> <span class="nav-text">优化方案五：使用 Optional</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88%E5%85%AD%EF%BC%9A%E8%A1%A8%E9%A9%B1%E5%8A%A8%E6%B3%95"><span class="nav-number">1.6.</span> <span class="nav-text">优化方案六：表驱动法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88%E4%B8%83%EF%BC%9A%E4%BC%98%E5%8C%96%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%EF%BC%8C%E8%AE%A9%E6%AD%A3%E5%B8%B8%E6%B5%81%E7%A8%8B%E8%B5%B0%E4%B8%BB%E5%B9%B2"><span class="nav-number">1.7.</span> <span class="nav-text">优化方案七：优化逻辑结构，让正常流程走主干</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88%E5%85%AB%EF%BC%9A%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%B6%88%E9%99%A4if-else"><span class="nav-number">1.8.</span> <span class="nav-text">优化方案八：策略模式+工厂方法消除if else</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E5%8D%81%E4%B8%AA%E5%BB%BA%E8%AE%AE"><span class="nav-number">2.</span> <span class="nav-text">Java异常处理的十个建议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E4%BD%BF%E7%94%A8log%E6%89%93%E5%8D%B0%EF%BC%8C%E5%B0%BD%E9%87%8F%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8e-printStackTrace"><span class="nav-number">2.1.</span> <span class="nav-text">一、使用log打印，尽量不要使用e.printStackTrace()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81catch%E4%BA%86%E5%BC%82%E5%B8%B8%EF%BC%8C%E4%BD%86%E6%98%AF%E6%B2%A1%E6%9C%89%E6%89%93%E5%8D%B0%E5%87%BA%E5%85%B7%E4%BD%93%E7%9A%84exception%EF%BC%8C%E6%97%A0%E6%B3%95%E6%9B%B4%E5%A5%BD%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98"><span class="nav-number">2.2.</span> <span class="nav-text">二、catch了异常，但是没有打印出具体的exception，无法更好定位问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E4%B8%8D%E8%A6%81%E7%94%A8%E4%B8%80%E4%B8%AAException%E6%8D%95%E6%8D%89%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="nav-number">2.3.</span> <span class="nav-text">三、不要用一个Exception捕捉所有可能的异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E4%BD%BF%E7%94%A8finally%E6%88%96%E7%9B%B4%E6%8E%A5try-with-resource%E5%85%B3%E9%97%AD%E6%B5%81%E8%B5%84%E6%BA%90"><span class="nav-number">2.4.</span> <span class="nav-text">四、使用finally或直接try-with-resource关闭流资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8%E4%B8%8E%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E5%BF%85%E9%A1%BB%E6%98%AF%E5%AE%8C%E5%85%A8%E5%8C%B9%E9%85%8D%EF%BC%8C%E6%88%96%E8%80%85%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8%E6%98%AF%E6%8A%9B%E5%BC%82%E5%B8%B8%E7%9A%84%E7%88%B6%E7%B1%BB"><span class="nav-number">2.5.</span> <span class="nav-text">五、捕获异常与抛出异常必须是完全匹配，或者捕获异常是抛异常的父类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E6%B3%A8%E6%84%8F%E5%BC%82%E5%B8%B8%E5%AF%B9%E4%BB%A3%E7%A0%81%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E7%9A%84%E4%BE%B5%E6%9F%93%EF%BC%88%E6%97%A9%E5%8F%91%E7%8E%B0%E6%97%A9%E5%A4%84%E7%90%86%EF%BC%89"><span class="nav-number">2.6.</span> <span class="nav-text">六、注意异常对代码层次结构的侵染（早发现早处理）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B0%81%E8%A3%85%E5%BC%82%E5%B8%B8%EF%BC%8C%E4%B8%8D%E8%A6%81%E4%B8%A2%E5%BC%83%E5%8E%9F%E5%A7%8B%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BF%A1%E6%81%AFThrowable-cause"><span class="nav-number">2.7.</span> <span class="nav-text">七、自定义封装异常，不要丢弃原始异常的信息Throwable cause</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AB%E3%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8RuntimeException-%EF%BC%8C%E4%B8%8D%E5%BA%94%E8%AF%A5%E9%80%9A%E8%BF%87catch-%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9D%A5%E5%A4%84%E7%90%86%EF%BC%8C%E8%80%8C%E6%98%AF%E5%85%88%E9%A2%84%E6%A3%80%E6%9F%A5%EF%BC%8C%E6%AF%94%E5%A6%82%EF%BC%9ANullPointerException%E5%A4%84%E7%90%86"><span class="nav-number">2.8.</span> <span class="nav-text">八、运行时异常RuntimeException ，不应该通过catch 的方式来处理，而是先预检查，比如：NullPointerException处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%9D%E3%80%81%E6%B3%A8%E6%84%8F%E5%BC%82%E5%B8%B8%E5%8C%B9%E9%85%8D%E7%9A%84%E9%A1%BA%E5%BA%8F%EF%BC%8C%E4%BC%98%E5%85%88%E6%8D%95%E8%8E%B7%E5%85%B7%E4%BD%93%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="nav-number">2.9.</span> <span class="nav-text">九、注意异常匹配的顺序，优先捕获具体的异常</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">3.</span> <span class="nav-text">Java序列化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFJava%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">3.1.</span> <span class="nav-text">一、什么是Java序列化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F"><span class="nav-number">3.2.</span> <span class="nav-text">二、为什么需要序列化？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E7%94%A8%E9%80%94"><span class="nav-number">3.3.</span> <span class="nav-text">三、序列化用途</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E3%80%81Java%E5%BA%8F%E5%88%97%E5%8C%96%E5%B8%B8%E7%94%A8API"><span class="nav-number">3.4.</span> <span class="nav-text">四、Java序列化常用API</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Serializable-%E6%8E%A5%E5%8F%A3"><span class="nav-number">3.4.1.</span> <span class="nav-text">Serializable 接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Externalizable-%E6%8E%A5%E5%8F%A3"><span class="nav-number">3.4.2.</span> <span class="nav-text">Externalizable 接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#java-io-ObjectOutputStream%E7%B1%BB"><span class="nav-number">3.4.3.</span> <span class="nav-text">java.io.ObjectOutputStream类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#java-io-ObjectInputStream"><span class="nav-number">3.4.4.</span> <span class="nav-text">java.io.ObjectInputStream</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">3.5.</span> <span class="nav-text">五、序列化的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AAStudent%E7%B1%BB%EF%BC%8C%E5%AE%9E%E7%8E%B0Serializable"><span class="nav-number">3.5.1.</span> <span class="nav-text">声明一个Student类，实现Serializable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8ObjectOutputStream%E7%B1%BB%E7%9A%84writeObject%E6%96%B9%E6%B3%95%EF%BC%8C%E5%AF%B9Student%E5%AF%B9%E8%B1%A1%E5%AE%9E%E7%8E%B0%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">3.5.2.</span> <span class="nav-text">使用ObjectOutputStream类的writeObject方法，对Student对象实现序列化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8ObjectInputStream%E7%B1%BB%E7%9A%84readObject%E6%96%B9%E6%B3%95%EF%BC%8C%E5%AE%9E%E7%8E%B0%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%8C%E9%87%8D%E6%96%B0%E7%94%9F%E6%88%90Student%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.5.3.</span> <span class="nav-text">使用ObjectInputStream类的readObject方法，实现反序列化，重新生成Student对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E5%BA%95%E5%B1%82"><span class="nav-number">3.6.</span> <span class="nav-text">六、序列化底层</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Serializable%E5%BA%95%E5%B1%82"><span class="nav-number">3.6.1.</span> <span class="nav-text">Serializable底层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#writeObject%EF%BC%88Object%EF%BC%89"><span class="nav-number">3.6.2.</span> <span class="nav-text">writeObject（Object）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%83%E3%80%81%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="nav-number">3.7.</span> <span class="nav-text">七、日常开发序列化的一些注意点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#static%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8Ctransient-%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%AD%97%E6%AE%B5%E4%B8%8D%E4%BC%9A%E8%A2%AB%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">3.7.1.</span> <span class="nav-text">static静态变量和transient 修饰的字段不会被序列化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#serialVersionUID%E9%97%AE%E9%A2%98"><span class="nav-number">3.7.2.</span> <span class="nav-text">serialVersionUID问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#serialVersionUID%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="nav-number">3.7.2.1.</span> <span class="nav-text">serialVersionUID有什么用？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E6%9F%90%E4%B8%AA%E5%BA%8F%E5%88%97%E5%8C%96%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E6%98%AF%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%88%99%E8%AF%A5%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%B1%BB%E5%BF%85%E9%A1%BB%E5%AE%9E%E7%8E%B0%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">3.7.3.</span> <span class="nav-text">如果某个序列化类的成员变量是对象类型，则该对象类型的类必须实现序列化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%90%E7%B1%BB%E5%AE%9E%E7%8E%B0%E4%BA%86Serializable%EF%BC%8C%E7%88%B6%E7%B1%BB%E6%B2%A1%E6%9C%89%E5%AE%9E%E7%8E%B0Serializable%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%AF%9D%EF%BC%8C%E7%88%B6%E7%B1%BB%E4%B8%8D%E4%BC%9A%E8%A2%AB%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">3.7.4.</span> <span class="nav-text">子类实现了Serializable，父类没有实现Serializable接口的话，父类不会被序列化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AB%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">3.8.</span> <span class="nav-text">八、序列化常见面试题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">3.9.</span> <span class="nav-text">参考资料</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Fork-join-%E6%A1%86%E6%9E%B6"><span class="nav-number">4.</span> <span class="nav-text">Fork&#x2F;join 框架</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%9F%BA%E7%A1%80%E6%B5%81%E7%A8%8B"><span class="nav-number">5.</span> <span class="nav-text">Java基础流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-spring%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">5.1.</span> <span class="nav-text">1.spring的生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">5.2.</span> <span class="nav-text">2.TCP三次握手，四次挥手</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9A"><span class="nav-number">5.2.1.</span> <span class="nav-text">三次握手：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%9A"><span class="nav-number">5.2.2.</span> <span class="nav-text">四次挥手：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="nav-number">5.3.</span> <span class="nav-text">3.线程池执行流程图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">5.3.1.</span> <span class="nav-text">执行流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK%E6%8F%90%E4%BE%9B%E4%BA%86%E5%9B%9B%E7%A7%8D%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%E5%A4%84%E7%90%86%E7%B1%BB"><span class="nav-number">5.3.2.</span> <span class="nav-text">JDK提供了四种拒绝策略处理类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="nav-number">5.4.</span> <span class="nav-text">4.JVM内存结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88PC-%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%89"><span class="nav-number">5.4.1.</span> <span class="nav-text">程序计数器（PC 寄存器）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="nav-number">5.4.2.</span> <span class="nav-text">Java虚拟机栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="nav-number">5.4.3.</span> <span class="nav-text">本地方法栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E5%A0%86"><span class="nav-number">5.4.4.</span> <span class="nav-text">Java堆</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="nav-number">5.4.5.</span> <span class="nav-text">方法区</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.5.</span> <span class="nav-text">5.Java内存模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-springMVC%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">5.6.</span> <span class="nav-text">6.springMVC执行流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-JDBC%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">5.7.</span> <span class="nav-text">7.JDBC执行流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JDBC%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="nav-number">5.7.1.</span> <span class="nav-text">JDBC执行流程：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-spring-cloud%E7%BB%84%E4%BB%B6%E6%9E%B6%E6%9E%84"><span class="nav-number">5.8.</span> <span class="nav-text">8.spring cloud组件架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-dubbo-%E8%B0%83%E7%94%A8"><span class="nav-number">5.9.</span> <span class="nav-text">9.dubbo 调用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile%E8%A7%A3%E6%9E%90"><span class="nav-number">6.</span> <span class="nav-text">volatile解析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-volatile%E7%9A%84%E7%94%A8%E6%B3%95"><span class="nav-number">6.1.</span> <span class="nav-text">1.volatile的用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-vlatile%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">6.2.</span> <span class="nav-text">2. vlatile修饰变量的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A8%A1%E5%9E%8B%EF%BC%8CMESI%E5%8D%8F%E8%AE%AE%EF%BC%8C%E5%97%85%E6%8E%A2%E6%8A%80%E6%9C%AF%EF%BC%8C%E6%80%BB%E7%BA%BF%EF%BC%89"><span class="nav-number">6.3.</span> <span class="nav-text">3. 现代计算机的内存模型（计算机模型，MESI协议，嗅探技术，总线）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A8%A1%E5%9E%8B"><span class="nav-number">6.3.1.</span> <span class="nav-text">计算机模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BA%BF"><span class="nav-number">6.3.2.</span> <span class="nav-text">总线</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MESI%E5%8D%8F%E8%AE%AE"><span class="nav-number">6.3.3.</span> <span class="nav-text">MESI协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%97%85%E6%8E%A2%E6%8A%80%E6%9C%AF"><span class="nav-number">6.3.4.</span> <span class="nav-text">嗅探技术</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88JMM%EF%BC%89"><span class="nav-number">6.4.</span> <span class="nav-text">4. Java内存模型（JMM）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%843%E4%B8%AA%E7%89%B9%E6%80%A7%EF%BC%88%E5%8E%9F%E5%AD%90%E6%80%A7%E3%80%81%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%81%E6%9C%89%E5%BA%8F%E6%80%A7%EF%BC%89"><span class="nav-number">6.5.</span> <span class="nav-text">5.并发编程的3个特性（原子性、可见性、有序性）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="nav-number">6.5.1.</span> <span class="nav-text">原子性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-number">6.5.2.</span> <span class="nav-text">可见性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="nav-number">6.5.3.</span> <span class="nav-text">有序性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-volatile%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-number">6.6.</span> <span class="nav-text">6.volatile底层原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE%E8%A7%A3volatile%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7%E7%9A%84"><span class="nav-number">6.6.1.</span> <span class="nav-text">图解volatile是如何保证可见性的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DCL%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88volatile%EF%BC%89-%E7%BC%96%E8%AF%91%E5%AF%B9%E6%AF%94"><span class="nav-number">6.6.2.</span> <span class="nav-text">DCL单例模式（volatile）&amp;编译对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C"><span class="nav-number">6.6.3.</span> <span class="nav-text">内存屏障</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-volatile%E7%9A%84%E5%85%B8%E5%9E%8B%E5%9C%BA%E6%99%AF"><span class="nav-number">6.7.</span> <span class="nav-text">7.volatile的典型场景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-%E7%8A%B6%E6%80%81%E6%A0%87%E5%BF%97"><span class="nav-number">6.7.1.</span> <span class="nav-text">7.1 状态标志</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-DCL%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.7.2.</span> <span class="nav-text">7.2 DCL单例模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-volatile%E7%9B%B8%E5%85%B3%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">6.8.</span> <span class="nav-text">8. volatile相关经典面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-1-%E8%B0%88%E8%B0%88volatile%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">6.8.1.</span> <span class="nav-text">8.1 谈谈volatile的特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-volatile%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89"><span class="nav-number">6.8.2.</span> <span class="nav-text">8.2  volatile的内存语义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-3-%E8%AF%B4%E8%AF%B4%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%843%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="nav-number">6.8.3.</span> <span class="nav-text">8.3 说说并发编程的3大特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-4-%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%BA%8F%EF%BC%9F"><span class="nav-number">6.8.4.</span> <span class="nav-text">8.4 什么是内存可见性，什么是指令重排序？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-5-volatile%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3java%E5%B9%B6%E5%8F%91%E4%B8%AD%E5%8F%AF%E8%A7%81%E6%80%A7%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">6.8.5.</span> <span class="nav-text">8.5 volatile是如何解决java并发中可见性的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-6-volatile%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92"><span class="nav-number">6.8.6.</span> <span class="nav-text">8.6 volatile如何防止指令重排</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-7-volatile%E5%8F%AF%E4%BB%A5%E8%A7%A3%E5%86%B3%E5%8E%9F%E5%AD%90%E6%80%A7%E5%98%9B%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">6.8.7.</span> <span class="nav-text">8.7 volatile可以解决原子性嘛？为什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-8-volatile%E5%BA%95%E5%B1%82%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="nav-number">6.8.8.</span> <span class="nav-text">8.8 volatile底层的实现机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-9-volatile%E5%92%8Csynchronized%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">6.8.9.</span> <span class="nav-text">8.9 volatile和synchronized的区别？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">6.9.</span> <span class="nav-text">参考</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Dr July</p>
  <div class="site-description" itemprop="description">一个练习两年半的实习生</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/DrJuly2333" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;DrJuly2333" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/HTTTS2022@gmail.com" title="E-Mail → HTTTS2022@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; Wed Jul 24 2024 08:00:00 GMT+0800 (中国标准时间) – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dr July</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


  <script async src="/js/cursor/love.min.js"></script>




</body>
</html>
