<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>鸟哥的Linux实战阅读笔记 | DrJuly</title><meta name="author" content="DrJuly2333"><meta name="copyright" content="DrJuly2333"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[TOC]  一、计算机概论计算机：接受输入指令与数据，经由中央处理器的数学与逻辑单元运算处理后，以产生或储存成有用的信息。 计算机由五个主要单元所组成的，包括输入单元、输出单元、CPU 内部的控制单元、算数逻辑单元与内存五大部分。 重点在于中央处理器（Central Processing Unit,  CPU），CPU 为一个具有特定功能的芯片，里头含有微指令集。 CPU 的工作主要在于管理与运">
<meta property="og:type" content="article">
<meta property="og:title" content="鸟哥的Linux实战阅读笔记">
<meta property="og:url" content="http://example.com/2024/08/10/%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="DrJuly">
<meta property="og:description" content="[TOC]  一、计算机概论计算机：接受输入指令与数据，经由中央处理器的数学与逻辑单元运算处理后，以产生或储存成有用的信息。 计算机由五个主要单元所组成的，包括输入单元、输出单元、CPU 内部的控制单元、算数逻辑单元与内存五大部分。 重点在于中央处理器（Central Processing Unit,  CPU），CPU 为一个具有特定功能的芯片，里头含有微指令集。 CPU 的工作主要在于管理与运">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/avatar.png">
<meta property="article:published_time" content="2024-08-10T21:46:35.000Z">
<meta property="article:modified_time" content="2024-08-26T01:06:53.000Z">
<meta property="article:author" content="DrJuly2333">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/avatar.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/08/10/%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?95d98ba73784092d75263482b3e4ecc4";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '鸟哥的Linux实战阅读笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-25 21:06:53'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="DrJuly"><span class="site-name">DrJuly</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">鸟哥的Linux实战阅读笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-08-10T21:46:35.000Z" title="Created 2024-08-10 17:46:35">2024-08-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-08-26T01:06:53.000Z" title="Updated 2024-08-25 21:06:53">2024-08-25</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">34.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>127mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="鸟哥的Linux实战阅读笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>[TOC] </p>
<h1 id="一、计算机概论"><a href="#一、计算机概论" class="headerlink" title="一、计算机概论"></a>一、计算机概论</h1><p>计算机：接受输入指令与数据，经由中央处理器的数学与逻辑单元运算处理后，以产生或储存成有用的信息。</p>
<p>计算机由五个主要单元所组成的，包括<strong>输入单元、输出单元、CPU 内部的控制单元、算数逻辑单元与内存</strong>五大部分。</p>
<p>重点在于中央处理器（<code>Central Processing Unit</code>,  CPU），CPU 为一个具有特定功能的芯片，里头含有<strong>微指令集</strong>。</p>
<p>CPU 的工作主要在于<strong>管理与运算</strong>，因此在CPU 内又可分为两个主要的单元：算数逻辑单元与控制单元。</p>
<ul>
<li>算数逻辑单元：主要负责程序运算与逻辑判断</li>
<li>控制单元：协调各周边元件与各单元间的工作。</li>
</ul>
<p>CPU 读取的数据都是从内存来的，内存内的数据则是从输入单元所传输进来！而 CPU 处理完毕的数据也必须要先写回内存中，最后数据才从内存传输到输出单元。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph LR<br>	输入输出设备 --输入--&gt; 内存<br>	内存 --读取--&gt; CPU<br>	CPU --传输--&gt; 内存<br>	内存 --输出--&gt; 输入输出设备<br></code></pre></td></tr></table></figure>



<span id="more"></span>

<h2 id="CPU-架构"><a href="#CPU-架构" class="headerlink" title="CPU 架构"></a>CPU 架构</h2><p>主要有两种 CPU 架构，分别是：精简指令集（<code>RISC</code>）与复杂指令集（<code>CISC</code>）系统。</p>
<ul>
<li><p>精简指令集（<code>Reduced Instruction Set Computer,</code>  <code>RISC</code>）：这种 CPU 的微指令集较为精简，每个指令的执行时间都很短，完成的动作也很单纯，指令的执行性能较佳；但是若要做复杂的事情，就要由多个指令来完成。.</p>
<blockquote>
<p>常见的 RISC微指令集 CPU :</p>
<p>甲骨文（Oracle）公司的 SPARC 系列，常用于学术领域的大型工作站中和银行金融体系的主要服务器</p>
<p>IBM 公司的 <code>PowerArchitecture</code> （包括 <code>PowerPC</code>）系列，<code>PS3</code>的Cell处理器等</p>
<p>安谋公司（ARM Holdings）的 ARM CPU 系列，手机、<code>PDA</code>、导航系统、网络设备（交换器、路由器等）等</p>
</blockquote>
</li>
<li><p>复杂指令集（<code>Complex Instruction Set Computer</code>, <code>CISC</code>）：与<code>RISC</code>不同的，<code>CISC</code>在微指令集的每个小指令可以执行一些较低阶的硬件操作，指令数目多而且复杂，每条指令的长度并不相同。因为指令执行较为复杂所以每条指令花费的时间较长，但每条个别指令可以处理的工作较为丰富。</p>
<p>常见的<code>CISC</code>微指令集CPU主要有<code>AMD</code>、<code>Intel</code>、<code>VIA</code>等<code>x86</code>架构的CPU。</p>
<blockquote>
<p>为啥叫<code>x86</code>？</p>
<p>因为最早的那颗Intel发展出来的CPU代号称为<strong>8086</strong>，后来依此架构又开发出80286, 80386…，因此这种架构的CPU就被称为<code>x86</code>架构了。在2003年以前由Intel所开发的<code>x86</code>架构CPU由8位升级到16、32位，后来<code>AMD</code>依此架构修改新一代的CPU为64位，为了区别两者的差异，因此64位的CPU又被统称为<code>x86_64</code>的架构</p>
</blockquote>
<blockquote>
<p>所谓的位指的是<strong>CPU一次数据读取的最大量</strong>！64位CPU代表CPU一次可以读写<code>64bits</code>的数据，32位CPU一次只能读取<code>32bits</code>的数据。</p>
<p>因为CPU读取数据量有限制，因此能够从内存中读写的数据也就有所限制。所以，一般32位的CPU所能读写的最大数据量，大概就是<code>4GB</code>左右</p>
</blockquote>
</li>
</ul>
<h3 id="CPU的工作频率"><a href="#CPU的工作频率" class="headerlink" title="CPU的工作频率"></a>CPU的工作频率</h3><p>每秒钟可以执行的时钟周期数，而不是直接表示可以进行多少次工作。频率越高表示CPU单位时间内可以作更多的事情。 </p>
<p>例如：<code>i7-4790</code> CPU频率为<code>3.6GHz</code>，表示每秒钟可以进行3.6 × 10^9 次时钟周期，如果每个时钟周期可以完成一项基本操作，那么理论上每秒钟可以完成3.6 × 10^9 次基本操作.</p>
<h3 id="外频与倍频"><a href="#外频与倍频" class="headerlink" title="外频与倍频"></a>外频与倍频</h3><p>早期的 CPU 架构主要通过<strong>北桥</strong>来链接系统最重要的 <code>CPU、内存与显卡设备</code>。因为所有的设备都得通过北桥来链接，每个设备的工作频率应该要相同，于是就有所谓的前端总线（<code>FSB</code>）。由于 CPU 的运算速度比其他的设备都快，又为了要满足<code>FSB</code> 的频率，因此厂商就在 CPU 内部再进行加速，于是就有所谓的外频与倍频了。</p>
<ul>
<li>外频：CPU与外部元件进行数据传输时的速度</li>
<li>倍频：CPU 内部用来加速工作性能的一个倍数，两者相乘才是CPU的频率速度</li>
</ul>
<p>例如 <code>Intel Core 2 E8400</code> 的内频为 <code>3.0GHz</code>，而外频是<code>333MHz</code>，因此倍频就是9倍！（<code>3.0G = 333M x 9</code>）</p>
<blockquote>
<p>超频的原理？</p>
<p>以前的超频：将CPU的倍频或者是外频通过主板的设置功能更改成较高频率的一种方式。但因为CPU的倍频通常在出厂时已经被锁定而无法修改，因此较常被超频的为<strong>外频</strong>。</p>
<p>目前的<strong>CPU自动超频</strong></p>
<p>CPU自动超频通常是指通过处理器内部的动态频率调整技术，如<code>Intel的Turbo Boost</code>或<code>AMD的Precision Boost</code>，来自动提升处理器的工作频率，以在需要时提供更高的性能</p>
<p>手动超频：</p>
<p>超频需要主板和BIOS的支持。主板的设计和电源供应必须足够强大，同时BIOS提供了设置频率、电压等参数的界面和选项</p>
<p>1、时钟发生器调整</p>
<p>改变时钟发生器的输出频率，使CPU执行的时钟周期增加，从而提高CPU的工作频率</p>
<p>2、电压调整</p>
<p>增加CPU的电压，以确保处理器在更高频率下能够稳定运行</p>
</blockquote>
<p>但如此一来所有的数据都被北桥卡死了，北桥又不可能比 CPU 更快，因此这家伙常常是系统性能的瓶颈。为了解决这个问题，新的 CPU 设计中，已经将<strong>内存控制器</strong>整合到 CPU 内部，而链接 <strong>CPU 与内存、显卡</strong>的控制器的设计，在<code>Intel</code>部份使用 <code>QPI （Quick PathInterconnect）</code>与 <code>DMI</code> 技术，而 <code>AMD</code> 部份则使用 <code>Hyper Transport</code> 了，这些技术都可以让CPU 直接与内存、显卡等设备分别进行沟通，而不需要通过外部的链接芯片了。</p>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>个人电脑的内存主要元件为动态随机存取内存（Dynamic Random Access Memory, DRAM），随机存取内存只有在<strong>通电</strong>时才能记录与使用，断电后数据就消失了。因此也称这种RAM为挥发性内存。</p>
<h3 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h3><p><code>DRAM</code>根据技术的更新分好几代，使用上较广泛的是<code>SDRAM</code>与<code>DDR SDRAM</code>两种。这两种内存的差别除了<strong>脚位</strong>与<strong>工作电压</strong>上的不同之外，<code>DDR</code>是双倍数据传送速度（Double Data Rate），可以在一次工作周期中进行两次数据的传送，所以传输频率方面比<code>SDRAM</code>还要好。<code>DDR2</code> 的频率倍数是<code>DDR</code>的 4 倍，而<code>DDR3</code> 则是 8 倍。</p>
<p><code>DDR3/DDR3L</code>：新的制程中降低了内存的操作电压，<code>DDR3</code> 标准电压为 <code>1.5V</code>，但 <code>DDR3L</code> 则仅须 <code>1.35V</code> ，需要主板支持。</p>
<h4 id="内存容量"><a href="#内存容量" class="headerlink" title="内存容量"></a>内存容量</h4><p>内存容量不够大的话将会导致某些<strong>大容量数据</strong>无法被完整的载入，此时已存在内存当中但暂时没有被使用到的数据必须要先被<strong>释放</strong>，使得可用内存容量大于该数据，那份新数据才能够被载入。所以，通常越大的内存代表越快速的系统，这是因为系统不用常常释放一些内存内部的数据。</p>
<h4 id="多通道"><a href="#多通道" class="headerlink" title="多通道"></a>多通道</h4><p>由于所有的数据都必须要存放在内存，所以内存的数据宽度当然是越大越好。但传统的总线宽度一般大约仅达64位，为了加大这个宽度，芯片组厂商将两个内存汇整在一起，如果一支内存可达64位，两支内存就可以达到128位了，这就是双通道的设计理念。启用双通道的功能必须要安插两支（或四支）内存，最好连内存型号都一样，因为数据是同步写入&#x2F;读出这一对内存。</p>
<h4 id="内存信道"><a href="#内存信道" class="headerlink" title="内存信道"></a>内存信道</h4><p>计算机系统中用于传输数据和指令的路径或通道，其作用类似于数据在计算机内存和其他硬件组件（如CPU、显卡等）之间的桥梁。</p>
<h5 id="作用和功能"><a href="#作用和功能" class="headerlink" title="作用和功能"></a>作用和功能</h5><ul>
<li><p><strong>数据传输</strong>：内存信道负责将数据从计算机的主存储器（RAM）传输到其他硬件组件，如<code>CPU</code>、<code>GPU</code>等，或者反之。</p>
</li>
<li><p><strong>并发性</strong>：现代计算机系统通常具有多个内存信道，允许同时进行多条数据传输，以提高整体系统的带宽和效率。</p>
</li>
<li><p><strong>速度匹配</strong>：内存信道的设计要与处理器、系统总线和其他硬件组件的速度匹配，以确保高效的数据交换和处理。</p>
</li>
</ul>
<h3 id="CPU内部高速缓存"><a href="#CPU内部高速缓存" class="headerlink" title="CPU内部高速缓存"></a>CPU内部高速缓存</h3><p>CPU内部高速缓存（CPU Cache）是位于CPU内部的一种高速存储器，用于临时存放<strong>频繁使用</strong>的数据和指令，减少从主存（<code>RAM</code>）读取数据的时间，以提高处理器访问数据的速度和效率。</p>
<p>静态随机存取内存（<code>StaticRandom Access Memory, SRAM</code>）：是一种基于静态存储单元的存储器技术。<code>SRAM</code>主要用于实现高速缓存、寄存器文件和其他需要快速访问的存储器部件，包括但不限于CPU内部缓存。</p>
<h4 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h4><p><strong>三级缓存</strong>：现代CPU通常包含多层级别的高速缓存，包括 <code>L1</code>（一级缓存）、<code>L2</code>（二级缓存）和<code>L3</code>（三级缓存）。</p>
<ul>
<li>**<code>L1 Cache</code>**：位于CPU核心内部，速度最快，但容量较小。</li>
<li>**<code>L2 Cache</code>**：通常位于CPU核心之间或者与核心紧密结合，速度次于<code>L1</code>，容量比<code>L1</code>大。</li>
<li>**<code>L3 Cache</code>**：位于处理器芯片上，用于共享所有CPU核心之间的数据，速度比<code>L2</code>和<code>L1</code>略慢，但容量最大。</li>
</ul>
<h4 id="命中和失效"><a href="#命中和失效" class="headerlink" title="命中和失效"></a>命中和失效</h4><ul>
<li><p><strong>缓存命中（Cache Hit）</strong>：当处理器需要访问数据时，如果数据恰好在缓存中，则可以直接从缓存中读取，这称为缓存命中。</p>
</li>
<li><p><strong>缓存失效（Cache Miss）</strong>：如果需要的数据不在缓存中，则发生缓存失效，处理器必须从主存中读取数据，并将其存入缓存，以备将来使用。</p>
</li>
</ul>
<h3 id="ROM（Read-Only-Memory，只读存储器）"><a href="#ROM（Read-Only-Memory，只读存储器）" class="headerlink" title="ROM（Read-Only Memory，只读存储器）"></a>ROM（Read-Only Memory，只读存储器）</h3><p>一种计算机存储器类型，主要特点是一旦数据被存储在其中，就无法直接修改或写入新的数据。这使得<code>ROM</code>适合存储那些不需要经常更改的固定数据，例如系统固件、基本输入输出系统（BIOS）、引导程序等</p>
<p><strong>种类和应用</strong>：</p>
<ul>
<li><strong><code>EPROM</code>（可擦除可编程ROM）</strong>：<code>EPROM</code>可以通过特定的擦除设备进行擦除和重新编程，但通常需要专业的设备，不适合常规用户。</li>
<li><strong><code>EEPROM</code>（电可擦除可编程ROM）</strong>：<code>EEPROM</code>相对更容易擦除和重新编程，可以通过特定的电压信号来实现擦除操作。</li>
<li><strong><code>Flash</code>存储器</strong>：<code>Flash</code>存储器是一种基于<code>EEPROM</code>技术的可编程存储器，适合大容量数据存储和固件更新。</li>
</ul>
<h2 id="显卡"><a href="#显卡" class="headerlink" title="显卡"></a>显卡</h2><p>显卡又称为VGA（<code>Video Graphics Array</code>），用于图形影像的显示。</p>
<p>一般对于图形影像的显示重点在于分辨率与色彩深度，每个图像显示的颜色会占用掉内存，显卡上面会有一个内存的容量，这个显存容量会影响屏幕分辨率与色彩深度。</p>
<p>除了显存之外，显卡的运算能力也很重要。一些<code>3D</code>的运算早期是交给CPU去运行的，但是CPU并非完全针对这些<code>3D</code>来进行设计的，而且CPU平时已经非常忙碌了！所以显卡厂商直接在显卡上面嵌入一个<code>3D</code>加速的芯片，这就是所谓的<code>GPU</code>称谓的由来。</p>
<h3 id="PCIe"><a href="#PCIe" class="headerlink" title="PCIe"></a><code>PCIe</code></h3><p><code>PCIe</code>（Peripheral Component Interconnect Express，外设组件互联扩展）是一种用于连接高速外设和主板的计算机总线标准，使用的是类似管线的概念来处理，在 <code>PCIe 1.0</code>中，每条管线可以具有<code>250MBytes/s</code>的带宽性能，管线越多（通常设计到 <code>x16</code>管线）则总带宽越高。</p>
<table>
<thead>
<tr>
<th>规格</th>
<th>1x带宽</th>
<th>16x带宽</th>
<th>速度</th>
</tr>
</thead>
<tbody><tr>
<td>PCIe 1.0</td>
<td>250MB&#x2F;s</td>
<td>4GB&#x2F;s</td>
<td>2.5 GT&#x2F;s</td>
</tr>
<tr>
<td>PCIe 2.0</td>
<td>500MB&#x2F;s</td>
<td>8GB&#x2F;s</td>
<td>5 GT&#x2F;s</td>
</tr>
<tr>
<td>PCIe 3.0</td>
<td>1GB&#x2F;s</td>
<td>16GB&#x2F;s</td>
<td>8 GT&#x2F;s</td>
</tr>
<tr>
<td>PCIe 4.0</td>
<td>2GB&#x2F;s</td>
<td>32GB&#x2F;s</td>
<td>16 GT&#x2F;s</td>
</tr>
<tr>
<td>PCIe 5.0</td>
<td>4GB&#x2F;s</td>
<td>64GB&#x2F;s</td>
<td>32 GT&#x2F;s</td>
</tr>
</tbody></table>
<h2 id="硬盘和储存设备"><a href="#硬盘和储存设备" class="headerlink" title="硬盘和储存设备"></a>硬盘和储存设备</h2><p>硬盘（Hard Disk Drive，HDD）是一种用于存储数据的计算机存储设备，它由多个磁性盘片（通常为金属或玻璃材料制成）组成，盘片上覆盖有磁性材料，用来存储数据。</p>
<h4 id="结构和工作原理"><a href="#结构和工作原理" class="headerlink" title="结构和工作原理"></a>结构和工作原理</h4><h5 id="磁盘和磁头"><a href="#磁盘和磁头" class="headerlink" title="磁盘和磁头"></a><strong>磁盘和磁头</strong></h5><ul>
<li><strong>磁盘片</strong>：硬盘内部有一个或多个磁盘片，通常是金属或玻璃材料制成，表面上有一层磁性材料。</li>
<li><strong>磁头</strong>：每个磁盘片的两面都有读写磁头，负责在盘片表面上读取和写入数据。</li>
</ul>
<h5 id="数据存储原理："><a href="#数据存储原理：" class="headerlink" title="数据存储原理："></a><strong>数据存储原理</strong>：</h5><ul>
<li><strong>磁性记录</strong>：硬盘通过在磁盘片表面创建的磁性颗粒来记录数据。这些颗粒在磁场的作用下会根据磁性状况的不同，存储0和1的数据。</li>
</ul>
<h5 id="工作过程："><a href="#工作过程：" class="headerlink" title="工作过程："></a><strong>工作过程</strong>：</h5><ul>
<li><strong>读取数据</strong>：当计算机需要读取硬盘上的数据时，磁头会定位到相应的磁道（一个圆形的路径），并读取相应的磁性颗粒上的数据。</li>
<li><strong>写入数据</strong>：写入数据时，磁头会通过改变磁性颗粒的磁性状态来记录新的数据</li>
</ul>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><h5 id="传统硬盘驱动器（HDD）："><a href="#传统硬盘驱动器（HDD）：" class="headerlink" title="传统硬盘驱动器（HDD）："></a><strong>传统硬盘驱动器（HDD）</strong>：</h5><ul>
<li><strong>机械结构</strong>：传统HDD内部有机械运动部件，如旋转的磁盘片和移动的读写磁头。</li>
<li><strong>容量</strong>：通常具有较大的存储容量，目前主流产品容量从几百GB到数TB不等。</li>
<li><strong>成本</strong>：相对于其他存储设备（如固态硬盘），传统HDD通常价格更低。</li>
</ul>
<h5 id="固态硬盘（SSD）："><a href="#固态硬盘（SSD）：" class="headerlink" title="固态硬盘（SSD）："></a><strong>固态硬盘（SSD）</strong>：</h5><ul>
<li><strong>基于闪存技术</strong>：SSD使用闪存芯片而非机械部件来存储数据，因此没有机械运动，速度更快。</li>
<li><strong>速度</strong>：读写速度比传统HDD快得多，适合需要快速访问数据的应用。</li>
<li><strong>耐用性</strong>：由于没有移动部件，SSD通常比传统HDD更耐用，对震动和冲击更具抵抗力</li>
</ul>
<h4 id="数据存储和访问的物理结构"><a href="#数据存储和访问的物理结构" class="headerlink" title="数据存储和访问的物理结构"></a>数据存储和访问的物理结构</h4><h5 id="扇区（Sector）"><a href="#扇区（Sector）" class="headerlink" title="扇区（Sector）"></a>扇区（Sector）</h5><ul>
<li><strong>定义</strong>：扇区是硬盘上最小的物理数据存储单元。每个扇区可以存储固定大小的数据块。</li>
<li><strong>大小</strong>：传统硬盘通常的扇区大小为512字节或4KB（4096字节）。SSD的扇区大小可能会有所不同，通常为4KB或更大。</li>
<li><strong>作用</strong>：操作系统和硬件使用扇区来读取和写入数据，扇区的大小决定了硬盘能够存储和处理的最小数据单位。</li>
</ul>
<h5 id="磁道（Track）"><a href="#磁道（Track）" class="headerlink" title="磁道（Track）"></a>磁道（Track）</h5><ul>
<li><strong>定义</strong>：磁道是硬盘盘片表面上的一个圆形轨道，沿着盘片的半径方向布置。</li>
<li><strong>结构</strong>：硬盘通常有多个磁道，每个磁道被划分为多个扇区。同一个磁道上的扇区具有相同的物理距离，这有助于保持读写数据的稳定性和一致性。</li>
<li><strong>作用</strong>：磁道用于组织和管理硬盘上的数据，操作系统可以通过磁头在磁道上的移动来访问不同扇区中的数据。</li>
</ul>
<h5 id="柱面（Cylinder）"><a href="#柱面（Cylinder）" class="headerlink" title="柱面（Cylinder）"></a>柱面（Cylinder）</h5><ul>
<li><strong>定义</strong>：柱面是所有盘片上相同半径位置的磁道的集合体。换句话说，所有盘片上垂直于盘片表面的磁道构成一个柱面。</li>
<li><strong>结构</strong>：硬盘通常有多个盘片，每个盘片上有多个磁道，多个盘片上对应的磁道构成一个柱面。例如，第一个磁头上的第一个磁道，第二磁头上的第一个磁道等等。</li>
<li><strong>作用</strong>：操作系统使用柱面来组织和优化磁头的访问顺序，通过在同一柱面上的不同磁头移动，可以快速访问多个盘片上的数据。</li>
</ul>
<h5 id="物理布局和优化"><a href="#物理布局和优化" class="headerlink" title="物理布局和优化"></a>物理布局和优化</h5><ul>
<li><strong>寻道</strong>：硬盘读取数据时，磁头必须移动到正确的磁道上，这个过程称为寻道。</li>
<li><strong>扇区间隙和同步</strong>：相邻扇区之间通常有间隙和同步字段，用于确保数据的正确读取和写入。</li>
<li><strong>数据组织</strong>：操作系统和硬件通过优化磁道和柱面的访问顺序来最大化硬盘的性能和效率。</li>
</ul>
<h4 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h4><h5 id="MBR（Master-Boot-Record）"><a href="#MBR（Master-Boot-Record）" class="headerlink" title="MBR（Master Boot Record）"></a>MBR（Master Boot Record）</h5><p>传统的分区方案和引导加载程序，用于BIOS（Basic Input&#x2F;Output System）和早期UEFI系统</p>
<ul>
<li>限制：MBR支持的最大磁盘容量为2TB（2^32个扇区），最多支持 4个主分区 或者 3个主分区 和 1个扩展分区</li>
<li>结构：MBR存储在硬盘的第一个扇区（通常是512字节），包括分区表（Partition Table）（64字节）和引导加载程序（Bootloader）</li>
<li>主分区是MBR分区方案中的基本分区类型，最多支持4个主分区</li>
<li>扩展分区是一种特殊的主分区，用于扩展MBR分区方案的分区数量限制</li>
</ul>
<p>有三种类型的分区</p>
<ul>
<li>主分区（Primary Partition）<ul>
<li>MBR分区方案中的基本分区类型，最多支持4个主分区</li>
<li>每个主分区可以包含一个操作系统或数据</li>
<li>可以直接被操作系统识别和引导</li>
<li>每个主分区被描述为一个分区条目，占据分区表的一个条目</li>
</ul>
</li>
<li>扩展分区（Extended Partition）<ul>
<li>一种特殊的主分区，用于扩展MBR分区方案的分区数量限制</li>
<li>只能有一个扩展分区，可以包含多个逻辑分区</li>
<li>本身并不存储文件数据，它仅用于存放其他逻辑分区的信息</li>
</ul>
</li>
<li>逻辑分区<ul>
<li>逻辑分区是存在于扩展分区内的分区，用于克服主分区数量限制</li>
<li>通常用于存储数据，不能直接被操作系统引导</li>
<li>逻辑分区的数量没有明确的限制，只受扩展分区的容量限制</li>
</ul>
</li>
</ul>
<h5 id="GPT（GUID-Partition-Table）"><a href="#GPT（GUID-Partition-Table）" class="headerlink" title="GPT（GUID Partition Table）"></a>GPT（GUID Partition Table）</h5><p>一种现代的分区方案和引导加载程序，设计用于替代 MBR，并广泛支持UEFI（Unified Extensible Firmware Interface）系统</p>
<ul>
<li>容量：GPT支持更大的硬盘容量，最多可达到约8ZB（2^64个扇区，1ZB &#x3D; 230TB）</li>
<li>分区数量：GPT支持128个分区条目，每个分区条目可以是主分区或逻辑分区，且没有主扩展分区的限制</li>
<li>结构：GPT在硬盘的起始位置（通常是第一个扇区）存储主要GPT头（Primary GPT Header）和GPT备份表（Backup GPT Header and Partition Table），这些信息在硬盘上多个位置进行存储，提供了容错性</li>
</ul>
<blockquote>
<p>使用 lscpu 或 cat &#x2F;proc&#x2F;cpuinfo 或 lspci 查看主板各元件信息</p>
</blockquote>
<h1 id="二、Linux学习"><a href="#二、Linux学习" class="headerlink" title="二、Linux学习"></a>二、Linux学习</h1><p>Linux的核心原型是1991年由托瓦兹（Linus Torvalds）写出来的。</p>
<p>Linux的核心版本编号如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看内核版本</span><br>$ <span class="hljs-built_in">uname</span> -r<br>4.18.0-348.7.1.el8_5.x86_64<br><span class="hljs-comment"># 各参数说明</span><br>主版本号（Linux内核的主要版本号）：4<br>次版本号（内核的次要版本更新）：18<br>修订版本号（对次版本的小的修正和错误修复）：0<br>内核编译号（Linux内核编译时的唯一标识）：348<br>ABI（Application Binary Interface）变化序号（内核与用户空间之间的接口是否发生了变化）：7<br>发布序号（用于指示特定版本的修订或维护更新）：1<br>发行标签（表示此内核是为特定的Linux发行版编译的）：el8_5（适用于RHEL 8.5（Red Hat Enterprise Linux 8.5）发行版）<br>处理器架构（内核编译的目标处理器架构）：x86_64<br></code></pre></td></tr></table></figure>

<p>在Linux系统中，<strong>万物皆为文件</strong></p>
<blockquote>
<p> 比如：SATA接口的硬盘的文件名称即为&#x2F;dev&#x2F;sd[a-d]</p>
</blockquote>
<h2 id="目录树结构"><a href="#目录树结构" class="headerlink" title="目录树结构"></a>目录树结构</h2><p>所谓的目录树结构（directory tree），就是以根目录为主，然后向下呈现分支状的目录结构的一种文件架构。整个目录树架构最重要的就是那个根目录（root directory），用 <code>/</code> 表示，所有的文件都与目录树有关。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mermaid">graph TD;<br>	/ --&gt; /etc<br>	/ --&gt; /bin<br>	/ --&gt; /home<br>	/ --&gt; /usr<br>	/ --&gt; ...<br>	/home --&gt; /www<br>	/home --&gt; /test<br>	/test --&gt; 1&gt; 1.txt]<br>	/test --&gt; 2&gt; 2.txt]<br></code></pre></td></tr></table></figure>

<h2 id="挂载（文件系统与目录树的关系）"><a href="#挂载（文件系统与目录树的关系）" class="headerlink" title="挂载（文件系统与目录树的关系）"></a>挂载（文件系统与目录树的关系）</h2><p>利用一个目录（挂载点）当成进入点，将磁盘分区的数据放置在该目录下，即进入该目录就可以读取该分区的意思</p>
<blockquote>
<p>如何判断某个文件在哪个partition下</p>
<ul>
<li><p>使用 <code>df</code> 命令</p>
<p>df -h &#x2F;path&#x2F;to&#x2F;your&#x2F;file</p>
</li>
<li><p>使用findmnt命令</p>
<p>findmnt -n -o SOURCE –target &#x2F;path&#x2F;to&#x2F;your&#x2F;file</p>
</li>
<li><p>stat命令</p>
<p>stat -c %D &#x2F;path&#x2F;to&#x2F;your&#x2F;file</p>
</li>
<li><p>通过 <code>/proc</code> 文件系统查看</p>
<p>grep &#x2F;path&#x2F;to&#x2F;your&#x2F;file &#x2F;proc&#x2F;mounts</p>
</li>
</ul>
</blockquote>
<h2 id="Linux系统安装"><a href="#Linux系统安装" class="headerlink" title="Linux系统安装"></a>Linux系统安装</h2><p>以CentOS7为例</p>
<ul>
<li>烧录镜像到到 U盘</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># USB 设备为 /dev/sdc</span><br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=centos7.iso of=/dev/sdc<br></code></pre></td></tr></table></figure>

<ul>
<li>进入BIOS（一般是重启后狂按<code>del</code>或<code>F2</code>）</li>
<li>关闭安全启动</li>
<li>调整开机启动速度，将U盘调整到第一优先开机，F10保存并退出</li>
<li>安装Linux系统（这块后面补充）</li>
</ul>
<blockquote>
<p>关于<code>swap</code>分区：</p>
<p>内存交换空间的功能是：当有数据被存放在内存里面，但又不是常被CPU所取用时，那么这些不常被使用的程序将会被丢到硬盘的swap交换空间当中，将内存空间释放出来给真正需要的程序使用！目前机器内存都比较大，所以一般分配 swap 1-2G足够。</p>
</blockquote>
<h3 id="Kickstart-配置文件"><a href="#Kickstart-配置文件" class="headerlink" title="Kickstart 配置文件"></a>Kickstart 配置文件</h3><p>Kickstart 是 Red Hat 系统上用于自动化安装的一种方法，允许用户定义安装过程中的各种参数和配置选项，从而实现无人值守安装。</p>
<p><code>/root/anaconda-ks.cfg</code> 文件是 Anaconda 安装程序使用的 Kickstart 配置文件。在 Linux 系统中，特别是在基于 Red Hat 的发行版（如 CentOS、Fedora）中，Anaconda 是用于系统安装的图形化和文本界面安装程序。</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul>
<li><p><strong>自动化安装</strong>：通过定义 Kickstart 文件，可以指定安装过程中需要的各种配置选项，如分区设置、软件包选择、网络配置、用户账号等。</p>
</li>
<li><p><strong>批量部署</strong>：Kickstart 文件可以用于批量部署多台机器，确保所有安装过程的配置和参数一致。</p>
</li>
<li><p><strong>简化配置</strong>：避免手动输入和配置，尤其是在大规模部署和测试环境中，可以大大提高效率和减少错误。</p>
</li>
</ul>
<h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h4><ul>
<li>准备 Kickstart 文件，如<code>/root/anaconda-ks.cfg</code> </li>
<li>准备安装介质，如U盘</li>
<li>重启进入引导界面</li>
<li>输入 <code>linux ks=hd:sda1/anaconda-ks.cfg</code>后回车，假设 Kickstart 文件在 sda1 分区上的根目录下</li>
</ul>
<blockquote>
<p> 登陆成功后终端显示如下，其中<code>test</code>表示目前使用者的账号，@之后接的 <code>172-12-0-1</code>是主机名称，<code>~</code>指当前目录（在这里 ~ 等同于 &#x2F;home&#x2F;test），<code>$</code>是提示字符（root用户是#，普通用户是$）</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># root用户</span><br>[root@172-12-0-1 ~]#<br><span class="hljs-comment"># 一般用户</span><br>[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$<br></code></pre></td></tr></table></figure>

<p>登出系统</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 登出当前的终端会话，不是关机</span><br>[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ <span class="hljs-built_in">exit</span><br><span class="hljs-comment"># 效果同exit</span><br>[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ <span class="hljs-built_in">logout</span><br><span class="hljs-comment"># 使用Ctrl + D组合键</span><br><br><span class="hljs-comment"># 强制关闭指定用户的所有会话，可能需要管理员权限</span><br>[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ pkill -KILL -u &lt;username&gt;<br></code></pre></td></tr></table></figure>

<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ <span class="hljs-built_in">command</span>  [-options]  parameter1  parameter2 ...<br><span class="hljs-comment">#						指令		选项		  参数（1）	   参数（2）</span><br></code></pre></td></tr></table></figure>

<ul>
<li>command: 可以是指令或可执行文件</li>
<li>中刮号<code>[]</code>里边是可选的指令，比如 <code>-h</code> 或者 <code>--help</code>（完整全名需要使用 <code>--</code>）</li>
<li>指令太长的时候，可以使用反斜线（<code>\</code>）来换行</li>
<li>指令大小写含义是不同的</li>
</ul>
<h2 id="基础指令"><a href="#基础指令" class="headerlink" title="基础指令"></a>基础指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看当前日期和时间</span><br>[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ <span class="hljs-built_in">date</span><br><span class="hljs-comment"># 格式化为 yyyy/MM/dd 格式</span><br>[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ <span class="hljs-built_in">date</span> +%Y/%m/%d<br><span class="hljs-comment"># 格式化为 HH:mm:ss格式</span><br>[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ <span class="hljs-built_in">date</span> +%H:%M:%S<br><br><span class="hljs-comment"># 显示日历</span><br><span class="hljs-comment"># cal [month] [year]</span><br>[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ cal<br><span class="hljs-comment"># 显示一年的日历</span><br>[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ cal 2024<br><span class="hljs-comment"># 显示某一年某一月的日历</span><br>[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ cal 8 2024<br></code></pre></td></tr></table></figure>

<h2 id="中文乱码问题"><a href="#中文乱码问题" class="headerlink" title="中文乱码问题"></a>中文乱码问题</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ locale<br><span class="hljs-comment"># 语言语系的输出</span><br>LANG=zh_CN.UTF-8<br><span class="hljs-comment"># 下面为许多信息的输出使用的特别语系</span><br>LC_CTYPE=<span class="hljs-string">&quot;zh_CN.UTF-8&quot;</span><br>LC_NUMERIC=<span class="hljs-string">&quot;zh_CN.UTF-8&quot;</span><br><span class="hljs-comment"># 时间方面的语系数据</span><br>LC_TIME=<span class="hljs-string">&quot;zh_CN.UTF-8&quot;</span><br>LC_COLLATE=<span class="hljs-string">&quot;zh_CN.UTF-8&quot;</span><br>...<br><span class="hljs-comment"># 全部的数据同步更新的设置值</span><br>LC_ALL=<br></code></pre></td></tr></table></figure>

<h3 id="修改语言"><a href="#修改语言" class="headerlink" title="修改语言"></a>修改语言</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 临时修改为英文（exit后失效）</span><br><span class="hljs-comment"># LANG 只与输出讯息有关，若需要更改其他不同的信息，要同步更新 LC_ALL 才行</span><br><span class="hljs-comment"># 等号两边没有空白字符</span><br>[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ LANG=en_US.utf8<br>[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ <span class="hljs-built_in">export</span> LC_ALL=en_US.utf8<br></code></pre></td></tr></table></figure>

<h2 id="计算器：bc"><a href="#计算器：bc" class="headerlink" title="计算器：bc"></a>计算器：bc</h2><ul>
<li><p>安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 确认是否安装</span><br>[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ bc --version<br><span class="hljs-comment"># 安装</span><br>[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ <span class="hljs-built_in">sudo</span> yum install -y bc<br></code></pre></td></tr></table></figure>
</li>
<li><p>使用</p>
<ul>
<li><p>基础计算</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;2 + 3&quot;</span> | bc<br></code></pre></td></tr></table></figure>
</li>
<li><p>浮点数计算</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 需要设置小数点的精度scale</span><br>[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;scale=2; 5 / 3&quot;</span> | bc<br></code></pre></td></tr></table></figure>
</li>
<li><p>变量和表达式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;a=5; b=3; a * b&quot;</span> | bc<br></code></pre></td></tr></table></figure>
</li>
<li><p>函数和计算</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;scale=2; sqrt(16)&quot;</span> | bc<br>[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;scale=2; 2^3&quot;</span> | bc<br></code></pre></td></tr></table></figure>
</li>
<li><p>从文件读取表达式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;3 + 4&quot;</span> &gt; calc.txt<br>[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ bc &lt; calc.txt<br></code></pre></td></tr></table></figure>
</li>
<li><p>交互式模式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ bc<br><span class="hljs-comment"># ENTER</span><br>scale=3<br>22 / 7<br></code></pre></td></tr></table></figure>
</li>
<li><p>启用数学库，使用 <code>-l</code> 选项启用数学库，提供更多函数支持（如对数、三角函数等）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 计算 10 的自然对数</span><br>[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;scale=2; l(10)&quot;</span> | bc -l<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>退出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ quit<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="Tab代码补全"><a href="#Tab代码补全" class="headerlink" title="Tab代码补全"></a>Tab代码补全</h2><h3 id="代码补全"><a href="#代码补全" class="headerlink" title="代码补全"></a>代码补全</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 如果d有多个，显示所有d开头的指令，同样适用于文件补全</span><br>[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ d[Tab][Tab]<br>[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ <span class="hljs-built_in">ls</span> -al ~/.bash[tab][tab]<br><span class="hljs-comment"># 如果da开头指令只有一个，自动补全</span><br>[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ da[Tab]<br></code></pre></td></tr></table></figure>

<h3 id="参数-选项补齐"><a href="#参数-选项补齐" class="headerlink" title="参数&#x2F;选项补齐"></a>参数&#x2F;选项补齐</h3><ul>
<li><p>安装<code>bash-completion</code>软件，只适用于 <code>bash</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ <span class="hljs-built_in">sudo</span> yum install -y bash-completion<br></code></pre></td></tr></table></figure>
</li>
<li><p>验证</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ <span class="hljs-built_in">date</span> --[Tab][Tab]<br></code></pre></td></tr></table></figure>
</li>
<li><p>如果验证不生效，启用 <code>bash-completion</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 打开 ~/.bashrc 文件，这里使用vim</span><br>[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ <span class="hljs-built_in">sudo</span> vim ~/.bashrc<br></code></pre></td></tr></table></figure>

<p>在文件末尾添加以下行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"># Enable bash completion<br>if [ -f /etc/profile.d/bash_completion.sh ]; then<br>    . /etc/profile.d/bash_completion.sh<br>fi<br></code></pre></td></tr></table></figure>

<p>重新加载配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ <span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="向前向后翻页"><a href="#向前向后翻页" class="headerlink" title="向前向后翻页"></a>向前向后翻页</h2><ul>
<li><p>向前：Shift + PageUp</p>
</li>
<li><p>向后：Shift + PageDown</p>
</li>
</ul>
<h2 id="命令帮助文档"><a href="#命令帮助文档" class="headerlink" title="命令帮助文档"></a>命令帮助文档</h2><h3 id="指令的help求助"><a href="#指令的help求助" class="headerlink" title="指令的help求助"></a>指令的help求助</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs bash">[<span class="hljs-built_in">test</span>@172-12-0-1 <span class="hljs-built_in">test</span>]$ <span class="hljs-built_in">date</span> --<span class="hljs-built_in">help</span><br><br>用法：<span class="hljs-built_in">date</span> [选项]... [+格式]	<span class="hljs-comment"># 基本语法</span><br>　或：<span class="hljs-built_in">date</span> [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]	<span class="hljs-comment"># 设置时间的语法</span><br>Display the current time <span class="hljs-keyword">in</span> the given FORMAT, or <span class="hljs-built_in">set</span> the system <span class="hljs-built_in">date</span>.<br><br><span class="hljs-comment"># 下面是主要的选项说明</span><br>必选参数对长短选项同时适用。<br>  -d, --<span class="hljs-built_in">date</span>=STRING          display time described by STRING, not <span class="hljs-string">&#x27;now&#x27;</span><br>      --debug                annotate the parsed <span class="hljs-built_in">date</span>,<br>                              and warn about questionable usage to stderr<br>  -f, --file=DATEFILE        like --<span class="hljs-built_in">date</span>; once <span class="hljs-keyword">for</span> each line of DATEFILE<br>  ...<br>  -u, --utc, --universal     <span class="hljs-built_in">print</span> or <span class="hljs-built_in">set</span> Coordinated Universal Time (UTC)<br>      --<span class="hljs-built_in">help</span>		显示此帮助信息并退出<br>      --version		显示版本信息并退出<br><br><span class="hljs-comment"># 下面是格式化（FORMAT）的主要项目</span><br>给定的格式FORMAT 控制着输出，解释序列如下：<br><br>  %%	一个文字的 %<br>  %a	当前locale 的星期名缩写(例如： 日，代表星期日)<br>  %A	当前locale 的星期名全称 (如：星期日)<br>  ...<br><br><span class="hljs-comment"># 下面是几个重要的范例（Example）</span><br>Examples:<br>Convert seconds since the epoch (1970-01-01 UTC) to a <span class="hljs-built_in">date</span><br>  $ <span class="hljs-built_in">date</span> --<span class="hljs-built_in">date</span>=<span class="hljs-string">&#x27;@2147483647&#x27;</span><br><br>Show the time on the west coast of the US (use tzselect(1) to find TZ)<br>  $ TZ=<span class="hljs-string">&#x27;America/Los_Angeles&#x27;</span> <span class="hljs-built_in">date</span><br><br>Show the <span class="hljs-built_in">local</span> time <span class="hljs-keyword">for</span> 9AM next Friday on the west coast of the US<br>  $ <span class="hljs-built_in">date</span> --<span class="hljs-built_in">date</span>=<span class="hljs-string">&#x27;TZ=&quot;America/Los_Angeles&quot; 09:00 next Fri&#x27;</span><br><br>GNU coreutils 在线帮助：&lt;https://www.gnu.org/software/coreutils/&gt;<br>请向 &lt;http://translationproject.org/team/zh_CN.html&gt; 报告 <span class="hljs-built_in">date</span> 的翻译错误<br>完整文档请见：&lt;https://www.gnu.org/software/coreutils/date&gt;<br>或者在本地使用：info <span class="hljs-string">&#x27;(coreutils) date invocation&#x27;</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>通常 –help 用在协助你查询“你曾经用过的指令所具备的选项与参数”而已，如果你要使用的是从来没有用过得指令，或者是你要查询的根本就不是指令，而是<code>文件的格式</code>时，那就得要通过 man page </p>
</blockquote>
<h3 id="man-page"><a href="#man-page" class="headerlink" title="man page"></a>man page</h3><p>man是<code>manual</code>（操作说明）的简写，man page的数据通常放在<code>/usr/share/man/</code>下（可以在<code>/etc/man_db.conf</code> 配置）</p>
<ul>
<li>常用按键操作</li>
</ul>
<table>
<thead>
<tr>
<th>按键</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>Enter</td>
<td>显示下一行</td>
</tr>
<tr>
<td>空格 &#x2F; Page Down</td>
<td>向下翻一页</td>
</tr>
<tr>
<td>Page Up</td>
<td>向上翻一页</td>
</tr>
<tr>
<td>Home</td>
<td>回到首页</td>
</tr>
<tr>
<td>End</td>
<td>去到尾页</td>
</tr>
<tr>
<td>&#x2F;string</td>
<td>向下搜索字符串string</td>
</tr>
<tr>
<td>?string</td>
<td>向上搜索字符串string</td>
</tr>
<tr>
<td>n</td>
<td>向下搜索</td>
</tr>
<tr>
<td>N</td>
<td>向上搜索</td>
</tr>
<tr>
<td>q</td>
<td>退出man page</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs bash">[<span class="hljs-built_in">test</span>@172-12-0-1 <span class="hljs-built_in">test</span>]$ man <span class="hljs-built_in">date</span><br><br><span class="hljs-comment"># 请注意上面这个括号内的数字</span><br>DATE(1)                  			User Commands              				    DATE(1)<br><span class="hljs-comment"># 这个指令的完整全名，如下所示为date且说明简单用途为设置与显示日期/时间</span><br>NAME<br>       <span class="hljs-built_in">date</span> - <span class="hljs-built_in">print</span> or <span class="hljs-built_in">set</span> the system <span class="hljs-built_in">date</span> and time<br><span class="hljs-comment"># 这个指令的基本语法如下所示</span><br>SYNOPSIS<br>       <span class="hljs-built_in">date</span> [OPTION]... [+FORMAT]<br>       <span class="hljs-built_in">date</span> [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]<br><span class="hljs-comment"># 详细说明刚刚语法谈到的选项与参数的用法</span><br>DESCRIPTION<br>       Display the current time <span class="hljs-keyword">in</span> the given FORMAT, or <span class="hljs-built_in">set</span> the system <span class="hljs-built_in">date</span>.<br><br>       Mandatory arguments to long options are mandatory <span class="hljs-keyword">for</span> short options too.<br><br>       -d, --<span class="hljs-built_in">date</span>=STRING<br>              display time described by STRING, not <span class="hljs-string">&#x27;now&#x27;</span><br><br>       ...<br><br>       --version<br>              output version information and <span class="hljs-built_in">exit</span><br><br><span class="hljs-comment"># 格式化输出的详细数据</span><br>       FORMAT controls the output.  Interpreted sequences are:<br><br>       %%     a literal %<br><br>       ...<br><br>       %Z     alphabetic time zone abbreviation (e.g., EDT)<br><br><span class="hljs-comment"># 示例</span><br>EXAMPLES<br>       Convert seconds since the epoch (1970-01-01 UTC) to a <span class="hljs-built_in">date</span><br><br>              $ <span class="hljs-built_in">date</span> --<span class="hljs-built_in">date</span>=<span class="hljs-string">&#x27;@2147483647&#x27;</span><br><br>       ...<br><br><span class="hljs-comment"># date 的格式说明</span><br>DATE STRING<br>       The --<span class="hljs-built_in">date</span>=STRING is a mostly free format human readable <span class="hljs-built_in">date</span> string such as <span class="hljs-string">&quot;Sun, 29 Feb 2004 16:21:42 -0800&quot;</span> or <span class="hljs-string">&quot;2004-02-29 16:21:42&quot;</span> or even <span class="hljs-string">&quot;next Thursday&quot;</span>.  A <span class="hljs-built_in">date</span> string may contain items indicating calendar  <span class="hljs-built_in">date</span>,  time  of<br>       day, time zone, day of week, relative time, relative <span class="hljs-built_in">date</span>, and numbers.  An empty string indicates the beginning of the day.  The <span class="hljs-built_in">date</span> string format is more complex than is easily documented here but is fully described <span class="hljs-keyword">in</span> the info<br>       documentation.<br><br><span class="hljs-comment"># 与这个指令相关的环境参数说明</span><br>ENVIRONMENT<br>       TZ     Specifies the timezone, unless overridden by <span class="hljs-built_in">command</span> line parameters.  If neither is specified, the setting from /etc/localtime is used.<br><br><span class="hljs-comment"># 还可以从哪里查到与date相关的说明文档</span><br>SEE ALSO<br>       Full documentation at: &lt;https://www.gnu.org/software/coreutils/date&gt;<br>       or available locally via: info <span class="hljs-string">&#x27;(coreutils) date invocation&#x27;</span><br><br>GNU coreutils 8.30                       July 2018       				          DATE(1)<br></code></pre></td></tr></table></figure>

<blockquote>
<p>上面第一行出现的<code>DATE(1)</code>是什么意思呢</p>
<p>使用 <code>man man</code> 可以查看更多信息</p>
<table>
<thead>
<tr>
<th>代号</th>
<th>代表内容</th>
<th>重要</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>使用者在shell环境中可以操作的指令或可可执行文件</td>
<td>Y</td>
</tr>
<tr>
<td>2</td>
<td>系统核心可调用的函数与工具等</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>一些常用的函数（function）与函数库（library），大部分为C的函数库（libc）</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>设备文件的说明，通常在&#x2F;dev下的文件</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>配置文件或者是某些文件的格式</td>
<td>Y</td>
</tr>
<tr>
<td>6</td>
<td>游戏（games）</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>惯例与协定等，例如Linux文件系统、网络协定、ASCII code等等的说明</td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>系统管理员可用的管理指令</td>
<td>Y</td>
</tr>
<tr>
<td>9</td>
<td>跟kernel有关的文件</td>
<td></td>
</tr>
</tbody></table>
</blockquote>
<h4 id="搜寻特定指令-文件的man-page说明文档"><a href="#搜寻特定指令-文件的man-page说明文档" class="headerlink" title="搜寻特定指令&#x2F;文件的man page说明文档"></a>搜寻特定指令&#x2F;文件的man page说明文档</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用 -f 这个选项就可以取得更多与man相关的信息</span><br>[<span class="hljs-built_in">test</span>@172-12-0-1 /]$ man -f info<br>info (5)             - readable online documentation<br>info (1)             - <span class="hljs-built_in">read</span> Info documents<br><span class="hljs-comment"># 等同于 whatis [指令或数据]，如果使用不了，可以切换root用户执行 mandb</span><br>[<span class="hljs-built_in">test</span>@172-12-0-1 /]$ mandb<br>[<span class="hljs-built_in">test</span>@172-12-0-1 /]$ whatis info<br><br><span class="hljs-comment"># man info会使用哪个说明文档，跟/etc/man_db.conf配置的顺序有关，通常会使用数字小的</span><br><span class="hljs-comment"># 也可以手动去指定</span><br>[<span class="hljs-built_in">test</span>@172-12-0-1 /]$ man 1 info<br>[<span class="hljs-built_in">test</span>@172-12-0-1 /]$ man 5 info<br><br><span class="hljs-comment"># 找出系统说明文档中包含某个字符串的文件</span><br><span class="hljs-comment"># man -k string</span><br><span class="hljs-comment"># 等同于 apropos [指令或数据]</span><br>[<span class="hljs-built_in">test</span>@172-12-0-1 /]$ man -k info<br>[<span class="hljs-built_in">test</span>@172-12-0-1 /]$ apropos info<br></code></pre></td></tr></table></figure>

<h3 id="info-page"><a href="#info-page" class="headerlink" title="info page"></a>info page</h3><ol>
<li><p>与 <code>man page</code> 一次性输出一堆信息不同，<code>info page</code> 是将文件数据拆成一个一个的段落，每个段落用自己的页面来撰写，并且在各个页面中还有类似网页的“超链接”来跳到各不同的页面中，每个独立的页面也被称为一个节点（node）</p>
</li>
<li><p>支持info指令的文件放置在<code>/usr/share/info/</code>目录中。</p>
</li>
<li><p>查询的指令说明要具有info page功能的话，得用info page的格式来写成线上求助文件才行，否则展示效果同man page</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>N</td>
<td>前往下一个Node处</td>
</tr>
<tr>
<td>P</td>
<td>前往上一个Node处</td>
</tr>
<tr>
<td>U</td>
<td>向上移动一层</td>
</tr>
<tr>
<td>Tab</td>
<td>在Node节点间移动（有 node 的地方，通常会以 * 显示）</td>
</tr>
<tr>
<td>空白键 &#x2F; Page Down</td>
<td>向下翻一页</td>
</tr>
<tr>
<td>Page Up</td>
<td>向上翻一页</td>
</tr>
<tr>
<td>Enter</td>
<td>光标在Node上时，可以进入该Node节点</td>
</tr>
<tr>
<td>b</td>
<td>移动光标到该 info 画面当中的第一个 node 处</td>
</tr>
<tr>
<td>e</td>
<td>移动光标到该 info 画面当中的最后一个 node 处</td>
</tr>
<tr>
<td>s  或  &#x2F;</td>
<td>在 info page 当中进行搜索</td>
</tr>
<tr>
<td>h 或 ?</td>
<td>显示求助菜单</td>
</tr>
<tr>
<td>q</td>
<td>退出</td>
</tr>
</tbody></table>
<h3 id="其他有用的文件（documents）"><a href="#其他有用的文件（documents）" class="headerlink" title="其他有用的文件（documents）"></a>其他有用的文件（documents）</h3><p>在<code>/usr/share/doc</code>目录下，数据主要是以套件（packages）为主的，例如 git 的相关信息在 &#x2F;usr&#x2F;share&#x2F;doc&#x2F;git</p>
<h2 id="关机"><a href="#关机" class="headerlink" title="关机"></a>关机</h2><p>在 Linux 下面，有很多人在主机上面工作，直接按下电源开关来关机时，则其他人的数据可能就此中断。若不正常关机，则可能造成文件系统的毁损（因为来不及将数据回写到文件中，所以有些服务的文件会有问题！），所以关机需要注意：</p>
<ul>
<li><p>观察系统的使用状态：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看谁在线</span><br>[<span class="hljs-built_in">test</span>@172-12-0-1 /]$ <span class="hljs-built_in">who</span><br><span class="hljs-comment"># 查看网络连线状态</span><br>[<span class="hljs-built_in">test</span>@172-12-0-1 /]$ netstat -a<br><span class="hljs-comment"># 查看执行程序</span><br>[<span class="hljs-built_in">test</span>@172-12-0-1 /]$ ps -aux<br></code></pre></td></tr></table></figure>
</li>
<li><p>通知线上使用者关机的时刻，使用 <code>shutdown </code>指令</p>
</li>
</ul>
<p>几个与关机相关的命令</p>
<ul>
<li>将数据同步写入硬盘中的指令： sync<ul>
<li>在Linux系统中，为了加快数据的读取速度，所以在默认的情况中，某些已经载入内存中的数据将不会直接被写回硬盘，而是先暂存在内存当中</li>
<li>使用root账号执行，可以更新整个系统中的数据，否则只能更新单个用户的数据</li>
</ul>
</li>
<li>惯用的关机指令： shutdown</li>
<li>重新开机，关机： reboot &#x2F; halt &#x2F; poweroff<ul>
<li>这些指令在关机前进行了 sync 这个工具的调用</li>
<li>这些指令都是调用 systemctl 这个重要的管理命令</li>
</ul>
</li>
</ul>
<h1 id="三、Linux的文件权限与目录配置"><a href="#三、Linux的文件权限与目录配置" class="headerlink" title="三、Linux的文件权限与目录配置"></a>三、Linux的文件权限与目录配置</h1><p>Linux一般将文件可存取的身份分为三个类别，分别是 <code>owner/group/others</code>，且三种身份各有 <code>read/write/execute</code> 等权限</p>
<ul>
<li><p>owner（所有者）</p>
<ul>
<li><strong>定义</strong>：每个文件和目录都有一个所有者，通常是创建文件的用户。所有者对文件有特定的权限，可以是读取、写入或执行。</li>
<li><strong>权限表示</strong>：在文件权限的表示中，所有者的权限通常是权限字符串的第一个三位部分。例如，<code>-rwxr-xr--</code> 中的 <code>rwx</code> 表示所有者的权限。</li>
</ul>
</li>
<li><p>group（组）</p>
<ul>
<li><p><strong>定义</strong>：文件和目录的每个所有者都有一个关联的用户组。文件或目录的权限可以授予该组的所有成员。组权限使得同组的用户可以共享对文件的访问权。</p>
</li>
<li><p><strong>权限表示</strong>：在权限字符串中，组的权限是第二个三位部分。例如，<code>-rwxr-xr--</code> 中的 <code>r-x</code> 表示组用户的权限。</p>
</li>
</ul>
</li>
<li><p>others（其他用户）</p>
<ul>
<li><p><strong>定义</strong>：除文件所有者和文件所属组的用户之外的所有其他用户。这类用户的权限控制是为了保护文件不被不相关的用户访问。</p>
</li>
<li><p><strong>权限表示</strong>：在权限字符串中，其他用户的权限是第三个三位部分。例如，<code>-rwxr-xr--</code> 中的 <code>r--</code> 表示其他用户的权限。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>Linux使用者与群组记录的文件 </p>
<p>账号：&#x2F;etc&#x2F;passwd</p>
<p>密码：&#x2F;etc&#x2F;shadow</p>
<p>群组：&#x2F;etc&#x2F;group</p>
</blockquote>
<h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><p>使用 <code>ls -al</code> 可以查看文件权限</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@172-12-0-1 ~]# <span class="hljs-built_in">ls</span> -al<br>总用量 148<br>dr-xr-x---. 10 root root  4096 8月  12 10:51 .<br>dr-xr-xr-x. 24 root root  4096 7月  30 17:11 ..<br>-rw-------   1 root root 16635 8月  12 10:51 .bash_history<br>-rw-r--r--   1 root root   234 7月  30 08:56 .bashrc<br>drwxr-xr-x.  3 root root    17 7月  18 19:53 .cache<br>drwx------   3 root root    25 7月  23 11:15 .config<br>-rw-r--r--.  1 root root 47639 7月  16 11:45 install.sh<br>drwxr-x---   4 root root    37 7月  29 18:00 .vim<br></code></pre></td></tr></table></figure>

<h3 id="ls-al-显示字段解释"><a href="#ls-al-显示字段解释" class="headerlink" title="ls -al 显示字段解释"></a><code>ls -al</code> 显示字段解释</h3><h4 id="文件类型和权限-第1个参数"><a href="#文件类型和权限-第1个参数" class="headerlink" title="文件类型和权限(第1个参数)"></a>文件类型和权限(第1个参数)</h4><ul>
<li><code>drwxr-xr-x</code> 文件的权限和类型<ul>
<li>第一个字符表示文件类型<ul>
<li><code>-</code>：普通文件</li>
<li><code>d</code>：目录</li>
<li><code>l</code>：符号链接（link file）</li>
<li><code>c</code>：字符设备文件</li>
<li><code>b</code>：块设备文件</li>
<li><code>p</code>：命名管道（FIFO）</li>
<li><code>s</code>：套接字</li>
</ul>
</li>
<li>接下来的九个字符表示权限，没有权限时用 <code>-</code> 代替<ul>
<li><code>r</code>：读取权限，数字4表示</li>
<li><code>w</code>：写入权限，数字2表示</li>
<li><code>x</code>：执行权限，数字1表示</li>
</ul>
</li>
<li>权限分为三个部分，每部分三个字符<ul>
<li>所有者的权限</li>
<li>所属组的权限</li>
<li>其他用户的权限</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="硬链接数量（第2个参数）"><a href="#硬链接数量（第2个参数）" class="headerlink" title="硬链接数量（第2个参数）"></a>硬链接数量（第2个参数）</h4><ul>
<li>1：硬链接的数量。对于文件来说，通常是 <code>1</code>。对于目录，这个数字表示目录内包含的子目录数量加上 <code>.</code> 和 <code>..</code></li>
</ul>
<h4 id="所有者（第3个参数）"><a href="#所有者（第3个参数）" class="headerlink" title="所有者（第3个参数）"></a>所有者（第3个参数）</h4><ul>
<li><code>root</code>：文件或目录的所有者用户名。</li>
</ul>
<h4 id="所属组（第4个参数）"><a href="#所属组（第4个参数）" class="headerlink" title="所属组（第4个参数）"></a>所属组（第4个参数）</h4><ul>
<li><code>root</code>：文件或目录的所属组名。</li>
</ul>
<h4 id="文件大小（第5个参数）"><a href="#文件大小（第5个参数）" class="headerlink" title="文件大小（第5个参数）"></a>文件大小（第5个参数）</h4><ul>
<li><code>4096</code>：文件的大小，以字节为单位。对于目录，这个数字通常表示目录的元数据大小，而不是目录中文件的总大小</li>
</ul>
<h4 id="文件修改时间（第6个参数）"><a href="#文件修改时间（第6个参数）" class="headerlink" title="文件修改时间（第6个参数）"></a>文件修改时间（第6个参数）</h4><ul>
<li>8月  12 10:51：文件最后一次修改的日期和时间。格式通常为“月 日 时间”</li>
</ul>
<h4 id="文件名（第7个参数）"><a href="#文件名（第7个参数）" class="headerlink" title="文件名（第7个参数）"></a>文件名（第7个参数）</h4><ul>
<li><code>.bashrc</code>：文件或目录的名称，前面带<code>.</code>的是隐藏文件</li>
</ul>
<h2 id="改变文件属性和权限"><a href="#改变文件属性和权限" class="headerlink" title="改变文件属性和权限"></a>改变文件属性和权限</h2><ul>
<li><p>chgrp ：改变文件所属群组（changegroup）</p>
<ul>
<li>要被改变的群组名称必须要在<code>/etc/group</code>文件内存在才行</li>
</ul>
</li>
<li><p>chown ：改变文件拥有者（change owner）</p>
<ul>
<li>使用者必须是已经存在系统中的帐号，在<code>/etc/passwd</code> 这个文件中有纪录的使用者名称才能改变</li>
<li>还可以顺便修改群组的名称, <code>chown user:group file</code></li>
</ul>
</li>
<li><p>chmod ：改变文件的权限, SUID, SGID, SBIT等等的特性</p>
<ul>
<li>八进制模式<ul>
<li>权限用三位八进制数字表示，每位数字的范围是 <code>0</code> 到 <code>7</code><ul>
<li>4：读取权限 (<code>r</code>)</li>
<li>2：写入权限 (<code>w</code>)</li>
<li><strong>1</strong>：执行权限 (<code>x</code>)</li>
</ul>
</li>
<li>每种身份（owner&#x2F;group&#x2F;others）各自的三个权限（r&#x2F;w&#x2F;x）分数是累加的，比如<code>775</code> 代表 <code>-rwxrwxr-x</code></li>
</ul>
</li>
<li>符号模式<ul>
<li>符号模式使用字符表示权限<ul>
<li><code>u</code>：所有者（user）</li>
<li><code>g</code>：组（group）</li>
<li><code>o</code>：其他用户（others）</li>
<li><code>a</code>：所有用户（all）</li>
</ul>
</li>
<li>操作符：<ul>
<li><code>+</code>：添加权限</li>
<li><code>-</code>：移除权限</li>
<li><code>=</code>：设置权限</li>
</ul>
</li>
<li><code>-rwxr-xr-x</code> 可以设置为<code>chmod u=rwx,go=rx .bashrc</code>，<strong>其中u&#x3D;rwx,go&#x3D;rx间没有空格</strong></li>
<li>如果只想要增加<code>.bashrc</code>这个文件每个人均可写入的权限，可以使用 <code>chmod a+w .bashrc</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="FHS文件系统"><a href="#FHS文件系统" class="headerlink" title="FHS文件系统"></a>FHS文件系统</h2><p><strong>FHS（Filesystem Hierarchy Standard）</strong> 是一个定义 Linux 系统文件和目录结构的标准。FHS 提供了一个一致的文件系统布局指南，使得 Linux 发行版具有良好的兼容性和一致性。它规范了系统中常见的目录及其用途，便于系统管理员和开发人员理解和管理文件系统</p>
<h3 id="主要目录和其含义"><a href="#主要目录和其含义" class="headerlink" title="主要目录和其含义"></a>主要目录和其含义</h3><table>
<thead>
<tr>
<th>目录</th>
<th>中文名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;</td>
<td>根目录</td>
<td>文件系统的顶层目录，所有其他目录都挂载在这里</td>
</tr>
<tr>
<td>&#x2F;bin</td>
<td>基本用户命令</td>
<td>包含系统启动和修复所需的基本命令，如 <code>ls</code>, <code>cp</code>, <code>mv</code> 等</td>
</tr>
<tr>
<td>&#x2F;boot</td>
<td>启动文件</td>
<td>存放系统启动所需的文件，如内核映像（<code>vmlinuz</code>）和引导加载程序配置文件（<code>grub</code>）</td>
</tr>
<tr>
<td>&#x2F;dev</td>
<td>设备文件</td>
<td>包含设备文件，这些文件表示系统中的各种设备（如硬盘、终端等），通常是以 <code>char</code> 和 <code>block</code> 设备文件的形式存在</td>
</tr>
<tr>
<td>&#x2F;etc</td>
<td>系统配置文件</td>
<td>包含系统级别的配置文件和目录，如 <code>passwd</code>, <code>fstab</code>, <code>network</code>, 和其他系统配置文件</td>
</tr>
<tr>
<td>&#x2F;home</td>
<td>用户主目录</td>
<td>各用户的个人目录，通常每个用户都有一个子目录（如 <code>/home/username</code>）</td>
</tr>
<tr>
<td>&#x2F;lib</td>
<td>共享库</td>
<td>存放系统和应用程序使用的共享库文件。常见的库文件用于支持 <code>/bin</code> 和 <code>/sbin</code> 中的二进制文件</td>
</tr>
<tr>
<td>&#x2F;media</td>
<td>可移动媒体</td>
<td>自动挂载可移动媒体（如 CD-ROM、USB 设备）的位置</td>
</tr>
<tr>
<td>&#x2F;mnt</td>
<td>临时挂载点</td>
<td>用于临时挂载文件系统，通常用于手动挂载</td>
</tr>
<tr>
<td>&#x2F;opt</td>
<td>附加应用程序</td>
<td>用于安装附加的应用程序软件包。每个软件包可以有自己的子目录</td>
</tr>
<tr>
<td>&#x2F;proc</td>
<td>虚拟文件系统</td>
<td>提供关于内核和进程的信息，目录内容是虚拟的，不占用磁盘空间。常用于获取系统信息，如 <code>/proc/cpuinfo</code> 和 <code>/proc/meminfo</code></td>
</tr>
<tr>
<td>&#x2F;root</td>
<td>根用户的主目录</td>
<td>根用户（超级用户）的个人目录，通常用于存放根用户的配置文件</td>
</tr>
<tr>
<td>&#x2F;run</td>
<td>运行时数据</td>
<td>存放系统启动后产生的运行时数据，如 PID 文件、套接字等</td>
</tr>
<tr>
<td>&#x2F;srv</td>
<td>服务数据</td>
<td>存放由系统提供的服务数据，如 HTTP 或 FTP 服务的数据文件</td>
</tr>
<tr>
<td>&#x2F;sys</td>
<td>系统文件</td>
<td>提供内核和硬件的信息，类似于 <code>/proc</code>，但用于访问内核的实时信息</td>
</tr>
<tr>
<td>&#x2F;tmp</td>
<td>临时文件</td>
<td>存放临时文件，通常这些文件在系统重启后会被删除</td>
</tr>
<tr>
<td>&#x2F;usr</td>
<td>用户程序</td>
<td><code>Unix Software Resource</code>的缩写，存放用户级程序和数据。通常包括 <code>/usr/bin</code>（用户命令）、<code>/usr/lib</code>（共享库）和 <code>/usr/share</code>（共享数据）</td>
</tr>
<tr>
<td>&#x2F;var</td>
<td>可变数据</td>
<td>存放系统运行时产生的文件，如日志文件（<code>/var/log</code>）、邮件（<code>/var/mail</code>）、缓存（<code>/var/cache</code>）</td>
</tr>
</tbody></table>
<blockquote>
<p> 更多内容参考官方文档：<a target="_blank" rel="noopener" href="https://refspecs.linuxfoundation.org/FHS_3.0/fhs/index.html">Filesystem Hierarchy Standard (linuxfoundation.org)</a></p>
</blockquote>
<h1 id="四、Linux文件与目录管理"><a href="#四、Linux文件与目录管理" class="headerlink" title="四、Linux文件与目录管理"></a>四、Linux文件与目录管理</h1><h2 id="绝对路径与相对路径"><a href="#绝对路径与相对路径" class="headerlink" title="绝对路径与相对路径"></a>绝对路径与相对路径</h2><ul>
<li>绝对路径：路径的写法一定由根目录 <code>/</code> 写起，例如： &#x2F;usr&#x2F;share&#x2F;doc 这个目录</li>
<li>相对路径：路径的写法不是由 <code>/</code> 写起，相对路径指相对于目前工作目录的路径！例如由 &#x2F;usr&#x2F;share&#x2F;doc 要到 &#x2F;usr&#x2F;share&#x2F;man 下面时，可以写成： <code>cd ../man</code></li>
</ul>
<h2 id="目录的相关操作"><a href="#目录的相关操作" class="headerlink" title="目录的相关操作"></a>目录的相关操作</h2><p>在所有目录下面都会存在的两个目录，分别是<code>.</code>与<code>..</code>分别代表此层与上层目录的意思</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">.         代表此层目录<br>..        代表上一层目录<br>-         代表前一个工作目录<br>~         代表“目前使用者身份”所在的主文件夹<br>~account  代表 account 这个使用者的主文件夹<br></code></pre></td></tr></table></figure>

<ul>
<li><p>cd：变换目录</p>
</li>
<li><p>pwd：显示目前的目录</p>
</li>
<li><p>mkdir：创建一个新的目录</p>
<ul>
<li>mkdir [-mp] 目录名称</li>
</ul>
<p>  -m ：设置文件的权限</p>
<p>  -p：直接将所需要的目录（包含上层目录）递归创建起来</p>
</li>
<li><p>rmdir：删除一个<strong>空</strong>的目录</p>
</li>
<li><p>ls：列出目录内容</p>
</li>
<li><p>mv：移动或重命名目录</p>
</li>
<li><p>cp：复制目录</p>
</li>
<li><p>du：查看目录大小，<code>du -sh directory_name</code></p>
</li>
<li><p>ln s：创建符号链接</p>
</li>
<li><p>rm：移除文件或目录</p>
</li>
<li><p>basename：显示文件名</p>
</li>
<li><p>dirname：显示目录名</p>
</li>
</ul>
<h2 id="可执行文件路径变量（环境变量）：-PATH"><a href="#可执行文件路径变量（环境变量）：-PATH" class="headerlink" title="可执行文件路径变量（环境变量）：$PATH"></a>可执行文件路径变量（环境变量）：$PATH</h2><p>执行一个指令的时候，比如 <code>ls</code>，系统会依照<code>PATH</code>的设置去每个PATH定义的目录下搜寻文件名为ls的可执行文件，如果在PATH定义的目录中含有多个文件名为<code>ls</code>的可执行文件，那么先搜寻到的同名指令先被执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span><br><span class="hljs-comment"># 这个变量的内容由一堆目录所组成，每个目录中间用冒号（:）来隔开，每个目录是有顺序之分的</span><br>/home/test/.local/bin:/home/test/bin:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin<br></code></pre></td></tr></table></figure>

<h2 id="文件内容查询"><a href="#文件内容查询" class="headerlink" title="文件内容查询"></a>文件内容查询</h2><ul>
<li><p>cat ：由第一行开始显示文件内容</p>
</li>
<li><p>tac ：从最后一行开始显示（ tac 是 cat 倒着写）</p>
</li>
<li><p>nl ：显示的时候输出行号</p>
</li>
<li><p>more： 一页一页的显示文件内容，</p>
<ul>
<li><code>空格</code>：向下翻页</li>
<li><code>Enter</code>：向下翻一行</li>
<li><code>:f</code>：显示文件名和目前行数</li>
<li><code>b</code>：向上翻页</li>
<li><code>/字符串</code>：搜索字符串</li>
<li><code>q</code>：退出</li>
</ul>
</li>
<li><p>less：与 more 类似，比 more 更强大</p>
<ul>
<li><code>空格</code>：向下翻页</li>
<li><code>b</code>：向上翻页</li>
<li><code>/字符串</code>：搜索字符串</li>
<li><code>pagedown</code>：向下翻动一页</li>
<li><code>pageup</code>：向上翻动一页</li>
<li><code>/字符串</code>：向下搜索字串串</li>
<li><code>?字符串</code>：向上搜索字符串</li>
<li><code>n</code>：重复前一个搜索</li>
<li><code>N</code>：反向的重复前一个搜索</li>
<li><code>g</code>：前进到这个数据的第一行去</li>
<li><code>G</code>：前进到这个数据的最后一行去（注意大小写）</li>
<li><code>q</code>：离开less程序</li>
</ul>
</li>
<li><p>head：只显示前几行，不加参数默认显示前10行</p>
<ul>
<li>打印指定行数：<code>head [-n 数字] filename</code></li>
<li>打印除了最后行数：<code>head -n -10 filename</code></li>
</ul>
</li>
<li><p>tail： 只显示后几行，不加参数默认显示后10行</p>
<ul>
<li><code>tail [-n 数字] filename</code>：输出最后几行</li>
<li><code>tail -f filename</code>：持续监测文件并输出</li>
<li><code>tail -n +100 filename</code>：不知道文件有几行，只想列出100行以后的数据</li>
</ul>
<blockquote>
<p><strong>显示文件中间几行</strong></p>
<p>显示文件 11 到 20 行：head -n 20 &#x2F;etc&#x2F;man_db.conf | tail -n 10</p>
<p>带行号显示11到20行：cat &#x2F;etc&#x2F;man_db.conf | head -n 20 | tail -n 10</p>
<blockquote>
<p><strong>|</strong> 是管道符，表示前面的指令所输出的信息，交由后续的指令继续使用，所以tail不需要加文件名</p>
</blockquote>
</blockquote>
</li>
<li><p>od： 读取非纯文本文件内容</p>
<ul>
<li><p><code>echo password | od -t oCc</code></p>
</li>
<li><p>**<code>-t</code>**：指定输出格式：</p>
<p>**<code>o</code>**：输出八进制格式</p>
<p>**<code>C</code>**：输出字符形式，并显示 ASCII 码</p>
<p>**<code>c</code>**：输出 ASCII 字符，并在遇到不可打印字符时显示 <code>.</code></p>
</li>
</ul>
</li>
</ul>
<h2 id="修改文件时间或创建新文件：touch"><a href="#修改文件时间或创建新文件：touch" class="headerlink" title="修改文件时间或创建新文件：touch"></a>修改文件时间或创建新文件：touch</h2><p>通过<code>ls</code>可以看到每个文件在linux下面都会记录很多时间参数，有三个主要的变动时间</p>
<ul>
<li>modification time （mtime）：当文件的<strong>内容（不包括文件的属性或权限）</strong>变更时，会更新这个时间</li>
<li>status time （ctime）：当文件的<strong>状态（权限与属性）</strong>改变时，会更新这个时间</li>
<li>access time （atime）：当文件内容<strong>被读取（例如<code>cat</code> ）</strong>时，就会更新这个读取时间（access）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ; 表示多重指令，可以依次执行</span><br>[root@172-12-0-1 <span class="hljs-built_in">test</span>]# <span class="hljs-built_in">date</span>;\<br><span class="hljs-built_in">ls</span> -l /etc/man_db.conf;\<br><span class="hljs-built_in">ls</span> -l --time=atime /etc/man_db.conf;\<br><span class="hljs-built_in">ls</span> -l --time=ctime /etc/man_db.conf<br><span class="hljs-comment"># 当前时间</span><br>2024年 08月 13日 星期二 11:59:19 CST<br><span class="hljs-comment"># ls默认展示mtime</span><br>-rw-r--r--. 1 root root 5165 6月  30 2021 /etc/man_db.conf<br><span class="hljs-comment"># 读取时间</span><br>-rw-r--r--. 1 root root 5165 8月  12 13:47 /etc/man_db.conf<br><span class="hljs-comment"># 系统按安装时间点</span><br>-rw-r--r--. 1 root root 5165 7月  18 19:35 /etc/man_db.conf<br></code></pre></td></tr></table></figure>

<h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><ol>
<li>创建一个空文件</li>
<li>修改一个文件的<code>atime</code>和<code>mtime</code>，不能修改<code>ctime</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ <span class="hljs-built_in">touch</span> [-acdmt] filename<br><span class="hljs-comment"># 选项与参数：</span><br>-a：仅修订 access time<br>-c：仅修改文件的时间，若该文件不存在则不创建新文件<br>-d：后面可以接欲修订的日期而不用目前的日期，也可以使用 --<span class="hljs-built_in">date</span>=<span class="hljs-string">&quot;日期或时间&quot;</span><br>-m：仅修改 mtime<br>-t：后面可以接欲修订的时间而不用目前的时间，格式为[YYYYMMDDhhmm]<br></code></pre></td></tr></table></figure>

<h2 id="文件与目录的默认权限与隐藏权限"><a href="#文件与目录的默认权限与隐藏权限" class="headerlink" title="文件与目录的默认权限与隐藏权限"></a>文件与目录的默认权限与隐藏权限</h2><p>除了基本<code>r, w, x</code>权限外，在Linux传统的<code>Ext2/Ext3/Ext4</code>文件系统下，还可以设置其他的系统隐藏属性，这部份可使用<code>chattr</code>来设置，以<code>lsattr</code>来查看，最重要的属性就是可以设置其不可修改的特性（文件所有者也不能修改），这个属性是相当重要的，尤其是在安全机制上面（security）。</p>
<p>比较可惜的是，在 <code>CentOS 7.x</code> 后利用 xfs 作为默认文件系统，xfs 没有支持所有的 <code>chattr</code> 的参数。</p>
<h3 id="文件默认权限：umask"><a href="#文件默认权限：umask" class="headerlink" title="文件默认权限：umask"></a>文件默认权限：umask</h3><p>umask：在创建新文件和目录时，系统会默认使用哪些权限；通过从默认权限中减去，来限制文件和目录的权限。关于默认 <code>umask</code> 的设置可以参考 <code>/etc/bashrc</code> 这个文件的内容</p>
<p><strong>默认权限</strong>：</p>
<ul>
<li>文件的默认权限是 666（即 <code>rw-rw-rw-</code>），表示所有用户都具有读写权限</li>
<li>目录的默认权限是 777（即 <code>rwxrwxrwx</code>），表示所有用户都具有读、写、执行权限</li>
</ul>
<p><strong>umask</strong>：</p>
<ul>
<li><strong>umask</strong> 是一个掩码，它从默认权限中减去指定的权限</li>
<li>例如，如果 umask 设置为 <code>022</code>，则新创建的文件和目录的权限会从默认权限中减去 <code>022</code>，即：<ul>
<li>文件的权限会是 <code>644</code>（即 <code>rw-r--r--</code>），去掉了组和其他用户的写权限</li>
<li>目录的权限会是 <code>755</code>（即 <code>rwxr-xr-x</code>），去掉了组和其他用户的写权限</li>
</ul>
</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看当前 umask(0002)</span><br>[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ <span class="hljs-built_in">umask</span><br>0002<br>[root@172-12-0-1 ~]# <span class="hljs-built_in">umask</span><br>0022<br><br><span class="hljs-comment"># 符号类型显示(rwx)</span><br>[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ <span class="hljs-built_in">umask</span> -S<br><br><span class="hljs-comment"># 设置 umask 为 027</span><br>[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ <span class="hljs-built_in">umask</span> 027<br><br><span class="hljs-comment"># 新创建的文件权限为 640（666 - 027 = 640），目录权限为 750（777 - 027 = 750）</span><br>[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ <span class="hljs-built_in">touch</span> myfile<br>[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ <span class="hljs-built_in">mkdir</span> mydir<br>[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ <span class="hljs-built_in">ls</span> -l myfile mydir<br></code></pre></td></tr></table></figure>

<h3 id="文件隐藏权限"><a href="#文件隐藏权限" class="headerlink" title="文件隐藏权限"></a>文件隐藏权限</h3><p><code>chattr</code> 是一个 Linux 命令，用于更改文件和目录的属性。这些属性提供了额外的控制和保护机制，能够影响文件或目录的行为，尤其是在系统维护和安全方面。 <code>chattr</code> 命令的属性主要用于防止文件被修改、删除或重命名等操作。</p>
<p><strong>常用选项</strong></p>
<ul>
<li>**<code>+</code>**：添加一个或多个属性。</li>
<li>**<code>-</code>**：删除一个或多个属性。</li>
<li>**<code>=</code>**：设置属性，替换现有属性。</li>
</ul>
<p><strong>常见属性</strong></p>
<ul>
<li>**<code>A</code>**：存取此文件（或目录）时，存取时间 atime 将不会被修改，可避免 I&#x2F;O 较慢的机器过度的存取磁盘。（目前建议使用文件系统挂载参数处理这个项目）</li>
<li>**<code>S</code>**：一般文件是非同步写入磁盘的，加上 这个属性后进行任何文件的修改，会同步写入磁盘中</li>
<li>**<code>a</code>**：附加属性。文件只能被追加内容，不能被修改或删除（适用于文件），只有root 才能设置该属性</li>
<li>**<code>c</code>**：压缩属性。启用文件系统的压缩功能（适用于大文件，具体取决于文件系统），读取的时候将会自动解压缩</li>
<li>**<code>d</code>**：当 dump 程序被执行的时候，可使该文件（或目录）不会被 dump 备份</li>
<li>**<code>i</code>**：不可变属性。文件无法被修改、删除、重命名，也不能被创建链接（适用于文件），只有root 才能设置该属性</li>
<li>**<code>s</code>**：安全删除属性。删除文件时，会确保文件数据被完全擦除（适用于文件）</li>
<li>**<code>u</code>**：在文件被删除后，保留文件数据的备份（适用于文件）</li>
</ul>
<p>xfx文件系统仅支持**<code>AadiS</code>**这几个选项参数</p>
<h4 id="查看文件属性"><a href="#查看文件属性" class="headerlink" title="查看文件属性"></a>查看文件属性</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ lsattr filename<br></code></pre></td></tr></table></figure>

<h4 id="修改文件属性"><a href="#修改文件属性" class="headerlink" title="修改文件属性"></a><strong>修改文件属性</strong></h4><p><strong>1. 添加属性</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 将不可变属性添加到文件</span><br>[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ <span class="hljs-built_in">sudo</span> chattr +i filename<br></code></pre></td></tr></table></figure>

<p><strong>2. 删除属性</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">bash复制代码# 删除不可变属性<br>[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ <span class="hljs-built_in">sudo</span> chattr -i filename<br></code></pre></td></tr></table></figure>

<p><strong>3. 设置属性</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 设置附加属性</span><br>[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ <span class="hljs-built_in">sudo</span> chattr +a filename<br></code></pre></td></tr></table></figure>

<p><strong>常见使用场景</strong></p>
<ul>
<li><strong>保护重要文件</strong>：使用不可变属性保护关键系统文件或配置文件，防止意外修改或删除。</li>
<li><strong>增强安全性</strong>：使用 <code>chattr</code> 命令可以增强文件系统的安全性，特别是在关键系统文件和配置文件的管理中。</li>
</ul>
<h2 id="文件特殊权限：-SUID-SGID-SBIT"><a href="#文件特殊权限：-SUID-SGID-SBIT" class="headerlink" title="文件特殊权限： SUID, SGID, SBIT"></a>文件特殊权限： SUID, SGID, SBIT</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@172-12-0-1 ~]# <span class="hljs-built_in">ls</span> -ld /tmp; <span class="hljs-built_in">ls</span> -l /usr/bin/passwd<br>drwxrwxrwt. 11 root root 8192 8月  13 16:19 /tmp<br>-rwsr-xr-x. 1 root root 33600 4月   7 2020 /usr/bin/passwd<br></code></pre></td></tr></table></figure>

<p>注意这里的<code>s</code>和<code>t</code>，后面要考的</p>
<ul>
<li><p>Set SID</p>
<p>当 <code>s</code> 这个标志出现在<strong>文件</strong>所有者的 x 权限上时，被称为 Set UID，简称为 SUID 的特殊权限</p>
<ul>
<li>SUID 权限仅对二进制程序（binary program）有效</li>
<li>执行者对于该程序需要具有 x 的可执行权限</li>
<li>本权限仅在执行该程序的过程中有效（run-time）</li>
<li>执行者将具有该程序拥有者（owner）的权限</li>
</ul>
<p>比如 <code>passwd</code>这个命令，普通用户具有 <code>x</code>权限，所以也可以执行，但是无法读取</p>
</li>
<li><p>Set GID</p>
<ul>
<li><p>当 <code>s</code> 标志在<code>group</code>的 x 权限时，称为 Set GID，简称为SGID</p>
<ul>
<li>SGID 可以针对<strong>文件或目录</strong>来设置</li>
<li>作用在文件上时<ol>
<li>SGID 对二进制程序有用</li>
<li>以文件所属组的权限执行，而不是执行者的组权限</li>
</ol>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># /usr/bin/locate 会去搜索 /var/lib/mlocate/mlocate.db 这个文件的内容</span><br><span class="hljs-comment"># 使用 test这个帐号去执行locate 时，那 test将会取得slocate 群组的支持</span><br>[root@172-12-0-1 /]# ll /usr/bin/locate /var/lib/mlocate/mlocate.db<br>-rwx--s--x 1 root slocate   48552 5月  11 2019 /usr/bin/locate<br>-rw-r----- 1 root slocate 4093713 8月  14 09:33 /var/lib/mlocate/mlocate.db<br></code></pre></td></tr></table></figure>

<ul>
<li>作用在目录上时<ol>
<li>新创建的文件和子目录会继承该目录的组，而不是创建者的组</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Sticky Bit</p>
<ul>
<li>SBIT 只针对目录有效<ul>
<li>当使用者对于此目录具有 <code>w, x</code> 权限，亦即具有写入的权限时</li>
<li>当使用者在该目录下创建文件或目录时，仅有自己与 root 才有权力删除该文件（即无法删除他人的文件）</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@172-12-0-1 /]# <span class="hljs-built_in">ls</span> -dl /tmp/<br>drwxrwxrwt. 3 root root 85 8月  14 09:56 /tmp/<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="SUID-SGID-SBIT权限设置"><a href="#SUID-SGID-SBIT权限设置" class="headerlink" title="SUID&#x2F;SGID&#x2F;SBIT权限设置"></a>SUID&#x2F;SGID&#x2F;SBIT权限设置</h3><h4 id="权限数值表示"><a href="#权限数值表示" class="headerlink" title="权限数值表示"></a>权限数值表示</h4><ul>
<li><code>SUID</code>：4</li>
<li><code>SGID</code>：2</li>
<li><code>SBIT</code>：1</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>设置权限<code>-rwsr-xr-x</code></p>
<ul>
<li>数字模式，<code>chmod 4755 filename</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@172-12-0-1 /]# <span class="hljs-built_in">cd</span> /tmp<br>[root@172-12-0-1 /tmp]# <span class="hljs-built_in">touch</span> <span class="hljs-built_in">test</span><br><span class="hljs-comment"># 加入SUID 权限</span><br>[root@172-12-0-1 /tmp]# <span class="hljs-built_in">chmod</span> 4755 <span class="hljs-built_in">test</span><br>[root@172-12-0-1 /tmp]# ll <span class="hljs-built_in">test</span><br>-rwsr-xr-x 1 root root  0 8月  14 10:07 <span class="hljs-built_in">test</span><br><span class="hljs-comment"># 加入SUID/SGID 权限</span><br>[root@172-12-0-1 /tmp]# <span class="hljs-built_in">chmod</span> 6755 <span class="hljs-built_in">test</span><br>[root@172-12-0-1 /tmp]# ll <span class="hljs-built_in">test</span><br>-rwsr-sr-x 1 root root  0 8月  14 10:07 <span class="hljs-built_in">test</span><br><span class="hljs-comment"># 加入 SBIT 权限</span><br>[root@172-12-0-1 /tmp]# <span class="hljs-built_in">chmod</span> 1755 <span class="hljs-built_in">test</span><br>[root@172-12-0-1 /tmp]# ll <span class="hljs-built_in">test</span><br>-rwxr-xr-t 1 root root 0 8月  14 10:07 <span class="hljs-built_in">test</span><br><span class="hljs-comment"># 具有空的 SUID/SGID 权限</span><br>[root@172-12-0-1 /tmp]# <span class="hljs-built_in">chmod</span> 7666 <span class="hljs-built_in">test</span><br>[root@172-12-0-1 /tmp]# <span class="hljs-built_in">ls</span> -l <span class="hljs-built_in">test</span><br>-rwSrwSrwT 1 root root  0 8月  14 10:07 <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>最后一个为什么会出现大写的 S 与 T 呢？</p>
<p>因为 s 与 t都是取代 x 这个权限的，设置 7666 权限时user、group、others都没有x的权限，所以，这个 S, T 代表的就是没权限执行（文件所有者都没权限执行，其他人肯定不能用了）</p>
</blockquote>
<ul>
<li>符号模式<ul>
<li>SUID ： u+s</li>
<li>SGID ： g+s</li>
<li>SBIT  ： o+t</li>
</ul>
</li>
</ul>
<h2 id="文件查找：-locate"><a href="#文件查找：-locate" class="headerlink" title="文件查找： locate"></a>文件查找： locate</h2><ul>
<li>安装</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装lcoate</span><br>[root@172-12-0-1 ~]# yum install mlocate<br></code></pre></td></tr></table></figure>

<ul>
<li>更新数据库</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 根据 /etc/updatedb.conf 的设置去搜寻系统硬盘内的文件名，并更新 /var/lib/mlocate 内的数据库文件</span><br>[root@172-12-0-1 ~]# updatedb<br></code></pre></td></tr></table></figure>

<ul>
<li>查找文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在 /var/lib/mlocate 中查找</span><br>[root@172-12-0-1 ~]# locate filename<br></code></pre></td></tr></table></figure>

<h2 id="查看文件类型：-file"><a href="#查看文件类型：-file" class="headerlink" title="查看文件类型： file"></a>查看文件类型： file</h2><p>想要知道某个文件的基本数据，例如是属于 ASCII 或者是 data 文件、 binary，且其中有没有使用到动态函数库（share library）等，可以使用file命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ASCII 的纯文本文件</span><br>[root@172-12-0-1 ~]# file ~/.bashrc <br>/root/.bashrc: ASCII text<br><span class="hljs-comment"># 可执行文件的数据，包括这个文件的 suid 权限、相容于 Intel x86-64 等级的硬件平台，使用的是 Linux 核心 3.2.0 的动态函数库链接等</span><br>[root@172-12-0-1 ~]# file /usr/bin/passwd<br>/usr/bin/passwd: setuid ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, <span class="hljs-keyword">for</span> GNU/Linux 3.2.0, BuildID[sha1]=87e17c1d9b2e20d7e8aeab9115074375eec5e8e1, stripped<br><span class="hljs-comment"># data 文件</span><br>[root@172-12-0-1 ~]# file /var/lib/mlocate/mlocate.db<br>/var/lib/mlocate/mlocate.db: mlocate database, version 0, require visibility, root /<br></code></pre></td></tr></table></figure>

<h2 id="指令与文件的搜索"><a href="#指令与文件的搜索" class="headerlink" title="指令与文件的搜索"></a>指令与文件的搜索</h2><h3 id="指令文件名的搜索"><a href="#指令文件名的搜索" class="headerlink" title="指令文件名的搜索"></a>指令文件名的搜索</h3><ul>
<li>which：用于查找命令的可执行文件路径。它会输出在 <code>PATH</code> 环境变量中找到的第一个匹配命令的位置</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查找 ifconfig 执行文件</span><br>[root@172-12-0-1 ~]# <span class="hljs-built_in">which</span> ifconfig <br>/usr/sbin/ifconfig<br><br><span class="hljs-comment"># 查找 history 执行文件，发现找不到，是因为history是 bash 内置的指令，可以通过type搜索</span><br>[root@172-12-0-1 ~]# <span class="hljs-built_in">which</span> <span class="hljs-built_in">history</span> <br>/usr/bin/which: no <span class="hljs-built_in">history</span> <span class="hljs-keyword">in</span> (/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin)<br></code></pre></td></tr></table></figure>

<ul>
<li>type：提供更多的详细信息，包括命令的类型（内置命令、别名、函数、外部命令等）。它不仅显示命令的路径，还可以显示命令的类型和其他相关信息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@172-12-0-1 ~]# <span class="hljs-built_in">type</span> <span class="hljs-built_in">history</span> <br><span class="hljs-built_in">history</span> 是 shell 内建<br></code></pre></td></tr></table></figure>

<h3 id="文件文件名搜索"><a href="#文件文件名搜索" class="headerlink" title="文件文件名搜索"></a>文件文件名搜索</h3><ul>
<li>whereis：由一些特定的目录中寻找文件文件名，可以通过 <code>whereis -l</code>来查看搜索哪些目录</li>
<li>locate &#x2F; updatedb：[Ctrl点击跳转到locate](#文件查找： locate)</li>
<li>find：直接搜索硬盘，速度慢，但功能强大，使用 <code>man find</code>查看更多用法</li>
</ul>
<h1 id="五、Linux磁盘与文件系统管理"><a href="#五、Linux磁盘与文件系统管理" class="headerlink" title="五、Linux磁盘与文件系统管理"></a>五、Linux磁盘与文件系统管理</h1><p>Linux 最传统的磁盘文件系统（filesystem）使用的是 EXT2，文件系统创建在磁盘上边，前面已经有说过磁盘的基本组成了（<a href="#%E7%A1%AC%E7%9B%98%E5%92%8C%E5%82%A8%E5%AD%98%E8%AE%BE%E5%A4%87">跳转磁盘</a>），本章重点在于 inode, block 还有 superblock 等文件系统的基本部分。</p>
<blockquote>
<p>为什么磁盘分区完毕后还需要进行格式化（format），之后操作系统才能够使用这个文件系统？</p>
<p>这是因为每种操作系统所设置的文件属性&#x2F;权限并不相同，为了存放这些文件所需的数据，因此就需要将分区进行格式化，以成为操作系统能够利用的文件系统格式（filesystem）</p>
</blockquote>
<blockquote>
<p>传统的一个分区只能被格式化为一个文件系统，但由于新技术的应用，LVM与软件磁盘阵列（software raid）技术可以将一个分区格式化为多个文件系统，也能够将多个分区合成一个文件系统。所以目前我们在格式化时已经不再说成针对 <code>partition</code> 来格式化了，通常可以称呼一个可被挂载的数据为一个文件系统而不是一个分区。</p>
</blockquote>
<p>文件数据除了文件实际内容外，还有有非常多的属性，例如 Linux 操作系统的文件权限（rwx）与文件属性（拥有者、群组、时间参数等）。文件系统通常会将这两部份的数据分别存放在不同的区块，<strong>权限与属性</strong>放置到 <code>inode</code> 中，<strong>实际数据</strong>则放置到 <code>data block</code> 区块中。另外，还有一个超级区块（<code>superblock</code>）会记录整个文件系统的整体信息，包括 inode 与 block 的总量、使用量、剩余量等。</p>
<p>每个 <code>inode</code> 与 <code>block</code> 都有编号，这三个数据的意义可以简略说明如下：</p>
<ul>
<li>superblock：记录此 <code>filesystem</code> 的整体信息，包括<code>inode/block</code>的总量、使用量、剩余量，以及文件系统的格式与相关信息等</li>
<li>inode：记录文件的属性，一个文件占用一个inode，同时记录此文件的数据所在的 <code>block</code>号码</li>
<li>block：实际记录文件的内容，若文件太大时，会占用多个 block</li>
</ul>
<p>由inode可以找到此文件的数据存放的block块，这种数据存取方式称为<strong>索引式文件系统</strong>（indexed allocation）</p>
<blockquote>
<p>U盘的文件系统一般是FAT格式，FAT 这种格式的文件系统并没有 inode 存在，所以 FAT 没有办法将这个文件的所有 block 在一开始就读取出来。每个 block 号码都记录在前一个 block 当中（1-&gt;7-&gt;4-&gt;15），如果同一个文件数据写入的 block 分散的太厉害，则磁头将无法在磁盘转一圈就读到所有的数据，因此磁盘就会多转好几圈才能完整的读取到这个文件的内容。</p>
<p>所以需要隔三岔五的<strong>磁盘重组</strong>一下</p>
<p>磁盘重组（也称为磁盘整理或碎片整理）是一个用于优化存储设备性能的过程。在此过程中，文件系统会重新组织存储在磁盘上的文件，使得文件的各个部分尽可能地连续存储，以减少磁头移动的时间，从而提高磁盘读写效率。</p>
</blockquote>
<h2 id="Ext2文件系统-inode"><a href="#Ext2文件系统-inode" class="headerlink" title="Ext2文件系统(inode)"></a>Ext2文件系统(inode)</h2><p>文件系统一开始就将 inode 与 block 规划好了，除非重新格式化（或者利用 <code>resize2fs</code> 等指令变更文件系统大小），否则 inode 与 block 固定后就不再变动。但是如果我的文件系统高达数百GB时，将所有的 inode 与 block 放置在一起将是很不智的决定，因为 inode 与 block 的数量太庞大，不容易管理。</p>
<p>因此 Ext2 文件系统在格式化的时候基本上是区分为多个<strong>区块群组</strong>（<code>blockgroup</code>）的，每个区块群组都有<strong>独立</strong>的 inode&#x2F;block&#x2F;superblock 系统，如下图所示</p>
<img src="https://imgos.cn/2024/08/15/66bd629e6cf67.png" alt="图片描述" width="600" height="300">

<p>在整体的规划当中，文件系统最前面有一个开机扇区（boot sector），这个开机扇区可以安装开机管理程序，这是个非常重要的设计，我们能够将不同的开机管理程序安装到个别的文件系统最前端，而不用覆盖整颗磁盘唯一的 MBR，这样才能够制作出多重开机的环境。</p>
<h2 id="Data-Block（数据区块）"><a href="#Data-Block（数据区块）" class="headerlink" title="Data Block（数据区块）"></a>Data Block（数据区块）</h2><p>用来放置<strong>文件内容</strong>，在 Ext2 文件系统中所支持的 block 大小有 1K、2K及 4K 三种。在格式化时 block 的大小就固定了，且每个 block 都有编号，以方便 inode的记录。不过要注意的是，由于 block 大小的差异，会导致该文件系统能够支持的最大磁盘容量与最大单一文件大小并不相同</p>
<table>
<thead>
<tr>
<th>Block 大小</th>
<th>1KB</th>
<th>2KB</th>
<th>4KB</th>
</tr>
</thead>
<tbody><tr>
<td>最大单一文件限制</td>
<td>16GB</td>
<td>256GB</td>
<td>2TB</td>
</tr>
<tr>
<td>最大文件系统总容量</td>
<td>2TB</td>
<td>8TB</td>
<td>16TB</td>
</tr>
</tbody></table>
<blockquote>
<p>需要注意的是，虽然 Ext2 已经能够支持大于 2GB 以上的单一文件大小，不过某些应用程序依然使用旧的限制，也就是说，某些程序只能够识别到小于 2GB 以下的文件而已，这就跟文件系统无关了</p>
</blockquote>
<ul>
<li>Ext2 文件系统的 block 限制<ul>
<li>原则上，block 的大小与数量在格式化完就不能够再改变了（除非重新格式化）</li>
<li>每个 block 内最多只能够放置一个文件的数据<ul>
<li>如果文件大于 block 的大小，则一个文件会占用多个 block 数量</li>
<li>若文件小于 block ，则该 block 的剩余容量就不能够再被使用了（磁盘空间会浪费）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>基于以上的限制，如果block过大（4k），但是文件都非常小，可能会产生一些容量的浪费；如果block过小， 文件过大，可能导致不良的读写性能。</p>
<blockquote>
<p><strong>假设你的Ext2文件系统使用 4K block ，而该文件系统中有 10000 个小文件，每个文件大小均为 50Bytes，请问此时你的磁盘浪费多少容量？</strong></p>
<p>由于 Ext2 文件系统中一个 block仅能容纳一个文件，因此每个 block 会浪费 <code>4096 - 50 = 4046 （Byte）</code>，系统中总共有一万个小文件，所有文件大小为：<code>50 （Bytes） x 10000 = 488.3KBytes</code>，但此时浪费的容量为：<code>4046 （Bytes） x 10000 = 38.6MBytes</code></p>
<p>不到 1MB 的总文件大小却浪费将近 40MB 的容量，且文件越多将造成越多的磁盘容量浪费</p>
</blockquote>
<blockquote>
<p>既然大的 block 可能会产生较严重的磁盘容量浪费，那么是否可以将 block 大小定为1K 即可？</p>
<p>如果 block 较小的话，大型文件将会占用数量更多的 block ，而 inode 也要记录更多的 block 号码，此时将可能导致文件系统不良的读写性能</p>
</blockquote>
<h2 id="inode-table-（inode-表格）"><a href="#inode-table-（inode-表格）" class="headerlink" title="inode table （inode 表格）"></a>inode table （inode 表格）</h2><p>inode 的内容在记录文件的属性以及该文件实际数据是放置在哪几号 block 内</p>
<p>基本上，inode 记录的文件数据至少有下面这些：</p>
<ul>
<li>文件类型：文件、目录、符号链接等</li>
<li>文件权限：权限位（读、写、执行）以及文件的所有者和组的权限</li>
<li>硬链接计数：指示有多少硬链接指向该 <code>inode</code></li>
<li>文件所有者：文件的所有者的用户 ID</li>
<li>文件组：文件所属的组的组ID</li>
<li>文件大小；文件的字节数</li>
<li>时间戳：创建时间(ctime)、修改时间(mtime)、访问时间(atime)</li>
<li>数据块指针：指向文件数据块的指针或索引。这些指针存储了文件实际数据的位置</li>
<li><strong>i-node number</strong>：在文件系统中 <code>inode</code> 的唯一标识符</li>
</ul>
<p>inode 的数量与大小也是在<strong>格式化时就已经固定</strong>了，除此之外 inode 还有以下特色：</p>
<ul>
<li>每个 inode 大小均固定为 128 Bytes （新的 ext4 与 xfs 可设置到 256 Bytes）</li>
<li>每个文件都仅会占用一个 inode 而已<ul>
<li>文件系统能够创建的文件数量与 inode 的数量有关</li>
<li>系统读取文件时需要先找到 inode，并分析 inode 所记录的权限与使用者是否符合，若符合才开始读取 block 的内容</li>
</ul>
</li>
</ul>
<blockquote>
<p> inode 要记录的数据非常多，却只有 128Bytes 而已，而 inode 记录一个 block 号码要花掉 4Byte ，假设我一个文件有 400MB 且每个 block 为 4K 时，那么至少也要十万个 block 号码来记录，inode 哪有这么多空间来记录这些信息？</p>
<p>为此系统将 inode 记录 block 号码的区域定义为12个直接，一个间接, 一个二级间接与一个三级间接记录区</p>
</blockquote>
<p>文件数据块的指针。<code>i_block</code> 数组的前 12 个条目是直接块指针，指向文件数据的实际位置。接下来的 3 个条目分别是一级间接、二级间接和三级间接块指针。这些间接块指针用于支持较大的文件。</p>
<ul>
<li><strong>直接块指针</strong>：指向文件数据的直接位置</li>
<li><strong>一级间接块指针</strong>：指向一个块，其中包含更多的直接块指针</li>
<li><strong>二级间接块指针</strong>：指向一个块，其中包含一级间接块的指针</li>
<li><strong>三级间接块指针</strong>：指向一个块，其中包含二级间接块的指针</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// ext2文件系统中的 inode 结构</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext2_inode</span> &#123;</span><br>    __le16 i_mode;           <span class="hljs-comment">// 文件类型和权限</span><br>    __le16 i_uid;            <span class="hljs-comment">// 用户 ID</span><br>    __le32 i_size;           <span class="hljs-comment">// 文件大小（字节数）</span><br>    __le32 i_atime;          <span class="hljs-comment">// 访问时间（从 1970 年 1 月 1 日开始的秒数）</span><br>    __le32 i_ctime;          <span class="hljs-comment">// 创建时间（从 1970 年 1 月 1 日开始的秒数）</span><br>    __le32 i_mtime;          <span class="hljs-comment">// 修改时间（从 1970 年 1 月 1 日开始的秒数）</span><br>    __le32 i_dtime;          <span class="hljs-comment">// 删除时间（从 1970 年 1 月 1 日开始的秒数）</span><br>    __le16 i_gid;            <span class="hljs-comment">// 组 ID</span><br>    __le16 i_links_count;    <span class="hljs-comment">// 硬链接计数</span><br>    __le32 i_blocks;         <span class="hljs-comment">// 文件数据块数量（以 512 字节为单位）</span><br>    __le32 i_flags;          <span class="hljs-comment">// 文件属性标志（如是否为只读文件）</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>            __le32 i_block[<span class="hljs-number">15</span>]; <span class="hljs-comment">// 数据块指针（包括直接、间接和双重间接指针）</span><br>        &#125; linux2;<br>    &#125; osd2;<br>    __le32 i_reserved1;      <span class="hljs-comment">// 保留字段</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 假设有一个 ext2 文件系统中的 inode 结构如下</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext2_inode</span> <span class="hljs-title">inode</span>;</span><br>inode.i_mode = <span class="hljs-number">0100644</span>;   <span class="hljs-comment">// 常规文件，所有者读写，组和其他用户只读</span><br>inode.i_uid = <span class="hljs-number">1000</span>;       <span class="hljs-comment">// 用户 ID</span><br>inode.i_size = <span class="hljs-number">4096</span>;      <span class="hljs-comment">// 文件大小（字节数）</span><br>inode.i_atime = <span class="hljs-number">1616161616</span>; <span class="hljs-comment">// 访问时间（时间戳）</span><br>inode.i_ctime = <span class="hljs-number">1616161616</span>; <span class="hljs-comment">// 创建时间（时间戳）</span><br>inode.i_mtime = <span class="hljs-number">1616161616</span>; <span class="hljs-comment">// 修改时间（时间戳）</span><br>inode.i_dtime = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 删除时间（如果文件未删除，则为 0）</span><br>inode.i_gid = <span class="hljs-number">1000</span>;       <span class="hljs-comment">// 组 ID</span><br>inode.i_links_count = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 硬链接计数</span><br>inode.i_blocks = <span class="hljs-number">8</span>;       <span class="hljs-comment">// 占用的块数</span><br>inode.i_flags = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 文件属性标志</span><br><span class="hljs-comment">// 假设数据块大小为 512 字节</span><br><span class="hljs-comment">// 直接块指针</span><br>inode.i_block[<span class="hljs-number">0</span>] = <span class="hljs-number">1234</span>;  <span class="hljs-comment">// 数据块指针</span><br>inode.i_block[<span class="hljs-number">1</span>] = <span class="hljs-number">1235</span>;  <span class="hljs-comment">// 数据块指针</span><br><span class="hljs-comment">// 一级间接块指针</span><br>inode.i_block[<span class="hljs-number">12</span>] = <span class="hljs-number">1236</span>; <span class="hljs-comment">// 指向包含更多数据块指针的块</span><br><span class="hljs-comment">// 二级间接块指针</span><br>inode.i_block[<span class="hljs-number">13</span>] = <span class="hljs-number">1237</span>; <span class="hljs-comment">// 指向包含一级间接块指针的块</span><br><span class="hljs-comment">// 三级间接块指针</span><br>inode.i_block[<span class="hljs-number">14</span>] = <span class="hljs-number">1238</span>; <span class="hljs-comment">// 指向包含二级间接块指针的块</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>这样子 inode 能够指定多少个 block 呢？</p>
<p>以较小的 1K block 来说明好了，可以指定的情况如下：</p>
<p>12 个直接指向： 12 * 1K&#x3D;12K，由于是直接指向，所以总共可记录 12 笔记录</p>
<p>间接： 256 * 1K&#x3D;256K，每笔 block 号码的记录会花去 4Bytes， 1K 的大小能够记录256 笔记录</p>
<p>双间接： 256 * 256 * 1K&#x3D;256 <sup>2</sup> K ，一层 block 会指定 256 个第二层，每个第二层可以指定256 个号码</p>
<p>三间接： 256 * 256 * 256 * 1K&#x3D;256<sup>3</sup> K，第一层 block 会指定 256 个第二层，每个第二层可以指定 256 个第三层，每个第三层可以指定 256 个号码</p>
<p>总额： 12 + 256 + 256<sup>2</sup> + 256<sup>3</sup>（K） &#x3D; 16GB </p>
<p>当文件系统将 block 格式化为 1K 大小时，能够容纳的最大文件为 16GB， 跟前面表格[跳转](#Data Block（数据区块）)结果差不多。但这个方法不能用在 2K 及 4K block 大小的计算中，因为大于 2K 的 block 将会受到 Ext2 文件系统本身的限制，所以计算的结果会不太符合。</p>
</blockquote>
<h2 id="Superblock（超级区块）"><a href="#Superblock（超级区块）" class="headerlink" title="Superblock（超级区块）"></a>Superblock（超级区块）</h2><p>Superblock 是记录整个 <code>filesystem</code> 相关信息的地方，没有 Superblock ，就没有这个filesystem 了</p>
<p>记录的信息主要有：</p>
<ul>
<li><p>block 与 inode 的总量</p>
</li>
<li><p>未使用与已使用的 inode &#x2F; block 数量</p>
</li>
<li><p>block 与 inode 的大小（block 为 1, 2, 4K，inode 为 128Bytes 或 256Bytes）</p>
</li>
<li><p>filesystem 的挂载时间、最近一次写入数据的时间、最近一次检验磁盘（fsck）的时间等文件系统的相关信息</p>
</li>
<li><p>一个 <code>valid bit</code> 数值，若此文件系统已被挂载，则 valid bit 为 0 ，若未被挂载，则 valid bit为 1 。</p>
</li>
</ul>
<p>Superblock 非常重要，因为文件系统的基本信息都写在这里，superblock 的大小一般为 1024Bytes（<code>dumpe2fs</code>指令），此外，每个 <code>block group</code> 都可能含有 superblock ！事实上除了第一个 <code>block group</code> 含有 superblock，后续的 block group 不一定含有 superblock ，而若含有 superblock 则该 superblock主要是做为第一个 block group 内 superblock 的<strong>备份</strong>，这样做是为了 <code>superblock</code> 的救援。</p>
<h2 id="Filesystem-Description-（文件系统描述说明）"><a href="#Filesystem-Description-（文件系统描述说明）" class="headerlink" title="Filesystem Description （文件系统描述说明）"></a>Filesystem Description （文件系统描述说明）</h2><p>这个区段可以描述每个 <code>block group</code> 的开始与结束的 block 号码，以及说明每个区段（superblock, bitmap, inodemap, data block）分别介于哪一个 block 号码之间。<code>dumpe2fs指令观察</code></p>
<h2 id="block-bitmap-（区块对照表）"><a href="#block-bitmap-（区块对照表）" class="headerlink" title="block bitmap （区块对照表）"></a>block bitmap （区块对照表）</h2><p>从 block bitmap 当中可以知道哪些 block 是空的，系统就能够快速的找到可使用的空间来处置文件。同样的，如果删除某些文件时，那么那些文件原本占用的 block 号码就要释放，此时在 block bitmap 当中对应到该 block 号码的标志就要修改为<code>未使用中</code>，这就是bitmap 的功能。</p>
<h2 id="inode-bitmap-（inode-对照表）"><a href="#inode-bitmap-（inode-对照表）" class="headerlink" title="inode bitmap （inode 对照表）"></a>inode bitmap （inode 对照表）</h2><p>这个与 block bitmap 是类似的功能，只是 block bitmap 记录的是使用与未使用的 block号码，而 inode bitmap 是记录使用与未使用的 inode 号码</p>
<blockquote>
<p>  dumpe2fs：查询 Ext 家族 superblock 信息的指令</p>
<p>blkid：显示目前系统有被格式化的设备</p>
</blockquote>
<h2 id="文件系统与目录树的关系"><a href="#文件系统与目录树的关系" class="headerlink" title="文件系统与目录树的关系"></a>文件系统与目录树的关系</h2><p>在 Linux 系统下，每个文件（不管是一般文件还是目录文件）都会占用一个 <code>inode</code> ，且可依据文件内容的大小来分配多个 <code>block</code> 给该文件使用。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>在 Linux 下的文件系统创建一个目录时，文件系统会分配一个 inode 与至少一块 block给该目录。其中，inode 记录该目录的相关权限与属性，并记录分配到的那块 block 号码；而 block 则记录在这个目录下的文件名与该文件名占用的 inode 号码数据。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看文件的inode</span><br>[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ <span class="hljs-built_in">ls</span> -i -al<br>总用量 52<br> 33566006 drwx------   5 <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span>     183 8月  10 14:56 .<br>      138 drwxr-xr-x.  4 root root      29 7月  31 10:16 ..<br> 35194599 -rw-------   1 <span class="hljs-built_in">test</span> docker 16454 8月  14 10:49 .bash_history<br> ...<br></code></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># block的大小都是 1024 的倍数，因为每个 block 的数量都是 1K, 2K, 4K</span><br>[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ ll -d / /boot /usr/sbin /proc /sys<br>dr-xr-xr-x.  24 root root  4096 7月  30 17:11 /<br>dr-xr-xr-x.   6 root root  4096 7月  18 19:54 /boot<br>dr-xr-xr-x  236 root root     0 8月   2 16:03 /proc  <span class="hljs-comment">#  /proc不占磁盘容量</span><br>dr-xr-xr-x   13 root root     0 8月   2 16:03 /sys<br>dr-xr-xr-x.   2 root root 12288 8月   2 15:25 /usr/sbin<br></code></pre></td></tr></table></figure>

<p>由上面的结果可以发现目录并不是只占用一个 block 而已，在目录下面的文件数如果太多而导致一个 block 无法容纳下所有的文件名与 inode 对照表时，Linux 会给予该目录多一个 block 来继续记录相关的数据。</p>
<blockquote>
<p>在 Linux 下的 ext2 创建一个一般文件时， ext2 会分配一个 inode 与相对于该文件大小的 block 数量给该文件。例如：假设我的一个 block 为 4 KBytes ，我要创建一个 100KBytes 的文件，系统将分配一个 inode 与 25 个 block 来储存该文件，但 inode 仅有 12 个直接指向，因此还要多一个 block 来作为区块号码的记录。</p>
</blockquote>
<h3 id="目录树读取"><a href="#目录树读取" class="headerlink" title="目录树读取"></a>目录树读取</h3><p>inode 本身并不记录文件名，文件名的记录是在<strong>目录的 block</strong> 当中（前面提到**<code>新增/删除/更改文件名</code>与目录的 <code>w</code> 权限有关**），因此要读取某个文件时，就务必会经过目录的 inode 与 block ，然后才能够找到那个待读取文件的 inode 号码，最终才会读到正确的文件的 block 内的数据。</p>
<p>由于目录树是由根目录开始读起，因此系统通过挂载的信息可以找到挂载点的 inode 号码，此时就能够得到根目录的 inode 内容，并依据该 inode 读取根目录的 block 内的文件名数据，再一层一层的往下读到正确的文件名。</p>
<h2 id="EXT2-EXT3-EXT4-文件的存取与日志式文件系统的功能"><a href="#EXT2-EXT3-EXT4-文件的存取与日志式文件系统的功能" class="headerlink" title="EXT2&#x2F;EXT3&#x2F;EXT4 文件的存取与日志式文件系统的功能"></a>EXT2&#x2F;EXT3&#x2F;EXT4 文件的存取与日志式文件系统的功能</h2><p>新建一个文件或目录时，就需要 block bitmap 及 inode bitmap 的帮忙了</p>
<p>假设我们想要新增一个文件，此时文件系统的行为是：</p>
<ol>
<li>先确定使用者对于新增文件的目录是否具有 <code>w 与 x</code> 的权限，若有的话才能新增</li>
<li>根据 inode bitmap 找到没有使用的 inode 号码，并将新文件的权限&#x2F;属性写入</li>
<li>根据 block bitmap 找到没有使用中的 block 号码，并将实际的数据写入 block 中，且更新 inode 的 block 指向数据</li>
<li>将刚刚写入的 inode 与 block 数据同步更新 inode bitmap 与 block bitmap，并更新superblock 的内容</li>
</ol>
<p>一般来说，我们将 inode table 与 data block 称为<strong>数据存放区域</strong>，至于其他例如 superblock、block bitmap 与 inode bitmap 等区段被称为 <strong><code>metadata</code></strong> （中介数据），因为 superblock,inode bitmap 及 block bitmap 的数据是经常变动的，每次新增、移除、编辑时都可能会影响到这三个部分的数据，因此才被称为中介数据。</p>
<h3 id="数据的不一致（Inconsistent）状态"><a href="#数据的不一致（Inconsistent）状态" class="headerlink" title="数据的不一致（Inconsistent）状态"></a>数据的不一致（Inconsistent）状态</h3><p>一般情况下，上述的新增动作当然可以顺利的完成。但是如果你的文件在写入文件系统时，因为不知名原因导致<strong>系统中断</strong>（例如突然的停电啊、系统核心发生错误等发生时），导致写入的数据仅有 inode table 及 data block 而已，最后一个同步更新中介数据的步骤并没有做完，此时就会发生 metadata 的内容与实际数据存放区产生<strong>不一致</strong>（Inconsistent）的情况了。</p>
<p>在早期的 Ext2 文件系统中，如果发生这个问题，那么系统在重新开机的时候，就会借由 Superblock 当中记录的 valid bit （是否有挂载）与 filesystemstate （clean 与否）等状态来判断是否强制进行数据一致性的检查（<code>e2fsck</code>指令）</p>
<p>不过，这个检查要针对 metadata 区域与实际数据存放区来进行比对，得要搜索整个 filesystem，这样的检查真的很费时，这也就造成后来所谓日志式文件系统的兴起了。</p>
<h3 id="日志式文件系统（Journaling-filesystem）"><a href="#日志式文件系统（Journaling-filesystem）" class="headerlink" title="日志式文件系统（Journaling filesystem）"></a>日志式文件系统（Journaling filesystem）</h3><p>为了避免上述提到的文件系统不一致的情况发生，前辈们想到一个方式：如果在我们的 filesystem 当中规划出一个区块，该区块专门记录写入或修订文件时的步骤，就可以简化一致性检查的步骤了，也就是说：</p>
<ol>
<li>预备：当系统要写入一个文件时，会先在日志记录区块中记录某个文件准备要写入的信息</li>
<li>实际写入：开始写入文件的权限与数据，开始更新 metadata 的数据</li>
<li>结束：完成数据与 metadata 的更新后，在日志记录区块当中完成该文件的纪录</li>
</ol>
<p>在这样的程序中，万一数据的纪录过程当中发生了问题，我们的系统只要去检查日志记录区块，就可以知道哪个文件发生了问题，针对该问题来做一致性的检查即可，而不必针对整块 filesystem 去检查，这样就可以做到快速修复 filesystem。</p>
<h2 id="Linux-文件系统的运行"><a href="#Linux-文件系统的运行" class="headerlink" title="Linux 文件系统的运行"></a>Linux 文件系统的运行</h2><p>知道了目录树与文件系统的关系以及所有的数据要载入到内存后 CPU 才能对该数据进行处理。如果你频繁编辑一个大文件，在编辑的过程中又频繁的要系统来写入到磁盘中，由于磁盘写入的速度要比内存慢很多，时间都耗在等待磁盘的写入&#x2F;读取上。</p>
<p>为了解决这个问题，Linux 通过一个称为<strong>非同步处理（asynchronously）</strong>的方式：当系统载入一个文件到内存后，如果该文件没有被改动过，则在内存区段的文件数据会被标记为干净（<strong>clean</strong>）的。但如果内存中的文件数据被更改过了，此时该内存中的数据会被标记为脏的（<strong>Dirty</strong>）。此时所有的动作都还在<strong>内存</strong>中执行，并没有写入到磁盘中，系统会不定时的将内存中设置为<code>Dirty</code>的数据写回磁盘，以保持磁盘与内存数据的一致性。也可以使用 <code>sync</code>指令来手动写入磁盘。</p>
<p>内存的速度要比磁盘快的多，如果能够将常用的文件放置到内存当中，就能增加系统性能。</p>
<p>因此 Linux 系统上面文件系统与内存有非常大的关系：</p>
<ul>
<li>系统会将常用的文件数据放置到<strong>内存的缓冲区</strong>，以加速文件系统的读&#x2F;写</li>
<li>可以手动使用 sync 来强迫内存中设置为 Dirty 的文件回写到磁盘中</li>
<li>若正常关机时，关机指令会主动调用 sync 来将内存的数据回写入磁盘内</li>
<li>但若不正常关机（如跳电、死机或其他不明原因），由于数据尚未回写到磁盘内，因此重新开机后可能会花很多时间在进行磁盘检验，甚至可能导致文件系统的损毁（非磁盘损毁）</li>
</ul>
<h2 id="挂载点的意义（mount-point）"><a href="#挂载点的意义（mount-point）" class="headerlink" title="挂载点的意义（mount point）"></a>挂载点的意义（mount point）</h2><p>每个 <code>filesystem</code> 都有独立的 inode &#x2F; block &#x2F; superblock 等信息，这个文件系统要能够链接到目录树才能被使用。<strong>将文件系统与目录树结合的动作</strong>称为挂载。<strong>挂载点一定是目录</strong>，该目录为进入该文件系统的入口。因此并不是任何文件系统都能使用，必须要<strong>挂载</strong>到目录树的某个目录后，才能够使用该文件系统</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@172-12-0-1 ~]# <span class="hljs-built_in">ls</span> -lid / /boot /home<br>128 dr-xr-xr-x. 24 root root 4096 7月  30 17:11 /<br>128 dr-xr-xr-x.  6 root root 4096 7月  18 19:54 /boot<br>138 drwxr-xr-x.  4 root root   29 7月  31 10:16 /home<br></code></pre></td></tr></table></figure>

<p>由于 XFS filesystem 最顶层目录的 inode 一般为 128 号，可以发现 &#x2F;、&#x2F;boot、&#x2F;home 为三个不同的 filesystem（每一行的文件属性并不相同，且三个目录的挂载点也均不相同）</p>
<p>从使用文件系统的观点来看，同一个 filesystem 的某个 inode 只会对应到一个文件内容而已（一个文件占用一个 inode ），因此可以通过判断 inode 号码来确认不同文件名是否为相同的文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@172-12-0-1 /]# <span class="hljs-built_in">ls</span> -ild /  /.  /..<br>128 dr-xr-xr-x. 24 root root 4096 7月  30 17:11 /<br>128 dr-xr-xr-x. 24 root root 4096 7月  30 17:11 /.<br>128 dr-xr-xr-x. 24 root root 4096 7月  30 17:11 /..<br></code></pre></td></tr></table></figure>

<p>上面的信息中由于挂载点均为 &#x2F; ，因此三个文件均在同一个 filesystem 内，而这三个文件的 inode 号码均为 128 号，因此这三个文件名都指向同一个 inode 号码，所以这三个文件是完全一样的。</p>
<h2 id="其他-Linux-支持的文件系统与-VFS"><a href="#其他-Linux-支持的文件系统与-VFS" class="headerlink" title="其他 Linux 支持的文件系统与 VFS"></a>其他 Linux 支持的文件系统与 VFS</h2><p>常见的支持文件系统有：</p>
<ul>
<li><p>传统文件系统：ext2 &#x2F; minix &#x2F; MS-DOS &#x2F; FAT（用 vfat 模块）&#x2F; iso9660 （光盘）等</p>
</li>
<li><p>日志式文件系统： ext3 &#x2F;ext4 &#x2F; ReiserFS &#x2F; Windows’ NTFS &#x2F; IBM’s JFS &#x2F; SGI’s XFS &#x2F;ZFS</p>
</li>
<li><p>网络文件系统： NFS &#x2F; SMBFS</p>
</li>
<li><p>查看你的 Linux 支持的文件系统有哪些</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@172-12-0-1 /]# <span class="hljs-built_in">ls</span> -l /lib/modules/$(<span class="hljs-built_in">uname</span> -r)/kernel/fs<br>总用量 20<br>-rw-r--r--. 1 root root 7792 12月 22 2021 binfmt_misc.ko.xz<br>drwxr-xr-x. 2 root root   30 7月  18 19:35 cachefiles<br>drwxr-xr-x. 2 root root   24 7月  18 19:35 ceph<br>drwxr-xr-x. 2 root root   24 7月  18 19:35 cifs<br>drwxr-xr-x. 2 root root   26 7月  18 19:35 cramfs<br>drwxr-xr-x. 2 root root   23 7月  18 19:35 dlm<br>drwxr-xr-x. 2 root root   24 7月  18 19:35 ext4<br>drwxr-xr-x. 2 root root   60 7月  18 19:35 fat<br>drwxr-xr-x. 2 root root   27 7月  18 19:35 fscache<br>drwxr-xr-x. 2 root root   46 7月  18 19:35 fuse<br>drwxr-xr-x. 2 root root   24 7月  18 19:35 gfs2<br>drwxr-xr-x. 2 root root   25 7月  18 19:35 isofs<br>drwxr-xr-x. 2 root root   24 7月  18 19:35 jbd2<br>drwxr-xr-x. 2 root root   25 7月  18 19:35 lockd<br>-rw-r--r--. 1 root root 4900 12月 22 2021 mbcache.ko.xz<br>drwxr-xr-x. 5 root root  120 7月  18 19:35 nfs<br>drwxr-xr-x. 2 root root   46 7月  18 19:35 nfs_common<br>drwxr-xr-x. 2 root root   24 7月  18 19:35 nfsd<br>drwxr-xr-x. 2 root root 4096 7月  18 19:35 nls<br>drwxr-xr-x. 2 root root   27 7月  18 19:35 overlayfs<br>drwxr-xr-x. 2 root root   27 7月  18 19:35 pstore<br>drwxr-xr-x. 2 root root   28 7月  18 19:35 squashfs<br>drwxr-xr-x. 2 root root   23 7月  18 19:35 udf<br>drwxr-xr-x. 2 root root   23 7月  18 19:35 xfs<br></code></pre></td></tr></table></figure>

<ul>
<li>系统目前已载入到内存中支持的文件系统</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@172-12-0-1 /]# <span class="hljs-built_in">cat</span> /proc/filesystems<br>nodev	sysfs<br>nodev	tmpfs<br>nodev	bdev<br>nodev	proc<br>nodev	cgroup<br>nodev	cgroup2<br>nodev	cpuset<br>nodev	devtmpfs<br>nodev	configfs<br>nodev	debugfs<br>nodev	tracefs<br>nodev	securityfs<br>nodev	sockfs<br>nodev	bpf<br>nodev	pipefs<br>nodev	ramfs<br>nodev	hugetlbfs<br>nodev	devpts<br>nodev	autofs<br>nodev	pstore<br>nodev	mqueue<br>	fuseblk<br>nodev	fuse<br>nodev	fusectl<br>	xfs<br>nodev	overlay<br></code></pre></td></tr></table></figure>

<h3 id="Linux-VFS-（Virtual-Filesystem-Switch）"><a href="#Linux-VFS-（Virtual-Filesystem-Switch）" class="headerlink" title="Linux VFS （Virtual Filesystem Switch）"></a>Linux VFS （Virtual Filesystem Switch）</h3><p><strong>Linux 的核心是如何管理这些文件系统呢？</strong></p>
<p>整个 Linux 的 filesystem 都是 VFS 在进行管理，使用者并不需要知道每个 partition 上头的 filesystem 是什么，VFS 会主动做好读取的动作</p>
<blockquote>
<p> 假设你的 &#x2F; 使用的是 &#x2F;dev&#x2F;hda1 ，用 ext3 ，而 &#x2F;home 使用 &#x2F;dev&#x2F;hda2 ，用 reiserfs ，那么你取用 &#x2F;home&#x2F;dmtsai&#x2F;.bashrc 时，不需要指定要用的什么文件系统的模块来读取！这个就是 VFS 的功能！</p>
</blockquote>
<p>通过这个 VFS 的功能来管理所有的 filesystem，省去我们需要自行设置读取文件系统的定义。</p>
<h3 id="XFS-文件系统简介"><a href="#XFS-文件系统简介" class="headerlink" title="XFS 文件系统简介"></a>XFS 文件系统简介</h3><p>CentOS 7 开始，默认的文件系统已经由原本的 EXT4 变成了 XFS 文件系统了，这是因为</p>
<ul>
<li>EXT 家族当前较伤脑筋的地方：支持度最广，但格式化超慢</li>
</ul>
<p>Ext 文件系统对于文件格式化的处理方面，采用的是<strong>预先规划</strong>出所有的 inode&#x2F;block&#x2F;metadata 等数据，未来系统可以直接取用，不需要再进行动态配置的作法。这个作法在早期磁盘容量还不大的时候没啥问题，但时至今日，磁盘容量越来越大，连传统的 MBR 都已经被 GPT 所取代，现在都已经说到 PB 或 EB 以上容量了！当你的 TB 以上等级的传统 ext 家族文件系统在格式化的时候，光是系统要预先分配 inode 与 block 就要消耗好多时间。</p>
<blockquote>
<p>由于虚拟化的应用越来越广泛，而作为虚拟化磁盘来源的巨型文件（单一文件好几个GB 以上）也就越来越常见了。这种巨型文件在处理上需要考虑到性能问题，否则虚拟磁盘的效率就会不太好看。因此，从 CentOS 7.x 开始，文件系统已经由默认的 Ext4 变成了xfs 这一个较适合大容量磁盘与巨型文件性能较佳的文件系统了</p>
</blockquote>
<h4 id="XFS-文件系统的配置"><a href="#XFS-文件系统的配置" class="headerlink" title="XFS 文件系统的配置"></a>XFS 文件系统的配置</h4><p>xfs 是一个<strong>日志式文件系统</strong>，而 CentOS 7.x 拿它当默认的文件系统，最早之前，这个 xfs 就是<strong>用于大容量磁盘以及高性能文件系统</strong>，相当适合现在的系统环境。此外，几乎所有 Ext4 文件系统有的功能， xfs 都可以具备！</p>
<p>xfs 文件系统在数据的分布上，主要规划为三个部份，一个数据区（data section）、一个文件系统活动登录区（log section）以及一个实时运行区（realtime section）。这三个区域的数据内容如下：</p>
<ul>
<li><p>数据区（data section）</p>
<p>基本上，数据区就跟ext 家族一样，包括 <code>inode/data block/superblock</code> 等数据，都放置在这个区块。这个数据区与 ext 家族的 block group 类似，也是分为多个储存区群组（allocation groups）来分别放置文件系统所需要的数据。</p>
<p>每个储存区群组都包含了</p>
<ul>
<li>整个文件系统的 superblock</li>
<li>剩余空间的管理机制</li>
<li>inode的分配与追踪</li>
</ul>
<p>此外，<strong>inode与 block</strong> 都是系统需要<strong>用到时才动态配置产生</strong>，所以格式化动作快。</p>
<p>与 ext 家族不同的是， xfs 的 block 与 inode 有<strong>多种不同的容量可供设置</strong>，block 容量可在 512Bytes ~ 64K 之间调整，不过，Linux 由于<strong>内存管理和分页机制</strong>的关系（<em>Linux 系统使用分页机制来管理内存，物理内存被分成固定大小的页（pages），页大小通常为 4 KB（即 4096 字节）</em>），大多数 block 设置为 4K， <strong>与页大小对齐</strong>，以提高性能和效率。</p>
<blockquote>
<p>设置块大小</p>
<p>mkfs.xfs -b size&#x3D;4096 &#x2F;dev&#x2F;sdX</p>
</blockquote>
<p>至于 inode 容量可设置 256Bytes 到 2M。一般保留 256Bytes 的默认值就够用了</p>
<blockquote>
<p>设置inode大小</p>
<p>mkfs.xfs -i size&#x3D;256 &#x2F;dev&#x2F;sdX</p>
</blockquote>
</li>
<li><p>文件系统活动登录区（log section）</p>
<p>这个区域主要被用来<strong>记录文件系统的变化</strong>，直到该变化完整的写入到数据区后，才会被终结。</p>
<p>如果文件系统因为某些缘故（例如最常见的停电）而损毁时，系统会拿这个登录区块来进行检验，看看系统挂掉之前，文件系统正在运行哪些动作，快速的修复文件系统。</p>
<p>在这个区域中，磁盘活动是相当频繁的，你可以指定外部的SSD 磁盘来作为 xfs 文件系统的日志区块，这样当系统需要进行任何活动时，就可以更快速的进行工作。</p>
</li>
<li><p>实时运行区（realtime section）</p>
<p>当有文件要被创建时，xfs 会在这个区段里面找一个到数个 extent 区块，将文件放置在这个区块内，等到分配完毕后，再写入到数据区的 inode 与 block 去。</p>
<p>这个 <strong><code>extent</code></strong> 区块的大小 (4K - 1G)要在格式化的时候就先指定。一般磁盘默认为 64K 容量，最好不要乱动，因为可能会影响到实体磁盘的性能。</p>
</li>
<li><p>XFS 文件系统的描述数据观察</p>
<p>可以使用 <code>xfs_info</code> 指令观察</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 找出 /boot 这个挂载点下面的文件系统的 superblock 纪录</span><br>[root@172-12-0-1 ~]# <span class="hljs-built_in">df</span> -T /boot<br>文件系统       类型   1K-块   已用   可用 已用% 挂载点<br>/dev/nvme0n1p1 xfs  1038336 214876 823460   21% /boot<br><span class="hljs-comment"># 可以看出是xfs文件系统</span><br>[root@172-12-0-1 ~]# xfs_info /dev/nvme0n1p1<br><span class="hljs-comment"># isize 是inode 的容量，agcount 是储存区群组（allocation group）的个数，agsize 是每个储存区群组具有 65536 个 block，配合第 12 行的 block 设置为 4K，因此整个文件系统的容量应该就是 65536 * 4 * 4 = 1048576k = 1G 这么大</span><br>meta-data=/dev/nvme0n1p1         isize=512    agcount=4, agsize=65536 blks<br><span class="hljs-comment"># sectsz 是逻辑扇区</span><br>         =                       sectsz=512   attr=2, projid32bit=1<br>         =                       crc=1        finobt=1, sparse=1, rmapbt=0<br>         =                       reflink=1<br><span class="hljs-comment"># bsize 是block 的容量，整个文件系统有262144个block</span><br>data     =                       bsize=4096   blocks=262144, imaxpct=25<br><span class="hljs-comment"># sunit和swidth 与磁盘阵列的 stripe 相关性较高，这里没有使用磁盘阵列</span><br>         =                       sunit=0      swidth=0 blks<br>naming   =version 2              bsize=4096   ascii-ci=0, ftype=1<br><span class="hljs-comment"># internal 表示登录区位置在文件系统内， 2560 * 4K = 10M容量</span><br><span class="hljs-built_in">log</span>      =internal <span class="hljs-built_in">log</span>           bsize=4096   blocks=2560, version=2<br>         =                       sectsz=512   sunit=0 blks, lazy-count=1<br><span class="hljs-comment"># 实时运行区， extent 容量为 4K，不过目前并没有使用</span><br>realtime =none                   extsz=4096   blocks=0, rtextents=0<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="文件系统的简单操作"><a href="#文件系统的简单操作" class="headerlink" title="文件系统的简单操作"></a>文件系统的简单操作</h2><h3 id="磁盘与目录的容量"><a href="#磁盘与目录的容量" class="headerlink" title="磁盘与目录的容量"></a>磁盘与目录的容量</h3><p>磁盘的整体数据在 superblock 区块中，但是每个文件的容量是在 inode当中记录的</p>
<ul>
<li>df：列出文件系统的整体磁盘使用量</li>
<li>du：评估文件系统的磁盘使用量（常用在推估目录所占容量）</li>
</ul>
<h4 id="df"><a href="#df" class="headerlink" title="df"></a>df</h4><ul>
<li>以易读的方式显示容量</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@172-12-0-1 ~]# <span class="hljs-built_in">df</span> -h<br>文件系统             容量  已用  可用 已用% 挂载点<br>devtmpfs             3.8G     0  3.8G    0% /dev<br><span class="hljs-comment"># /dev/shm 利用内存虚拟出来的磁盘空间，通常是总实体内存的一半，存取速度快，但是数据在关机后会丢失</span><br>tmpfs                3.8G     0  3.8G    0% /dev/shm<br>tmpfs                3.8G  9.1M  3.8G    1% /run<br>tmpfs                3.8G     0  3.8G    0% /sys/fs/cgroup<br>/dev/mapper/cl-root   35G   12G   24G   34% /<br>/dev/nvme0n1p1      1014M  210M  805M   21% /boot<br>tmpfs                775M     0  775M    0% /run/user/0<br>overlay               35G   12G   24G   34% /var/lib/docker/overlay2/fbc51c4c7f4544effda9d2328bb3d841f0035c6678e211e968f18f31cf14ffb4/merged<br></code></pre></td></tr></table></figure>

<ul>
<li>将 &#x2F;etc 下面的可用的磁盘容量以易读的容量格式显示</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@172-12-0-1 ~]# <span class="hljs-built_in">df</span> -h /etc<br>文件系统             容量  已用  可用 已用% 挂载点<br>/dev/mapper/cl-root   35G   12G   24G   34% /<br></code></pre></td></tr></table></figure>

<ul>
<li>将目前各个 partition 当中可用的 inode 数量列出</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@172-12-0-1 ~]# <span class="hljs-built_in">df</span> -ih<br>文件系统            Inode 已用(I) 可用(I) 已用(I)% 挂载点<br>devtmpfs             964K     400    963K       1% /dev<br>tmpfs                968K       1    968K       1% /dev/shm<br>tmpfs                968K     736    968K       1% /run<br>tmpfs                968K      17    968K       1% /sys/fs/cgroup<br>/dev/mapper/cl-root   18M    143K     18M       1% /<br>/dev/nvme0n1p1       512K     311    512K       1% /boot<br>tmpfs                968K       6    968K       1% /run/user/0<br>overlay               18M    143K     18M       1% /var/lib/docker/overlay2/fbc51c4c7f4544effda9d2328bb3d841f0035c6678e211e968f18f31cf14ffb4/merged<br></code></pre></td></tr></table></figure>

<p>由于 <code>df</code> 读取的数据几乎都是针对整个文件系统，因此读取的范围主要是在 <code>Superblock</code> 内的信息，所以这个指令显示结果的速度非常的快速，在显示的结果中需要特别留意根目录的剩余容量，因为所有的数据都是由根目录衍生出来的。</p>
<h4 id="du"><a href="#du" class="headerlink" title="du"></a>du</h4><ul>
<li>检查根目录下面每个目录所占用的容量</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@172-12-0-1 ~]# <span class="hljs-built_in">du</span> -smh /*<br>0	/bin<br>171M	/boot<br>0	/dev<br>25M	/etc<br>321M	/git<br>1.5G	/home<br>0	/lib<br>0	/lib64<br>0	/media<br>92M	/minikube-linux-amd64<br>0	/mnt<br>100M	/myblog<br>24M	/node_modules<br>0	/opt<br>20K	/package-lock.json<br>4.0K	/patch<br><span class="hljs-comment"># 因为/proc 是内存内的程序，程序执行结束就会消失，因此会有些目录找不到</span><br><span class="hljs-built_in">du</span>: 无法访问<span class="hljs-string">&#x27;/proc/1370017/task/1370017/fd/4&#x27;</span>: 没有那个文件或目录<br><span class="hljs-built_in">du</span>: 无法访问<span class="hljs-string">&#x27;/proc/1370017/task/1370017/fdinfo/4&#x27;</span>: 没有那个文件或目录<br><span class="hljs-built_in">du</span>: 无法访问<span class="hljs-string">&#x27;/proc/1370017/fd/4&#x27;</span>: 没有那个文件或目录<br><span class="hljs-built_in">du</span>: 无法访问<span class="hljs-string">&#x27;/proc/1370017/fdinfo/4&#x27;</span>: 没有那个文件或目录<br>0	/proc<br>185M	/root<br>9.1M	/run<br>0	/sbin<br>0	/srv<br>0	/sys<br>40K	/test<br>0	/tmp<br>2.7G	/usr<br>6.0G	/var<br>1.4G	/www<br></code></pre></td></tr></table></figure>

<p>与 df 不一样的是，<code>du</code> 指令会直接到文件系统去搜索所有的文件数据，速度较慢。</p>
<blockquote>
<p>想要列出某目录下的全部数据，可以加上 -S 的选项，减少次目录的加总</p>
</blockquote>
<h2 id="实体链接与符号链接：-ln"><a href="#实体链接与符号链接：-ln" class="headerlink" title="实体链接与符号链接： ln"></a>实体链接与符号链接： ln</h2><p>在 Linux 下面的链接文件有两种:</p>
<ol>
<li>符号链接（Symbolic Link）：一个特殊类型的文件，它指向另一个<strong>文件或目录</strong>的路径。可以理解为Windows中的快捷方式<ul>
<li>创建：<code>ln -s /path/to/original /path/to/symlink</code></li>
<li>特点：<ul>
<li>可以跨文件系统创建</li>
<li>删除源文件后，符号链接会变成无效链接（悬空链接）</li>
<li>使用<code>ls -l</code>查看符号链接时，显示形式为<code>lrwxrwxrwx</code>，并显示链接目标</li>
<li>修改链接文件时，源文件也会变更</li>
</ul>
</li>
</ul>
</li>
<li>硬链接（hard link）：一个文件系统中的<strong>文件</strong>指针，指向相同的 inode 号，即指向实际的数据块。硬链接和原文件共享相同的 inode 和数据块（<code>类似Java中的对象引用</code>）<ul>
<li>创建：<code>ln /path/to/original /path/to/hardlink</code></li>
<li>特点;<ul>
<li>不能跨文件系统创建</li>
<li>删除原文件时，硬链接仍然有效，因为它们指向相同的 inode</li>
<li>使用<code>ls -l</code>查看硬链接时，显示形式为<code>-rw-r--r--</code>，没有链接信息</li>
<li>不能link目录</li>
<li>修改链接文件其实就是在修改源文件</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="磁盘的分区、格式化、检验与挂载"><a href="#磁盘的分区、格式化、检验与挂载" class="headerlink" title="磁盘的分区、格式化、检验与挂载"></a>磁盘的分区、格式化、检验与挂载</h2><p>我们想要在系统里面新增一颗磁盘时，有哪些动作需要做呢：</p>
<ol>
<li>对磁盘进行分区，以创建可用的 partition </li>
<li>对分区进行格式化（format），以创建系统可用的 filesystem</li>
<li>对刚刚创建好的 filesystem 进行检验（可选）</li>
<li>在 Linux 系统上，需要创建挂载点（目录），并将它挂载上来</li>
</ol>
<h3 id="观察磁盘分区状态"><a href="#观察磁盘分区状态" class="headerlink" title="观察磁盘分区状态"></a>观察磁盘分区状态</h3><h4 id="lsblk-（list-block-device）列出系统上的所有磁盘列表"><a href="#lsblk-（list-block-device）列出系统上的所有磁盘列表" class="headerlink" title="lsblk （list block device）列出系统上的所有磁盘列表"></a>lsblk （list block device）列出系统上的所有磁盘列表</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@172-12-0-1 /]# lsblk<br><span class="hljs-comment">#NAME :设备文件名，会省略/dev等前导目录</span><br><span class="hljs-comment"># MAJ:MIN :主要：次要设备代码</span><br><span class="hljs-comment"># RM :是否为可卸载设备，如U盘</span><br><span class="hljs-comment"># RO :是否为只读设备</span><br>NAME        MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT<br>sr0          11:0    1  789M  0 rom  <br>nvme0n1     259:0    0   40G  0 disk <br>├─nvme0n1p1 259:1    0    1G  0 part /boot<br>└─nvme0n1p2 259:2    0   39G  0 part <br>  ├─cl-root 253:0    0   35G  0 lvm  /<br>  └─cl-swap 253:1    0    4G  0 lvm<br></code></pre></td></tr></table></figure>

<h4 id="blkid-列出设备的-UUID-等参数"><a href="#blkid-列出设备的-UUID-等参数" class="headerlink" title="blkid 列出设备的 UUID 等参数"></a>blkid 列出设备的 UUID 等参数</h4><blockquote>
<p>lsblk 也可以使用 -f 来列出文件系统与设备的 UUID 数据</p>
</blockquote>
<p>UUID 是全域单一识别码（universally unique identifier），Linux 会将系统内所有的设备都给予一个识别码，作为挂载或者使用这个设备&#x2F;文件系统</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@172-12-0-1 /]# blkid<br>/dev/nvme0n1p1: UUID=<span class="hljs-string">&quot;1042e93c-e0b7-419f-9253-d38b759bce52&quot;</span> BLOCK_SIZE=<span class="hljs-string">&quot;512&quot;</span> TYPE=<span class="hljs-string">&quot;xfs&quot;</span> PARTUUID=<span class="hljs-string">&quot;ad2a4d81-01&quot;</span><br>/dev/nvme0n1p2: UUID=<span class="hljs-string">&quot;SJB3Rh-mEln-qIDL-Z3Zt-Hr2M-0NGa-NxGZWd&quot;</span> TYPE=<span class="hljs-string">&quot;LVM2_member&quot;</span> PARTUUID=<span class="hljs-string">&quot;ad2a4d81-02&quot;</span><br>/dev/sr0: BLOCK_SIZE=<span class="hljs-string">&quot;2048&quot;</span> UUID=<span class="hljs-string">&quot;2021-11-13-00-32-00-00&quot;</span> LABEL=<span class="hljs-string">&quot;CentOS-8-5-2111-x86_64-dvd&quot;</span> TYPE=<span class="hljs-string">&quot;iso9660&quot;</span> PTUUID=<span class="hljs-string">&quot;45f5f6ac&quot;</span> PTTYPE=<span class="hljs-string">&quot;dos&quot;</span><br>/dev/mapper/cl-root: UUID=<span class="hljs-string">&quot;3d1bfc52-aa9d-459d-89fa-1142cc63fc9c&quot;</span> BLOCK_SIZE=<span class="hljs-string">&quot;512&quot;</span> TYPE=<span class="hljs-string">&quot;xfs&quot;</span><br>/dev/mapper/cl-swap: UUID=<span class="hljs-string">&quot;46dd982b-9cf4-4626-8675-c9a8773c5962&quot;</span> TYPE=<span class="hljs-string">&quot;swap&quot;</span><br>/dev/nvme0n1: PTUUID=<span class="hljs-string">&quot;ad2a4d81&quot;</span> PTTYPE=<span class="hljs-string">&quot;dos&quot;</span><br></code></pre></td></tr></table></figure>

<h4 id="parted-列出磁盘的分区表类型与分区信息"><a href="#parted-列出磁盘的分区表类型与分区信息" class="headerlink" title="parted 列出磁盘的分区表类型与分区信息"></a>parted 列出磁盘的分区表类型与分区信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@172-12-0-1 /]# parted /dev/mapper/cl-root <span class="hljs-built_in">print</span><br>Model: Linux device-mapper (linear) (dm)	<span class="hljs-comment"># 磁盘的模块名称（厂商）</span><br>Disk /dev/mapper/cl-root: 37.6GB	<span class="hljs-comment"># 磁盘总容量</span><br>Sector size (logical/physical): 512B/512B	<span class="hljs-comment"># 磁盘的每个逻辑/物理扇区容量</span><br>Partition Table: loop	<span class="hljs-comment"># 分区表的格式（MBR/GPT），这里是虚拟机的缘故</span><br>Disk Flags: <br><br>Number  Start  End     Size    File system  标志		<span class="hljs-comment"># 分区数据</span><br> 1      0.00B  37.6GB  37.6GB  xfs<br></code></pre></td></tr></table></figure>

<h3 id="磁盘分区：-gdisk-fdisk"><a href="#磁盘分区：-gdisk-fdisk" class="headerlink" title="磁盘分区： gdisk&#x2F;fdisk"></a>磁盘分区： gdisk&#x2F;fdisk</h3><p>MBR 分区表请使用 fdisk 分区， GPT 分区表请使用 gdisk 分区</p>
<h4 id="gdisk"><a href="#gdisk" class="headerlink" title="gdisk"></a>gdisk</h4><blockquote>
<p> 具体分区操作可以直接按照界面提示来，</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@172-12-0-1 /]# gdisk /dev/vda  <span class="hljs-comment">#设备名称不要加上数字</span><br>Command （? <span class="hljs-keyword">for</span> <span class="hljs-built_in">help</span>）: ?<br>b       back up GPT data to a file<br>c       change a partition<span class="hljs-string">&#x27;s name</span><br><span class="hljs-string">d       delete a partition           # 删除一个分区</span><br><span class="hljs-string">i       show detailed information on a partition</span><br><span class="hljs-string">l       list known partition types</span><br><span class="hljs-string">n       add a new partition          # 增加一个分区</span><br><span class="hljs-string">o       create a new empty GUID partition table （GPT）</span><br><span class="hljs-string">p       print the partition table    # 印出分区表（常用）</span><br><span class="hljs-string">q       quit without saving changes  # 不储存分区就直接离开 gdisk</span><br><span class="hljs-string">r       recovery and transformation options （experts only）</span><br><span class="hljs-string">s       sort partitions</span><br><span class="hljs-string">t       change a partition&#x27;</span>s <span class="hljs-built_in">type</span> code<br>v       verify disk<br>w       write table to disk and <span class="hljs-built_in">exit</span> <span class="hljs-comment"># 储存分区操作后离开 gdisk</span><br>x       extra functionality （experts only）<br>?       <span class="hljs-built_in">print</span> this menu<br>Command （? <span class="hljs-keyword">for</span> <span class="hljs-built_in">help</span>）:<br></code></pre></td></tr></table></figure>

<ul>
<li>示例</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@172-12-0-1 /]# gdisk /dev/vda<br>Command （? <span class="hljs-keyword">for</span> <span class="hljs-built_in">help</span>）: p<br>Number  Start （sector）    End （sector）  Size       Code  Name   <br>1            2048            6143   	 2.0 MiB     EF02    <br>2            6144         2103295   	1024.0 MiB   0700   <br>3         2103296        65026047   	 30.0 GiB    8E00<br><span class="hljs-comment"># 找出最后一个 sector 的号码</span><br>Command （? <span class="hljs-keyword">for</span> <span class="hljs-built_in">help</span>）: ?  <span class="hljs-comment"># 查一下增加分区的指令为何</span><br>Command （? <span class="hljs-keyword">for</span> <span class="hljs-built_in">help</span>）: n  <span class="hljs-comment"># 开始新增的行为</span><br>Partition number （4-128, default 4）: 4  <span class="hljs-comment"># 默认就是 4 号，直接 enter 即可</span><br>First sector （34-83886046, default = 65026048） or &#123;+-&#125;size&#123;KMGTP&#125;: 65026048  <span class="hljs-comment"># 默认是上个分区的最后一个扇区 + 1，直接enter</span><br>Last sector （65026048-83886046, default = 83886046） or &#123;+-&#125;size&#123;KMGTP&#125;: +1G<br><span class="hljs-comment"># 不需要自己去计算扇区号码，通过 +容量的这个方式，就可以让 gdisk 算出最接近你需要的容量的扇区号码</span><br><br>Current <span class="hljs-built_in">type</span> is <span class="hljs-string">&#x27;Linux filesystem&#x27;</span><br>Hex code or GUID （L to show codes, Enter = 8300）: <span class="hljs-comment"># 使用默认值即可～直接 enter</span><br><span class="hljs-comment"># 这里让你选择未来这个分区预计使用的文件系统！默认都是 Linux 文件系统的 8300（可以使用-l查看）</span><br></code></pre></td></tr></table></figure>

<p>输入<code>w</code>保存后，由于Linux正在使用这颗磁盘，担心系统出问题，所以分区表不会进行更新，可以重启或者通过 <code>partprobe </code>指令来处理</p>
<h5 id="partprobe-更新-Linux-核心的分区表信息"><a href="#partprobe-更新-Linux-核心的分区表信息" class="headerlink" title="partprobe 更新 Linux 核心的分区表信息"></a>partprobe 更新 Linux 核心的分区表信息</h5><p><code>partprobe -s</code></p>
<h4 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h4><p>跟gdisk差不多</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@172-12-0-1 /]# fdisk /dev/sda<br>Command （m <span class="hljs-keyword">for</span> <span class="hljs-built_in">help</span>）: m   <span class="hljs-comment"># 输入 m 后，就会看到下面这些指令介绍</span><br>Command action   <br>a   toggle a bootable flag   <br>b   edit bsd disklabel   <br>c   toggle the dos compatibility flag   <br>d   delete a partition   <span class="hljs-comment">#删除一个partition   </span><br>l   list known partition types   <br>m   <span class="hljs-built_in">print</span> this menu   <br>n   add a new partition  <span class="hljs-comment"># 新增一个partition   </span><br>o   create a new empty DOS partition table   <br>p   <span class="hljs-built_in">print</span> the partition table     <span class="hljs-comment"># 在屏幕上显示分区表   </span><br>q   quit without saving changes   <span class="hljs-comment"># 不储存离开fdisk程序   </span><br>s   create a new empty Sun disklabel   <br>t   change a partition<span class="hljs-string">&#x27;s system id   </span><br><span class="hljs-string">u   change display/entry units   </span><br><span class="hljs-string">v   verify the partition table   </span><br><span class="hljs-string">w   write table to disk and exit  # 将刚刚的动作写入分区表   </span><br><span class="hljs-string">x   extra functionality （experts only）</span><br></code></pre></td></tr></table></figure>

<h4 id="parted分区"><a href="#parted分区" class="headerlink" title="parted分区"></a>parted分区</h4><p><code>parted /dev/vda print</code></p>
<p><code>parted /dev/vda mkpart primary fat32 36.0GB 36.5GB</code></p>
<h3 id="磁盘格式化（创建文件系统）"><a href="#磁盘格式化（创建文件系统）" class="headerlink" title="磁盘格式化（创建文件系统）"></a>磁盘格式化（创建文件系统）</h3><p>格式化的指令<code>makefilesystem, mkfs</code>，这是个综合的指令，它会去调用正确的<strong>文件系统格式化工具</strong>软件。<strong>格式化</strong>应该称为创建文件系统（make filesystem）才对！</p>
<p>创建 xfs 文件系统，使用 <code>mkfs.xfs</code> 指令，<code>mkfs.xfs /dev/vda4</code></p>
<p>创建ext4文件系统，使用<code>mkfs.ext4</code>指令，<code>mkfs.ext4 /dev/vda5</code></p>
<ul>
<li>查看支持哪些mkfs指令</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@172-12-0-1 ~]# mkfs[Tab][Tab]<br>mkfs         mkfs.cramfs  mkfs.ext2    mkfs.ext3    mkfs.ext4    mkfs.minix   mkfs.xfs<br></code></pre></td></tr></table></figure>

<h3 id="文件系统检验"><a href="#文件系统检验" class="headerlink" title="文件系统检验"></a>文件系统检验</h3><h4 id="xfs-repair-处理-XFS-文件系统"><a href="#xfs-repair-处理-XFS-文件系统" class="headerlink" title="xfs_repair 处理 XFS 文件系统"></a>xfs_repair 处理 XFS 文件系统</h4><p>当有 xfs 文件系统错乱才需要使用这个指令 <code>xfs_repair [-fnd] 设备名称</code>，修复时需要先卸载设备，如果时根目录有问题，就要进入<strong>单人维护或救援模式</strong>，然后通过 <code>-d</code> 这个选项来处理</p>
<h4 id="fsck-ext4-处理-EXT4-文件系统"><a href="#fsck-ext4-处理-EXT4-文件系统" class="headerlink" title="fsck.ext4 处理 EXT4 文件系统"></a>fsck.ext4 处理 EXT4 文件系统</h4><p>fsck 是个<strong>综合指令</strong>，针对 ext4 建议直接使用 fsck.ext4 来检测，<code>fsck.ext4 [-pf] [-b superblock] 设备名称</code></p>
<blockquote>
<p>通常只有 root 且文件系统有问题的时候才使用这个指令，在正常状况下使用，可能会造成对系统的危害！</p>
<p>通常使用这个指令的场合都是在系统出现极大的问题，导致你在 Linux 开机的时候得进入单人单机模式下进行维护的行为时，才必须使用此一指令</p>
</blockquote>
<h3 id="文件系统挂载与卸载"><a href="#文件系统挂载与卸载" class="headerlink" title="文件系统挂载与卸载"></a>文件系统挂载与卸载</h3><h4 id="文件挂载：mount"><a href="#文件挂载：mount" class="headerlink" title="文件挂载：mount"></a>文件挂载：mount</h4><p>前面提到挂载点是目录，而这个目录是进入磁盘分区（文件系统）的入口</p>
<p>不过要进行挂载前最好先确定几件事：</p>
<ol>
<li>单一文件系统不应该被重复挂载在不同的挂载点（目录）中</li>
<li>单一目录不应该重复挂载多个文件系统</li>
<li>要作为挂载点的目录，理论上应该都是空目录</li>
</ol>
<p><strong>注意：如果挂载的目录里面不是空的，那么挂载了文件系统之后，原目录下的东西就会暂时消失，等到新分区被卸载之后才会出现</strong></p>
<blockquote>
<p> 举个例子，假设你的 &#x2F;home 原本与根目录（&#x2F;）在同一个文件系统中，下面原本就有 &#x2F;home&#x2F;test 与 &#x2F;home&#x2F;vbird 两个目录。然后你想要加入新的磁盘，并且直接挂载 &#x2F;home 下面，那么当你挂载上新的分区时，则 &#x2F;home 目录显示的是新分区内的数据，至于原先的 test 与 vbird 这两个目录就会暂时的被<strong>隐藏</strong>掉了。等到新分区被卸载之后，则 &#x2F;home 原本的内容就会再次出现！</p>
</blockquote>
<p>而要将文件系统挂载到我们的 Linux 系统上，就要使用 <code>mount</code> 这个指令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@172-12-0-1 ~]# mount -a<br>[root@172-12-0-1 ~]# mount [-l]<br>[root@172-12-0-1 ~]# mount [-t 文件系统] LABEL=<span class="hljs-string">&#x27;&#x27;</span>  挂载点<br>[root@172-12-0-1 ~]# mount [-t 文件系统] UUID=<span class="hljs-string">&#x27;&#x27;</span>   挂载点<br>[root@172-12-0-1 ~]# mount [-t 文件系统] 设备文件名挂载点<br>选项与参数：<br>-a  ：依照配置文件 [/etc/fstab](../Text/index.html#fstab) 的数据将所有未挂载的磁盘都挂载上来<br>-l  ：单纯的输入 mount 会显示目前挂载的信息。加上 -l 可增列 Label 名称<br>-t  ：可以加上文件系统种类来指定欲挂载的类型。常见的 Linux 支持类型有：xfs, ext3, ext4<br>-n  ：在默认的情况下，系统会将实际挂载的情况实时写入 /etc/mtab 中，以利其他程序的运行。但在某些情况下（例如单人维护模式）为了避免问题会刻意不写入。此时就得要使用 -n 选项<br>-o  ：后面可以接一些挂载时额外加上的参数！比方说帐号、密码、读写权限等：<br>	async, <span class="hljs-built_in">sync</span>:   此文件系统是否使用同步写入（<span class="hljs-built_in">sync</span>）或非同步（默认）（async）的内存机制<br>	atime,noatime: 是否修订文件的读取时间（atime）。为了性能，某些时刻可使用 noatime<br>    ro, rw:        挂载文件系统成为只读（ro）或可读写（rw）<br>    auto, noauto:  允许此 filesystem 被以 mount -a 自动挂载（auto）<br>    dev, nodev:    是否允许此 filesystem 上，可创建设备文件？ dev 为可允许<br>    suid, nosuid:  是否允许此 filesystem 含有 suid/sgid 的文件格式？<br>    <span class="hljs-built_in">exec</span>, noexec:  是否允许此 filesystem 上拥有可执行 binary 文件？<br>    user, nouser:  是否允许此 filesystem 让任何使用者执行 mount ？一般来说，                     					 mount 仅有 root 可以进行，但下达 user 参数，则可让一般 user 也能够对此 						   partition 进行 mount 。<br>    defaults:      默认值为：rw, suid, dev, <span class="hljs-built_in">exec</span>, auto, nouser, and async<br>    remount:       重新挂载，这在系统出错，或重新更新参数时，很有用！<br></code></pre></td></tr></table></figure>

<p>CentOS 7 以后不需要加上 <code>-t</code> 这个选项，系统会自动的分析最恰当的文件系统来尝试挂载你需要的设备，这也是使用 <code>blkid</code> 就能够正确显示文件系统的原因！</p>
<blockquote>
<p>CentOS 是怎么找出文件系统类型的呢？</p>
<p>由于文件系统几乎都有 <code>superblock</code> ，Linux 可以通过分析 <code>superblock</code> 搭配 Linux 自己的驱动程序去测试挂载，如果成功，就使用该类型的文件系统挂载！</p>
</blockquote>
<blockquote>
<p>那么系统有没有指定哪些类型的<code>filesystem</code> 才需要进行上述的挂载测试呢？</p>
<p>主要是参考下面这两个文件</p>
<ul>
<li>&#x2F;etc&#x2F;filesystems：<strong>系统指定的测试挂载文件系统类型的优先顺序</strong></li>
<li>&#x2F;proc&#x2F;filesystems：<strong>Linux系统已经载入的文件系统类型</strong></li>
</ul>
</blockquote>
<blockquote>
<p>那我怎么知道我的 Linux 有没有相关文件系统类型的驱动程序呢？</p>
<p>Linux 支持的文件系统之驱动程序都写在如下的目录中</p>
<ul>
<li>&#x2F;lib&#x2F;modules&#x2F;$（uname -r）&#x2F;kernel&#x2F;fs&#x2F;</li>
</ul>
</blockquote>
<p>将某个目录挂载到其他目录，也可以使用 symbolic link 来链接，不过在某些不支持符号链接的程序运行中，还是得要通过这样的方法才行，<code>mount --bind /var /data/var</code></p>
<h4 id="卸载-umount"><a href="#卸载-umount" class="headerlink" title="卸载:umount"></a>卸载:umount</h4><p>将设备文件卸载，<code>umount 设备或挂载点</code></p>
<h3 id="磁盘-文件系统参数修订"><a href="#磁盘-文件系统参数修订" class="headerlink" title="磁盘&#x2F;文件系统参数修订"></a>磁盘&#x2F;文件系统参数修订</h3><p>有时你可能只是希望修改一下目前文件系统的一些<strong>相关信息</strong>（例如Label name ， journal 的参数），这个时候，就得需要下面这些相关的指令功能：</p>
<ul>
<li><p>mknod</p>
<p>在 Linux 下面所有的设备都以文件表示，通过文件的 major 与 minor 数值来表示，<code>mknod 设备文件名 [bcp] [Major] [Minor]</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mknod</span> [OPTION]... NAME TYPE [MAJOR MINOR]<br></code></pre></td></tr></table></figure>
</li>
<li><p>xfs_admin 修改 XFS 文件系统的 UUID 与 Label name</p>
<p>如果格式化的时候忘记加上标头名称，后来想要再次加入时，不需要重复格式化！直接使用 xfs_admin 指令来处理 LABEL name 以及 UUID 即可</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">xfs_admin [ -eflpu ] [ -c 0|1 ] [ -L label ] [ -U uuid ] device<br><br><span class="hljs-comment"># 生成uuid</span><br>[root@172-12-0-1 ~]# uuidgen<br>ec12c7fd-ddf8-45b1-b238-b970cdeaa6a7<br></code></pre></td></tr></table></figure>
</li>
<li><p>tune2fs 修改 ext4 的 label name 与 UUID</p>
</li>
</ul>
<h3 id="设置开机挂载"><a href="#设置开机挂载" class="headerlink" title="设置开机挂载"></a>设置开机挂载</h3><h4 id="开机挂载-etc-fstab-及-etc-mtab"><a href="#开机挂载-etc-fstab-及-etc-mtab" class="headerlink" title="开机挂载 &#x2F;etc&#x2F;fstab 及 &#x2F;etc&#x2F;mtab"></a>开机挂载 &#x2F;etc&#x2F;fstab 及 &#x2F;etc&#x2F;mtab</h4><p>修改 <code>/etc/fstab</code> (filesystem table)使开机自动挂载，以下时系统挂载的一些限制：</p>
<ul>
<li>根目录 <code>/</code> 是必须挂载的﹐而且一定要先于其它 mount point 被挂载进来</li>
<li>其它 mount point 必须为已创建的目录﹐可任意指定﹐但一定要遵守必须的系统目录架构原则（FHS）</li>
<li>所有 mount point 在同一时间之内﹐只能挂载一次</li>
<li>所有 partition 在同一时间之内﹐只能挂载一次</li>
<li>如若进行卸载﹐必须先将工作目录移到 mount point（及其子目录）之外</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@172-12-0-1 ~]# <span class="hljs-built_in">cat</span> /etc/fstab <br>...<br><span class="hljs-comment"># Device/UUID等         Mount point  filesystem parameters    dump fsck</span><br>/dev/mapper/cl-root     /               xfs     defaults        0 0<br>UUID=1042e93c-...-bce52 /boot           xfs     defaults        0 0<br><span class="hljs-comment">#/dev/mapper/cl-swap     none           swap    defaults        0 0</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>&#x2F;etc&#x2F;fstab 是开机时的配置文件，不过，实际 filesystem 的挂载是记录到 &#x2F;etc&#x2F;mtab 与&#x2F;proc&#x2F;mounts 这两个文件当中的。每次更改 filesystem 的挂载时也会同步到这两个文件！</p>
<p>但是，万一 &#x2F;etc&#x2F;fstab 输入的数据错误，导致无法顺利开机而进入单人维护模式当中，那时的 <strong>&#x2F;</strong> 是 read only 的状态，当然就无法修改 &#x2F;etc&#x2F;fstab ，也无法更新 &#x2F;etc&#x2F;mtab。可以使用 <code>mount -n -o remount,rw</code></p>
</blockquote>
<h4 id="特殊设备loop挂载（镜像文件不烧录就挂载使用）"><a href="#特殊设备loop挂载（镜像文件不烧录就挂载使用）" class="headerlink" title="特殊设备loop挂载（镜像文件不烧录就挂载使用）"></a>特殊设备loop挂载（镜像文件不烧录就挂载使用）</h4><h5 id="挂载光盘-DVD镜像文件"><a href="#挂载光盘-DVD镜像文件" class="headerlink" title="挂载光盘&#x2F;DVD镜像文件"></a>挂载光盘&#x2F;DVD镜像文件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@172-12-0-1 ~]# ll -h /tmp/CentOS-7.0-1406-x86_64-DVD.iso<br>-rw-r--r--. 1 root root 3.9G Jul  7  2014 /tmp/CentOS-7.0-1406-x86_64-DVD.iso<br><span class="hljs-comment"># 创建挂载点</span><br>[root@172-12-0-1 ~]# <span class="hljs-built_in">mkdir</span> /data/centos_dvd<br><span class="hljs-comment"># 挂载</span><br>[root@172-12-0-1 ~]# mount -o loop /tmp/CentOS-7.0-1406-x86_64-DVD.iso /data/centos_dvd<br><span class="hljs-comment"># </span><br>[root@172-12-0-1 ~]# <span class="hljs-built_in">df</span> /data/centos_dvd<br>Filesystem     1K-blocks    Used Available Use% Mounted on/dev/loop0       4050860 4050860         0 100% /data/centos_dvd<br><span class="hljs-comment"># .iso 镜像文件内的所有数据可以在 /data/centos_dvd 看到</span><br>[root@172-12-0-1 ~]# ll /data/centos_dvd<br>total 607<br>-rw-r--r--. 1  500  502     14 Jul  5  2014 CentOS_BuildTag<br>drwxr-xr-x. 3  500  502   2048 Jul  4  2014 EFI<br>-rw-r--r--. 1  500  502    611 Jul  5  2014 EULA<br>-rw-r--r--. 1  500  502  18009 Jul  5  2014 GPL<br>drwxr-xr-x. 3  500  502   2048 Jul  4  2014 images<br>.....（下面省略）.....<br>[root@172-12-0-1 ~]# umount /data/centos_dvd/<br></code></pre></td></tr></table></figure>

<p>如此一来就不需要将这个文件烧录成为光盘或者是 DVD 就能够读取内部的数据。但这样一来，也可以对这个文件动手脚，这也是为什么很多镜像文件提供后，还得要提供验证码（MD5）给使用者确认该镜像文件没有问题的原因。</p>
<h4 id="创建大文件以制作-loop-设备文件"><a href="#创建大文件以制作-loop-设备文件" class="headerlink" title="创建大文件以制作 loop 设备文件"></a>创建大文件以制作 loop 设备文件</h4><p>制作出一个大文件，然后将这个文件格式化后挂载，能够解决很多系统的分区不良的情况。</p>
<blockquote>
<p>如果当初在分区时，你只有分区出一个根目录，假设你已经没有多余的容量可以进行额外的分区的！偏偏根目录的容量还很大！此就能够制作出一个大文件，然后将这个文件挂载。</p>
</blockquote>
<p>下面在 &#x2F;srv 下创建一个 512MB 左右的大文件，然后将这个大文件格式化并且实际挂载</p>
<ul>
<li>创建大型文件，使用dd</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@172-12-0-1 ~]# <span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/zero of=/srv/loopdev bs=1M count=512<br>记录了512+0 的读入<br>记录了512+0 的写出<br>536870912 bytes (537 MB, 512 MiB) copied, 0.270615 s, 2.0 GB/s<br><span class="hljs-comment"># 这个指令的简单意义如下：</span><br><span class="hljs-comment"># if    是 input file ，输入文件。那个 /dev/zero 是会一直输出 0 的设备</span><br><span class="hljs-comment"># of    是 output file ，将一堆零写入到后面接的文件中</span><br><span class="hljs-comment"># bs    是每个 block 大小，就像文件系统那样的 block 意义</span><br><span class="hljs-comment"># count 则是总共几个 bs 的意思。所以 bs*count 就是这个文件的容量了</span><br>[root@172-12-0-1 ~]# ll -h /srv/loopdev<br>-rw-r--r-- 1 root root 512M 8月  19 14:44 /srv/loopdev<br></code></pre></td></tr></table></figure>

<ul>
<li>大型文件的格式化</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@172-12-0-1 ~]# mkfs.xfs -f /srv/loopdev<br>meta-data=/srv/loopdev           isize=512    agcount=4, agsize=32768 blks<br>         =                       sectsz=512   attr=2, projid32bit=1<br>         =                       crc=1        finobt=1, sparse=1, rmapbt=0<br>         =                       reflink=1<br>data     =                       bsize=4096   blocks=131072, imaxpct=25<br>         =                       sunit=0      swidth=0 blks<br>naming   =version 2              bsize=4096   ascii-ci=0, ftype=1<br><span class="hljs-built_in">log</span>      =internal <span class="hljs-built_in">log</span>           bsize=4096   blocks=1368, version=2<br>         =                       sectsz=512   sunit=0 blks, lazy-count=1<br>realtime =none                   extsz=4096   blocks=0, rtextents=0<br><br>[root@172-12-0-1 ~]# blkid /srv/loopdev<br>/srv/loopdev: UUID=<span class="hljs-string">&quot;bab933a5-a69d-48ce-ab5b-d3cc5038d639&quot;</span> BLOCK_SIZE=<span class="hljs-string">&quot;512&quot;</span> TYPE=<span class="hljs-string">&quot;xfs&quot;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>挂载</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@172-12-0-1 ~]# mount -o loop UUID=<span class="hljs-string">&quot;bab933a5-a69d-48ce-ab5b-d3cc5038d639&quot;</span> /mnt<br>[root@172-12-0-1 ~]# <span class="hljs-built_in">df</span> /mnt/<br>文件系统        1K-块  已用   可用 已用% 挂载点<br>/dev/loop0     518816 30092 488724    6% /mnt<br></code></pre></td></tr></table></figure>

<ul>
<li>设置开机自动挂载</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@172-12-0-1 ~]# vim /etc/fstab<br>/srv/loopdev /data/file  xfs  defaults,loop   0 0<br><br>[root@172-12-0-1 ~]# umount /mnt<br>[root@172-12-0-1 ~]# <span class="hljs-built_in">mkdir</span> /data/file<br>[root@172-12-0-1 ~]# mount -a<br>[root@172-12-0-1 /]# <span class="hljs-built_in">df</span> /data/file<br>文件系统        1K-块  已用   可用 已用% 挂载点<br>/dev/loop0     518816 30092 488724    6% /data/file<br><br><span class="hljs-comment"># 卸载并清除(可选，这里是演示)</span><br>[root@172-12-0-1 /]# umount /data/file<br>[root@172-12-0-1 /]# <span class="hljs-built_in">cd</span> /srv/<br>[root@172-12-0-1 /]# <span class="hljs-built_in">rm</span> -rf loopdev<br></code></pre></td></tr></table></figure>

<h3 id="内存交换空间（swap）创建"><a href="#内存交换空间（swap）创建" class="headerlink" title="内存交换空间（swap）创建"></a>内存交换空间（swap）创建</h3><p>交换空间作用：暂时将内存的程序拿到硬盘中暂放</p>
<ul>
<li>实体分区</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@172-12-0-1 /]# gdisk /dev/vda<br>Command （? <span class="hljs-keyword">for</span> <span class="hljs-built_in">help</span>）: n<br>Partition number （6-128, default 6）:<br>First sector （34-83886046, default = 69220352） or &#123;+-&#125;size&#123;KMGTP&#125;:<br>Last sector （69220352-83886046, default = 83886046） or &#123;+-&#125;size&#123;KMGTP&#125;: +512M<br>Current <span class="hljs-built_in">type</span> is <span class="hljs-string">&#x27;Linux filesystem&#x27;</span><br>Hex code or GUID （L to show codes, Enter = 8300）: 8200<br>Changed <span class="hljs-built_in">type</span> of partition to <span class="hljs-string">&#x27;Linux swap&#x27;</span><br><br>Command （? <span class="hljs-keyword">for</span> <span class="hljs-built_in">help</span>）: p<br>Number  Start （sector）    End （sector）  Size       Code  Name<br>6        69220352        70268927   512.0 MiB   8200  Linux swap  <br><span class="hljs-comment"># 重点就是产生这东西！</span><br>Command （? <span class="hljs-keyword">for</span> <span class="hljs-built_in">help</span>）: w<br>Do you want to proceed? （Y/N）: y<br>[root@172-12-0-1 /]# partprobe<br>[root@172-12-0-1 /]# lsblk<br>NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT<br>vda             252:0    0   40G  0 disk<br>.....（中间省略）.....<br>vda6            252:6    0  512M  0 part   <span class="hljs-comment"># 确定这里是存在的才行</span><br><br>2. 开始创建 swap 格式<br>[root@172-12-0-1 /]# mkswap /dev/vda6<br>Setting up swapspace version 1, size = 524284 KiB<br>no label, UUID=6b17e4ab-9bf9-43d6-88a0-73ab47855f9d<br>[root@172-12-0-1 /]# blkid<br>/dev/vda6/dev/vda6: UUID=<span class="hljs-string">&quot;6b17e4ab-9bf9-43d6-88a0-73ab47855f9d&quot;</span> TYPE=<span class="hljs-string">&quot;swap&quot;</span><br><br>3. 开始观察与载入<br>[root@172-12-0-1 /]# free<br>			total        used        free      shared  buff/cache   available<br>Mem:       1275140      227244      330124      7804      717772      875536  <span class="hljs-comment"># 实体内存</span><br>Swap:      1048572      101340      947232                                    <span class="hljs-comment"># swap 相关</span><br><br>[root@172-12-0-1 /]# swapon /dev/vda6<br>[root@172-12-0-1 /]# free<br>			total        used        free      shared  buff/cache   available<br>Mem:       1275140      227940      329256      7804     717944       874752<br>Swap:      1572856      101260     1471596   							   <span class="hljs-comment"># 可以看到增加了</span><br>[root@172-12-0-1 /]# swapon -s<br>Filename                 Type            Size    Used    Priority<br>/dev/dm-1                partition       1048572 101260  -1<br>/dev/vda6                partition       524284  0       -2<br><br>[root@172-12-0-1 /]# vim /etc/fstab<br>UUID=<span class="hljs-string">&quot;6b17e4ab-9bf9-43d6-88a0-73ab47855f9d&quot;</span>  swap  swap  defaults  0  0<br><span class="hljs-comment"># 写入配置文件，不是文件系统，所以没有挂载点，第二个字段写入 swap 即可</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>调整交换优先级，<strong>较低的优先级值会优先使用</strong></p>
<p>sudo swapon –priority 10 &#x2F;swapfile</p>
</blockquote>
<ul>
<li>使用文件swap分区</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># sudo swapoff /swapfile	# 扩容时先删除再创建</span><br><span class="hljs-comment"># sudo rm /swapfile</span><br><br><span class="hljs-comment"># 创建一个新的 2GB 交换文件</span><br>[root@172-12-0-1 /]# <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/zero of=/swapfile bs=1M count=2048<br><span class="hljs-comment"># 设置交换文件的权限</span><br>[root@172-12-0-1 /]# <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">chmod</span> 600 /swapfile<br><span class="hljs-comment"># 将文件设置为交换空间</span><br>[root@172-12-0-1 /]# <span class="hljs-built_in">sudo</span> mkswap /swapfile<br><span class="hljs-comment"># 启用交换文件</span><br>[root@172-12-0-1 /]# <span class="hljs-built_in">sudo</span> swapon /swapfile<br><span class="hljs-comment"># 验证</span><br>[root@172-12-0-1 /]# <span class="hljs-built_in">sudo</span> swapon --show<br><span class="hljs-comment"># 或者</span><br>[root@172-12-0-1 /]# free -h<br><span class="hljs-comment"># 持久化配置</span><br>[root@172-12-0-1 /]# <span class="hljs-built_in">sudo</span> vim /etc/fstab<br>/swapfile none swap sw 0 0<br>[root@172-12-0-1 /]# <span class="hljs-built_in">sudo</span> swapon --priority 10 /swapfile<br></code></pre></td></tr></table></figure>

<h1 id="六、文件与文件系统的压缩、打包与备份"><a href="#六、文件与文件系统的压缩、打包与备份" class="headerlink" title="六、文件与文件系统的压缩、打包与备份"></a>六、文件与文件系统的压缩、打包与备份</h1><h2 id="常见的压缩指令"><a href="#常见的压缩指令" class="headerlink" title="常见的压缩指令"></a>常见的压缩指令</h2><p>在Linux的环境中，压缩文件的扩展名大多是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">*.Z         compress 程序压缩的文件（不流行）<br>*.zip       zip 程序压缩的文件<br>*.gz        gzip 程序压缩的文件<br>*.bz2       bzip2 程序压缩的文件<br>*.xz        xz 程序压缩的文件<br>*.tar       tar 程序打包的数据，并没有压缩过<br>*.tar.gz    tar 程序打包的文件，并且经过 gzip 的压缩<br>*.tar.bz2   tar 程序打包的文件，并且经过 bzip2 的压缩<br>*.tar.xz    tar 程序打包的文件，并且经过 xz 的压缩<br></code></pre></td></tr></table></figure>

<h3 id="gzip-zcat-zmore-zless-zgrep"><a href="#gzip-zcat-zmore-zless-zgrep" class="headerlink" title="gzip, zcat&#x2F;zmore&#x2F;zless&#x2F;zgrep"></a>gzip, zcat&#x2F;zmore&#x2F;zless&#x2F;zgrep</h3><p>gzip 可以解开 compress, zip 与 gzip 等软件所压缩的文件， gzip 所创建的压缩文件为 *.gz 的文件，默认压缩级别为6.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 找出 /etc 下面（不含子目录）容量最大的文件，并将它复制到 /tmp ，然后以 gzip 压缩</span><br>[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ <span class="hljs-built_in">ls</span> -ldSr /etc/*<br>...<br>-rw-r--r--   1 root root    23127 8月  14 09:31 /etc/ld.so.cache<br>-rw-r--r--.  1 root root   692252 5月  15 2020 /etc/services<br>[<span class="hljs-built_in">test</span>@172-12-0-1 ~]$ <span class="hljs-built_in">cd</span> /tmp<br>[<span class="hljs-built_in">test</span>@172-12-0-1 tmp]$ <span class="hljs-built_in">cp</span> /etc/services .<br>[<span class="hljs-built_in">test</span>@172-12-0-1 tmp]$ gzip -v services<br>services:	 79.4% -- replaced with services.gz<br>[<span class="hljs-built_in">test</span>@172-12-0-1 tmp]$ ll /etc/services /tmp/services*<br>-rw-r--r--. 1 root root 692252 5月  15 2020 /etc/services<br>-rw-r--r--  1 <span class="hljs-built_in">test</span> <span class="hljs-built_in">test</span> 142528 8月  19 16:47 /tmp/services.gz<br><br><span class="hljs-comment"># 由于 services 这个原本的文件是是文本文件，因此我们可以尝试使用 zcat/zmore/zless 去读取</span><br>[<span class="hljs-built_in">test</span>@172-12-0-1 tmp]$ zcat services.gz<br><br><span class="hljs-comment"># 使用 gzip -d 来进行解压缩，与 gzip 相反， gzip -d 会将原本的 .gz 删除，回复到原本的 services 文件</span><br>[<span class="hljs-built_in">test</span>@172-12-0-1 tmp]$ gzip -d services.gz<br><br><span class="hljs-comment"># 将解开的 services 用最佳的压缩比压缩，并保留原本的文件</span><br>[<span class="hljs-built_in">test</span>@172-12-0-1 tmp]$ gzip -9 -c services &gt; services.gz<br><br><span class="hljs-comment"># 在 services.gz 中，找出 http 这个关键字在哪几行</span><br>[<span class="hljs-built_in">test</span>@172-12-0-1 tmp]$ zgrep -n <span class="hljs-string">&#x27;http&#x27;</span> services.gz<br>14:#       http://www.iana.org/assignments/port-numbers<br>89:http            80/tcp          www www-http    <span class="hljs-comment"># WorldWideWeb HTTP</span><br>90:http            80/udp          www www-http    <span class="hljs-comment"># HyperText Transfer Protocol</span><br>.....（下面省略）.....<br></code></pre></td></tr></table></figure>

<h3 id="bzip2-bzcat-bzmore-bzless-bzgrep"><a href="#bzip2-bzcat-bzmore-bzless-bzgrep" class="headerlink" title="bzip2, bzcat&#x2F;bzmore&#x2F;bzless&#x2F;bzgrep"></a>bzip2, bzcat&#x2F;bzmore&#x2F;bzless&#x2F;bzgrep</h3><p><code>bzip2</code>是为了取代gzip 并提供更佳的压缩比而来的，用法跟<code>gzip</code>一样</p>
<h3 id="xz-xzcat-xzmore-xzless-xzgrep"><a href="#xz-xzcat-xzmore-xzless-xzgrep" class="headerlink" title="xz, xzcat&#x2F;xzmore&#x2F;xzless&#x2F;xzgrep"></a>xz, xzcat&#x2F;xzmore&#x2F;xzless&#x2F;xzgrep</h3><p><code>xz</code>：比<code>bzip2</code>压缩比更高，用法跟 <code>gzip/bzip2</code>差不多</p>
<blockquote>
<p>通过<code>time [gzip|bzip2|xz] -c services &gt; services.[gz|bz2|xz]</code> 去执行运算结果，结果发现这三个指令的执行时间依序是： <code>0.019s, 0.042s, 0.261s</code>，所以xz耗时是最久的</p>
</blockquote>
<h2 id="打包指令：tar"><a href="#打包指令：tar" class="headerlink" title="打包指令：tar"></a>打包指令：tar</h2><p>前面谈到的指令大多仅能<strong>针对单一文件来进行压缩</strong>，虽然 <code>gzip, bzip2, xz</code> 也能针对目录进行压缩，不过对目录的压缩指的是<strong>将目录内的所有文件<code>分别</code>进行压缩</strong>。而不像 Windows 系统使用类似<code>WinRAR</code>这一类软件将很多数据包成<strong>一个文件</strong>的样式。</p>
<p>这种<strong>将多个文件或目录包成一个大文件</strong>的功能，就是打包。</p>
<p> <code>tar</code> 指令可以将多个目录或文件打包成一个大文件，同时还可以通过 gzip&#x2F;bzip2&#x2F;xz 的支持，将该文件同时进行压缩。</p>
<ul>
<li><p>压 缩bzip2：tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称</p>
</li>
<li><p>压 缩gzip：tar -zcv -f filename.tar.bz2 要被压缩的文件或目录名称</p>
</li>
<li><p>查 询：tar -jtv -f filename.tar.bz2</p>
</li>
<li><p>解压缩：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 加上 -p 这个选项是为了保存原本文件的权限与属性</span><br>[root@172-12-0-1 ~]# tar -zpc -f /root/etc.tar.gz /etc<br><span class="hljs-comment"># 重点：拿掉根目录</span><br>tar: 从成员名中删除开头的“/”<br>[root@172-12-0-1 ~]# ll /root/etc*<br>-rw-r--r-- 1 root root 5664963 8月  19 17:43 /root/etc.tar.gz<br><br><span class="hljs-comment"># 查看 tar 文件的数据内容（可查看文件名）</span><br><span class="hljs-comment"># 加上 -v，详细的文件权限/属性都会被列出来</span><br>[root@172-12-0-1 ~]# tar -ztv -f /root/etc.tar.gz<br>drwxr-xr-x root/root         0 2024-08-19 15:32 etc/<br>lrwxrwxrwx root/root         0 2024-07-18 19:35 etc/mtab -&gt; ../proc/self/mounts<br>-rw-r--r-- root/root       631 2024-08-19 15:32 etc/fstab<br>...<br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>打包为什么要拿掉根目录?</strong></p>
<p>主要是为了<strong>安全</strong>。我们使用 tar 备份的数据可能需要解压缩回来使用，在 tar 所记录的文件名就是解压缩后的实际文件名。如果拿掉了根目录，假设你将备份数据在 &#x2F;tmp 解开，那么解压缩的文件名就会变成<code>/tmp/etc/xxx</code>。但如果没有拿掉根目录，解压缩后的文件名就会是绝对路径，亦即解压缩后的数据一定会被放置到 <code>/etc/xxx</code>去，这样会覆盖掉原本的<code>/etc/</code> 下面的数据</p>
</blockquote>
<ul>
<li><p>仅解开单一文件的方法：</p>
<ul>
<li><p>查找需要的文件名：<code>tar -jtv -f /root/etc.tar.bz2 | grep &#39;shadow&#39;</code></p>
</li>
<li><p>将该文件解压：<code>tar -jxv -f /root/etc.tar.bz2 etc/shadow</code></p>
</li>
</ul>
</li>
<li><p>打包某目录，但不含该目录下的某些文件，<code>--exclude</code></p>
<ul>
<li>排除匹配 <code>/root/etc*</code> 的文件或目录和归档文件本身，指定要归档的目录 <code>/etc</code> 和 <code>/root</code>：<code>tar -jcv -f /root/system.tar.bz2 --exclude=/root/etc* --exclude=/root/system.tar.bz2 /etc /root</code></li>
</ul>
</li>
<li><p>仅备份比某个时刻还要新的文件，<code>--newer-mtime</code></p>
<ul>
<li>找出比 <code>/etc/passwd</code> 新的文件：<code>find /etc -newer /etc/passwd</code></li>
<li><code>tar -jcv -f /root/etc.newer.then.passwd.tar.bz2 --newer-mtime=&quot;2015/06/17&quot; /etc/*</code></li>
</ul>
</li>
</ul>
<h3 id="基本名称：-tarfile，-tarball"><a href="#基本名称：-tarfile，-tarball" class="headerlink" title="基本名称： tarfile， tarball"></a>基本名称： tarfile， tarball</h3><p>仅打包，就是<code>tar -cv -f file.tar</code> 而已，这个文件称为 <code>tarfile</code> ；如果还有进行压缩，例如<code>tar -jcv -f file.tar.bz2</code> 时，就称为 tarball。</p>
<p><code>tar</code> 除了可以将数据打包成为文件之外，还能够将文件打包到某些特别的设备去</p>
<blockquote>
<p>磁带机（tape）就是一个常见的例子。磁带机由于是一次性读取&#x2F;写入的设备，因此不能够使用类似 cp 等指令来复制！如果想要将 &#x2F;home, &#x2F;root, &#x2F;etc 备份到磁带机（&#x2F;dev&#x2F;st0）时，就可以使用：<code>tar -cv -f /dev/st0 /home /root /etc</code></p>
</blockquote>
<h3 id="特殊应用：利用管线命令与数据流"><a href="#特殊应用：利用管线命令与数据流" class="headerlink" title="特殊应用：利用管线命令与数据流"></a>特殊应用：利用管线命令与数据流</h3><ul>
<li><p>将 <code>/etc</code> 下面的数据直接 copy 到目前所在的路径：<code>tar -cvf - /etc | tar -xvf -</code></p>
<ul>
<li><p>整体流程：</p>
<ul>
<li><strong>归档创建</strong>：第一个 <code>tar</code> 命令创建一个包含 <code>/etc</code> 目录的归档，并将归档数据输出到标准输出</li>
<li><strong>归档提取</strong>：第二个 <code>tar</code> 命令从标准输入读取数据，并将其提取到当前目录</li>
<li>第一个<code>-f -</code> ：将归档写到标准输出（<code>-</code> 表示标准输出），这意味着创建的归档不会存储在磁盘上，而是通过管道直接传输</li>
<li>第二个<code>-f -</code>：从标准输入读取归档。这里 <code>-</code> 表示从标准输入读取数据</li>
</ul>
</li>
<li><p>使用场景：</p>
<ul>
<li><p><strong>在不同的主机之间传输数据</strong>：可以通过网络传输流式归档数据，而不需要中间存储归档文件。例如，你可以将数据通过 SSH 传输到另一台主机</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -cvf - /etc | ssh user@remotehost <span class="hljs-string">&quot;tar -xvf - -C /destination&quot;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>数据备份和恢复</strong>：在备份过程中，将数据流式传输到备份存储设备或恢复到另一个位置</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="解压缩后的-SELinux-课题"><a href="#解压缩后的-SELinux-课题" class="headerlink" title="解压缩后的 SELinux 课题"></a>解压缩后的 SELinux 课题</h3><p>因为某些缘故你的系统必须要以备份的数据还原到系统中，要特别注意还原后系统的 SELinux 问题，尤其是在系统文件上面。SELinux 是比较特别的细部权限设置，以后再介绍，现在只要明白SELinux 的权限问题<code>可能会让系统无法存取某些配置</code>文件，导致影响系统的正常使用。</p>
<blockquote>
<p><strong>通过 tar 去备份<code>/etc</code>的数据，然后在另一部系统上面还原。还原完之后，无论如何就是无法正常的登陆系统，使用单人维护模式操作时一切正常</strong></p>
<p>这个问题很常见，大部分原因是因为 <code>/etc/shadow</code> 这个密码文件的 SELinux 类型在还原时被更改了，导致系统的登陆程序无法顺利的存取它，造成无法登陆。简单的处理方式有这几个：</p>
<ul>
<li>通过各种可行的救援方式登陆系统，然后修改 <code>/etc/selinux/config</code> 文件，将 SELinux 改成<code>permissive</code> 模式，重新开机后系统就正常了</li>
<li>在第一次还原系统后，不要立即重新开机，先使用 <code>restorecon -Rv /etc</code> 自动修复SELinux 的类型（推荐）</li>
<li>通过各种可行的方式登陆系统，创建 <code>/.autorelabel</code> 文件，重新开机后系统会自动修复SELinux 的类型，并且会再次重新开机，之后就正常了</li>
</ul>
</blockquote>
<h2 id="XFS文件系统的备份与还原"><a href="#XFS文件系统的备份与还原" class="headerlink" title="XFS文件系统的备份与还原"></a>XFS文件系统的备份与还原</h2><p>使用 tar 通常是针对目录树系统来进行备份的工作，如果想针对整个文件系统来进行备份与还原，就得使用<code>xfsdump</code>与 <code>xfsrestore</code> 两个工具。</p>
<h3 id="XFS文件系统备份-xfsdump"><a href="#XFS文件系统备份-xfsdump" class="headerlink" title="XFS文件系统备份 xfsdump"></a>XFS文件系统备份 xfsdump</h3><p><code>xfsdump</code> 功能很强，除了可以进行文件系统的<strong>完整备份</strong>（full backup）外，还可以进行<strong>累积备份</strong>（Incremental backup），<strong>累积备份：新备份的数据只会记录与第一次完整备份所有差异的文件</strong>。</p>
<p>第一次备份一定是完整备份，在 xfsdump 当中被定义为 <code>level 0</code> ；等到第二次备份时，文件系统内的数据已经与 level 0 不一样了，而 level 1 仅是比较目前的文件系统与 level 0 之间的差异后，备份有变化过的文件而已。依此类推 level 2 就是与 level 1 进行比较的差异。各个 level 的记录档放置于 <strong><code>/var/lib/xfsdump/inventory</code></strong> 中。</p>
<p>另外，使用 xfsdump 时，请注意下面的限制：</p>
<ul>
<li>只能备份<strong>已挂载</strong>的文件系统</li>
<li>必须使用 <strong><code>root</code></strong> 的权限才能操作（涉及文件系统的关系）</li>
<li>只能备份 XFS 文件系统</li>
<li>备份下来的数据（文件或储存媒体）只能让 <code>xfsrestore</code> 解析</li>
<li>通过文件系统的 <strong>UUID</strong>  来分辨各个备份文件，因此不能备份两个具有相同UUID 的文件系统</li>
<li>xfsdump 默认仅支持文件系统的备份，并不支持特定目录的备份</li>
</ul>
<h4 id="用-xfsdump-备份完整的文件系统"><a href="#用-xfsdump-备份完整的文件系统" class="headerlink" title="用 xfsdump 备份完整的文件系统"></a>用 xfsdump 备份完整的文件系统</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装xfsdump(如果没有安装的话)</span><br>[root@172-12-0-1 ~]# yum install xfsdump<br></code></pre></td></tr></table></figure>

<p>假设备份**<code>/boot</code>**：<code>xfsdump -l 0 -L boot_all -M boot_all -f /srv/boot.dump /boot</code></p>
<blockquote>
<p>选项与参数：</p>
<p>-L  ：xfsdump 会记录每次备份的 session 标头，这里可以填写针对此文件系统的简易说明</p>
<p>-M  ：xfsdump 可以记录储存媒体的标头，这里可以填写此媒体的简易说明</p>
<p>-l  ： L 小写，就是指定等级～有 0~9 共 10 个等级（默认为 0，即完整备份）</p>
<p>-f  ：后面接产生的文件，亦可接例如 &#x2F;dev&#x2F;st0 设备文件名或其他一般文件文件名等</p>
<p>-I  ：从 &#x2F;var&#x2F;lib&#x2F;xfsdump&#x2F;inventory 列出目前备份的信息状态</p>
</blockquote>
<h4 id="用-xfsdump-进行累积备份（Incremental-backups）"><a href="#用-xfsdump-进行累积备份（Incremental-backups）" class="headerlink" title="用 xfsdump 进行累积备份（Incremental backups）"></a>用 xfsdump 进行累积备份（Incremental backups）</h4><p>一定要进行过<strong>完整备份</strong>后（-l 0）才能够进行累积备份（-l 1~9），<code>xfsdump -I</code>查看</p>
<p>累积备份示例：</p>
<p>创建一个文件在&#x2F;boot：<code>dd if=/dev/zero of=/boot/testing.img bs=1M count=10</code></p>
<p>备份：<code>xfsdump -l 1 -L boot_2 -M boot_2 -f /srv/boot.dump1 /boot</code></p>
<h3 id="XFS-文件系统还原-xfsrestore"><a href="#XFS-文件系统还原-xfsrestore" class="headerlink" title="XFS 文件系统还原 xfsrestore"></a>XFS 文件系统还原 xfsrestore</h3><h4 id="用-xfsrestore-观察-xfsdump-后的备份数据内容"><a href="#用-xfsrestore-观察-xfsdump-后的备份数据内容" class="headerlink" title="用 xfsrestore 观察 xfsdump 后的备份数据内容"></a>用 xfsrestore 观察 xfsdump 后的备份数据内容</h4><p>查看备份文件：<code>xfsrestore -I</code> </p>
<h4 id="简单还原-level-0-的文件系统"><a href="#简单还原-level-0-的文件系统" class="headerlink" title="简单还原 level 0 的文件系统"></a>简单还原 level 0 的文件系统</h4><p>想要将 <code>/boot</code> 还原到最原本的状态，只要知道被还原的那个文件，以及该文件的 <code>session label name</code>，就可以了，假设 level 0 的 session label 是<code>boot_all</code>，那整个流程是这样的：</p>
<ul>
<li>第一种，直接将数据覆盖回去：<code>xfsrestore -f /srv/boot.dump -L boot_all /boot</code></li>
<li>第二种，将备份数据在 &#x2F;tmp&#x2F;boot 下面解开：<ul>
<li><code>mkdir /tmp/boot</code></li>
<li><code>xfsrestore -f /srv/boot.dump -L boot_all /tmp/boot</code></li>
</ul>
</li>
<li>比较两个目录内的文件差异：<code>diff -r /boot /tmp/boot</code></li>
</ul>
<p>同名的文件会被覆盖，其他系统内新的文件会被保留</p>
<blockquote>
<p><strong>只想还原某一个目录或文件，直接加上<code>-s 目录</code>即可</strong></p>
<p>仅复原备份文件内的 grub2 到 &#x2F;tmp&#x2F;boot2&#x2F; 里</p>
<p><code>mkdir /tmp/boot2</code></p>
<p><code>xfsrestore -f /srv/boot.dump -L boot_all -s grub2 /tmp/boot2</code></p>
</blockquote>
<h4 id="还原累积备份数据"><a href="#还原累积备份数据" class="headerlink" title="还原累积备份数据"></a>还原累积备份数据</h4><p>继续复原 level 1 到 &#x2F;tmp&#x2F;boot 当中</p>
<p><code>xfsrestore -f /srv/boot.dump1 /tmp/boot</code></p>
<h2 id="光盘写入工具"><a href="#光盘写入工具" class="headerlink" title="光盘写入工具"></a>光盘写入工具</h2><p>DVD&#x2F;CD光盘烧录步骤：</p>
<ul>
<li><p>先将所需要备份的数据创建成为一个镜像文件（iso），利用 mkisofs 指令来处理</p>
</li>
<li><p>将该镜像文件烧录至光盘或 DVD 当中，利用 cdrecord 指令来处理</p>
</li>
</ul>
<h3 id="mkisofs：创建镜像文件"><a href="#mkisofs：创建镜像文件" class="headerlink" title="mkisofs：创建镜像文件"></a>mkisofs：创建镜像文件</h3><p>烧录可开机与不可开机的光盘，使用的方法不太一样</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装mkisofs</span><br>[root@172-12-0-1 ~]# yum install mkisofs<br></code></pre></td></tr></table></figure>

<ul>
<li><p>制作一般数据光盘镜像文件</p>
<p><code>mkisofs -r -v -o /tmp/system.img /root /home /etc</code></p>
</li>
<li><p>制作&#x2F;修改可开机光盘</p>
<p>制作<code>一键安装</code>的安装光盘，要修改原版的光盘镜像文件，改成自动载入某些程序的流程，让这片光盘放入主机光驱后，只要开机就直接安装系统（<code>kickstart</code> 相关技术等）</p>
<p>以CentOS-7.iso为例 ，放在&#x2F;home 下面，之后将里头的数据进行修改，假设新的镜像文件目录放置于 &#x2F;srv&#x2F;newcd里面</p>
<blockquote>
<p>rsync 可以完整的复制所有的权限属性等数据，也能够进行镜像处理</p>
</blockquote>
<ul>
<li>查看光盘里面有啥：<code>isoinfo -d -i /home/CentOS-7.iso</code></li>
<li>挂载光盘到 <code>/mnt</code> ，并将所有数据复制到 <code>/srv/newcd</code> 目录：<ul>
<li><code>mount /home/CentOS-7.iso /mnt</code></li>
<li><code>mkdir /srv/newcd</code></li>
<li><code>rsync -a /mnt/ /srv/newcd</code></li>
</ul>
</li>
<li>创建iso<ul>
<li><code>cd /srv/newcd</code></li>
<li><code>mkisofs -o /custom.iso -b isolinux/isolinux.bin -c isolinux/boot.cat \ -no-emul-boot -V &#39;CentOS 7 x86_64&#39; -boot-load-size 4 -boot-info-table -R -J -v -T .</code><ul>
<li><code> -o /custom.iso</code>： 指定输出的 ISO 镜像文件名</li>
<li><code>-b isolinux/isolinux.bin</code>: 指定启动引导程序的路径</li>
<li><code>-c isolinux/boot.cat</code>: 指定启动映像的目录和引导目录文件（boot catalog）</li>
<li><code>-no-emul-boot</code>：指定 ISO 镜像使用的引导模式为“无仿真”（no-emulation），适用于直接引导操作系统</li>
<li><code>-V &#39;CentOS 7 x86_64&#39;</code>：指定 ISO 镜像的卷标（volume label）</li>
<li><code>-boot-load-size 4</code>：指定引导加载区的大小（以块为单位）</li>
<li><code>-boot-info-table</code>：在 ISO 镜像中包含引导信息表</li>
<li><code>.</code>：指定当前目录（<code>.</code>）作为 ISO 镜像的源目录</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="cdrecord：光盘烧录工具"><a href="#cdrecord：光盘烧录工具" class="headerlink" title="cdrecord：光盘烧录工具"></a>cdrecord：光盘烧录工具</h3><p>CentOS 7 后使用的是 <code>wodim</code> 这个文字界面指令来进行烧录的行为，wodim兼容<code>cdrecord</code> </p>
<ul>
<li>列出可用设备</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wodim --devices<br></code></pre></td></tr></table></figure>

<ul>
<li>刻录ISO镜像</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># dev=/dev/cdrom：指定要使用的设备，可改成自己的设备路径`/dev/sr0`</span><br><span class="hljs-comment"># -eject：刻录完成后自动弹出光盘</span><br>wodim dev=/dev/cdrom -v -eject /path/to/image.iso<br></code></pre></td></tr></table></figure>

<h2 id="其他常见的压缩与备份命令"><a href="#其他常见的压缩与备份命令" class="headerlink" title="其他常见的压缩与备份命令"></a>其他常见的压缩与备份命令</h2><h3 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h3><p><code>dd</code> 是一个强大的 Linux 命令行工具，用于低级别的文件和磁盘操作。它可以用于复制和转换数据，创建备份、恢复数据、制作启动盘、测试磁盘性能等，<strong>能覆盖原有数据</strong></p>
<p>基本语法：<code>dd if=&lt;input_file&gt; of=&lt;output_file&gt; [options]</code></p>
<p>常见选项：</p>
<ul>
<li>**<code>bs=&lt;size&gt;</code>**：设置块大小（block size）。例如，<code>bs=4M</code> 表示使用 4 兆字节的块</li>
<li>**<code>count=&lt;number&gt;</code>**：指定要复制的块数。例如，<code>count=10</code> 表示复制 10 个块</li>
<li>**<code>skip=&lt;number&gt;</code>**：在开始读取之前跳过的块数。例如，<code>skip=1</code> 会跳过输入文件的第一个块</li>
<li>**<code>seek=&lt;number&gt;</code>**：在开始写入之前跳过的块数。例如，<code>seek=1</code> 会在输出文件中跳过第一个块</li>
<li>**<code>conv=&lt;conversion&gt;</code>**：指定转换选项，如 <code>notrunc</code>（不截断文件）、<code>sync</code>（填充块）、<code>noerror</code>（忽略读取错误）等</li>
</ul>
<p>用法示例：</p>
<ul>
<li><p>创建磁盘映像：</p>
<ul>
<li><p>将磁盘 <code>/dev/sdX</code>（例如 <code>/dev/sda</code>）的内容复制到一个映像文件 <code>disk.img</code> 中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">dd if=/dev/sdX of=disk.img bs=4M<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>恢复磁盘映像</p>
<ul>
<li><p>将之前创建的磁盘映像 <code>disk.img</code> 恢复到磁盘 <code>/dev/sdX</code> 中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=disk.img of=/dev/sdX bs=4M<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>制作启动 USB</p>
<ul>
<li><p>将 ISO 镜像 <code>ubuntu.iso</code> 刻录到 USB 驱动器 <code>/dev/sdX</code>（注意选择正确的设备路径，以避免数据丢失）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#  status=progress 会显示进度信息</span><br><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=ubuntu.iso of=/dev/sdX bs=4M status=progress<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>创建空文件</p>
<ul>
<li><p>创建一个指定大小的空文件，例如创建一个 1 GB 的空文件 <code>empty.img</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/zero of=empty.img bs=1G count=1<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>从设备创建备份</p>
<ul>
<li><p>备份 <code>/dev/sda1</code> 分区到一个文件 <code>backup.img</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/sda1 of=backup.img bs=1M<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>检测磁盘性能</p>
<ul>
<li><p>测试磁盘的写入速度</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">dd</span> <span class="hljs-keyword">if</span>=/dev/zero of=testfile bs=1G count=1 oflag=dsync<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="cpio"><a href="#cpio" class="headerlink" title="cpio"></a>cpio</h3><p><code>cpio</code> 是一个用于创建、提取和管理归档文件的命令行工具，常用于备份和恢复文件系统。它可以读取、写入、和提取各种归档格式（如 cpio 格式）</p>
<h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cpio [options] &lt;archive_file<br></code></pre></td></tr></table></figure>

<h4 id="常见选项和操作模式"><a href="#常见选项和操作模式" class="headerlink" title="常见选项和操作模式"></a>常见选项和操作模式</h4><ol>
<li><p><strong>创建归档（Create）</strong></p>
<ul>
<li><strong><code>-o</code></strong> 或 **<code>--create</code>**：创建一个新的归档</li>
<li><strong><code>-H</code></strong> 或 **<code>--format=&lt;format&gt;</code>**：指定归档格式，如 <code>newc</code>、<code>odc</code>、<code>crc</code> 等（<code>newc</code> 是最常用的格式）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 将 `/path/to/files` 目录中的所有文件传递给 `cpio`，创建一个 `archive.cpio` 的归档文件</span><br><span class="hljs-built_in">cd</span> /path/to/files<br>find . -<span class="hljs-built_in">print</span> | cpio -o &gt; archive.cpio<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>提取归档（Extract）</strong></p>
<ul>
<li><strong><code>-i</code></strong> 或 **<code>--extract</code>**：从归档中提取文件</li>
<li>**<code>-d</code>**：在提取时创建目录（如果归档中包含目录结构）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 从 `archive.cpio` 中提取文件到当前目录</span><br>cpio -i &lt; archive.cpio<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>列出归档内容（List）</strong></p>
<ul>
<li><strong><code>-t</code></strong> 或 **<code>--list</code>**：列出归档中的文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cpio -t &lt; archive.cpio<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>更新归档（Copy Pass-through）</strong></p>
<ul>
<li>**<code>-u</code>**：更新现有归档中的文件（如果文件已经存在）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 将 `/path/to/files` 目录中的所有文件添加到 `archive.cpio` 归档中，并更新已存在的文件</span><br>find /path/to/files -<span class="hljs-built_in">print</span> | cpio -u -o &gt; archive.cpio<br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="其他选项"><a href="#其他选项" class="headerlink" title="其他选项"></a>其他选项</h4><ul>
<li>**<code>-v</code>**：启用详细模式，显示处理的文件名</li>
<li>**<code>-C &lt;size&gt;</code>**：设置每个磁带文件的大小（用于磁带归档时）</li>
<li>**<code>-H &lt;format&gt;</code>**：指定归档格式（如 <code>newc</code>、<code>odc</code>）。</li>
</ul>
<hr>
<h1 id="七、BASH"><a href="#七、BASH" class="headerlink" title="七、BASH"></a>七、BASH</h1><p><strong>Shell</strong></p>
<ul>
<li><strong>定义</strong>：Shell 是一个命令行解释器，它接受用户输入的命令并将其传递给操作系统执行。Shell 提供了一个与操作系统交互的界面，可以执行命令、启动程序、管理文件等</li>
<li>类型：<ul>
<li>**Bourne Shell (sh)**：最早的 Unix Shell，基本功能</li>
<li>**C Shell (csh)**：引入了 C 语言风格的语法</li>
<li>**Korn Shell (ksh)**：结合了 Bourne Shell 和 C Shell 的功能</li>
<li>**Bash (Bourne Again Shell)**：Bourne Shell 的增强版本，支持更多功能和改进</li>
</ul>
</li>
</ul>
<p><strong>Bash</strong></p>
<ul>
<li><strong>定义</strong>：Bash 是一种 Unix Shell，意为 <code>Bourne Again Shell</code>，是 GNU 项目的一部分。它是最常用的 Shell，提供了 Bourne Shell 的兼容性，并增加了许多新功能。</li>
<li>特性：<ul>
<li><strong>命令行编辑</strong>：支持命令历史记录(<strong>前一次登录执行命令记录在<code>.bash_history </code></strong>)、自动补全、编辑模式等</li>
<li><strong>脚本编程</strong>：支持条件语句、循环、函数等编程构造</li>
<li><strong>变量和数组</strong>：提供更强大的变量和数组操作</li>
<li><strong>扩展功能</strong>：如正则表达式、算术扩展、进程替代等</li>
<li><strong>用户自定义</strong>：支持自定义提示符、别名（例如：<code>alias lm=&#39;ls -al&#39;</code>）、函数等</li>
</ul>
</li>
</ul>
<blockquote>
<p>为什么系统上合法的 shell 要写入 &#x2F;etc&#x2F;shells 这个文件？</p>
<p>这是因为系统某些服务在运行过程中，会去检查使用者能够使用的 shells ，而这些shell 的查询就是借由 &#x2F;etc&#x2F;shells 这个文件</p>
</blockquote>
<blockquote>
<p>使用者默认会取得哪一个 shell ?</p>
<p>查看&#x2F;etc&#x2F;passwd文件，其中&#x2F;sbin&#x2F;nologin的意思是：让使用者无法以其他服务登陆主机</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@172-12-0-1 ~]# <span class="hljs-built_in">cat</span> /etc/passwd<br>root:x:0:0:root:/root:/bin/bash<br>bin:x:1:1:bin:/bin:/sbin/nologin<br>daemon:x:2:2:daemon:/sbin:/sbin/nologin<br></code></pre></td></tr></table></figure>
</blockquote>
<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><table>
<thead>
<tr>
<th>组合键</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>\[Enter]</code></td>
<td>换行</td>
</tr>
<tr>
<td>[CTRL] + u&#x2F;k</td>
<td>向前&#x2F;向后删除指令</td>
</tr>
<tr>
<td>[CTRL] + a&#x2F;e</td>
<td>移动光标到最前&#x2F;最后</td>
</tr>
</tbody></table>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>定义：变量就是以一组文字或符号等，来取代一些设置或者是一串保留的数据</p>
<ul>
<li><p>环境变量：通常以大写字符表示，PATH、HOME、MAIL等</p>
</li>
<li><p>自定义变量</p>
</li>
</ul>
<h3 id="变量的取用与设置：echo，变量设置规则：unset"><a href="#变量的取用与设置：echo，变量设置规则：unset" class="headerlink" title="变量的取用与设置：echo，变量设置规则：unset"></a>变量的取用与设置：echo，变量设置规则：unset</h3><ul>
<li><p>ehco：<code>echo $变量名 </code>或 <code>echo $&#123;变量名&#125;</code></p>
</li>
<li><p>unset：<code>unset 变量名称</code></p>
</li>
<li><p>设置：变量名&#x3D;内容，<code>=</code>两边不能有空格，若有空格可以使用<strong>双引号或单引号</strong>括起来</p>
<ul>
<li><strong>双引号</strong>内的特殊字符如 <code>$</code>等，可以保有原本的特性， <code>var=&quot;lang is $LANG&quot;</code>，则<code>echo $var</code>输出lang is zh_CN.UTF-8</li>
<li><strong>单引号</strong>内的特殊字符则仅为一般字符（纯文本），<code>var=&#39;lang is $LANG&#39;</code>则<code>echo $var</code>输出lang is $LANG</li>
<li>在一串指令的执行中，需要借由其他额外的指令所提供的信息时，可以使用反单引号<code>指令</code>或 $(指令)</li>
<li>增加变量内容：<code>PATH=&quot;$PATH&quot;:/home/bin</code></li>
<li>若该变量需要在其他子程序执行，需要变成环境变量：<code>expot PATH</code></li>
</ul>
</li>
<li><p>取消变量：<code>unset 变量名称</code></p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@172-12-0-1 ~]# myName=DrJuly<br>[root@172-12-0-1 ~]# <span class="hljs-built_in">echo</span> <span class="hljs-variable">$myName</span><br>DrJuly<br><br>[root@172-12-0-1 ~]# <span class="hljs-built_in">cd</span> /lib/modules/`<span class="hljs-built_in">uname</span> -r`/kernel<br>[root@172-12-0-1 ~]# <span class="hljs-built_in">cd</span> /lib/modules/$(<span class="hljs-built_in">uname</span> -r)/kernel<br></code></pre></td></tr></table></figure>

<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>列出目前的shell环境下的所有环境变量与内容：<code>env</code></p>
<p>观察所有变量（含环境变量和自定义变量）：<code>set</code></p>
<p>自定义变量转成环境变量：<code>export 变量名</code>，只有 <code>export</code>时会列出所有环境变量</p>
<h3 id="变量键盘读取、数组与宣告"><a href="#变量键盘读取、数组与宣告" class="headerlink" title="变量键盘读取、数组与宣告"></a>变量键盘读取、数组与宣告</h3><p>读取用户输入数据：<code>read</code> [-pt] 变量名，<code>-p</code>：提示字符，<code>-t</code>等待秒数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@172-12-0-1 /]# <span class="hljs-built_in">read</span> -p <span class="hljs-string">&quot;Please keyin your name: &quot;</span> -t 30 named<br>Please keyin your name: DrJuly<br>[root@172-12-0-1 /]# <span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;named&#125;</span><br>DrJuly<br></code></pre></td></tr></table></figure>

<p>宣告变量的类型：<code>declare</code>或<code>typeset</code></p>
<ul>
<li><p>declare [-aixr] 变量名</p>
<ul>
<li><p>选项与参数：</p>
<p><code>-a</code>  ：将变量定义为数组（array）类型</p>
<ul>
<li><pre><code class="bash">[root@172-12-0-1 ~]# var[1]=&quot;small min&quot;
[root@172-12-0-1 ~]# var[2]=&quot;big min&quot;
[root@172-12-0-1 ~]# var[3]=&quot;nice min&quot;
[root@172-12-0-1 ~]# echo &quot;$&#123;var[1]&#125;, $&#123;var[2]&#125;, $&#123;var[3]&#125;&quot;
small min, big min, nice min
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"><br>    `-i`  ：将变量定义为整数（integer）类型，`declare -i sum=100+300+50`，bash数值计算默认只能取整，`1/3`结果是0<br><br>    `-x`  ：用法与 export 一样，将变量 变成环境变量<br><br>    - 变成环境变量：`declare -x sum`<br>    - 取消：`declare +x sum`<br><br>    `-r`  ：将变量设置为 `readonly` 类型，该变量不可被更改内容，也不能 unset<br><br>    `-p`：可以单独列出变量的类型<br><br>## 与文件系统及程序的限制关系： ulimit<br><br>&gt; 如果 Linux 主机里面同时登录了十个人，每个人都同时打开了 100 个文件，每个文件的大小约 10MBytes ，那 Linux 主机的内存要有 10*100*10 = 10000 MBytes = 10GBytes， 系统肯定会挂掉。<br><br>`ulimit` 是一个用于设置和显示用户进程的资源限制的命令，通常用于控制系统资源的使用，例如文件大小、内存使用等。这些限制帮助防止系统资源被过度消耗，影响系统稳定性<br><br>### 基本用法<br><br>1. **查看当前限制**<br><br>   ```bash<br>   ulimit -a<br></code></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li><p><strong>设置资源限制</strong></p>
<ul>
<li><p><strong>文件大小限制</strong>（以字节为单位）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ulimit</span> -f &lt;size&gt;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>进程数限制</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ulimit</span> -u &lt;number&gt;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>堆栈大小限制</strong>（以字节为单位）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ulimit</span> -s &lt;size&gt;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>最大打开文件数</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ulimit</span> -n &lt;number&gt;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>最大用户进程数</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ulimit</span> -u &lt;number&gt;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>最大文件大小</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ulimit</span> -f &lt;size&gt;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>永久修改限制</strong></p>
<p>对于永久修改 <code>ulimit</code> 限制，需要编辑系统配置文件，如 <code>/etc/security/limits.conf</code>（适用于 Linux）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">username soft nofile 4096<br>username hard nofile 8192<br></code></pre></td></tr></table></figure>

<ul>
<li><code>soft</code> 限制是当前会话的限制。</li>
<li><code>hard</code> 限制是系统允许的最大限制。</li>
</ul>
</li>
</ol>
<h2 id="变量内容的删除、取代与替换"><a href="#变量内容的删除、取代与替换" class="headerlink" title="变量内容的删除、取代与替换"></a>变量内容的删除、取代与替换</h2><h3 id="1-删除变量内容的前缀或后缀"><a href="#1-删除变量内容的前缀或后缀" class="headerlink" title="1. 删除变量内容的前缀或后缀"></a><strong>1. 删除变量内容的前缀或后缀</strong></h3><ul>
<li><p><strong>删除前缀</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$&#123;variable#pattern&#125;</span><br></code></pre></td></tr></table></figure>

<p>这个语法会删除变量 <code>variable</code> 中匹配 <code>pattern</code> 的最短前缀。<code>#</code> 表示删除最短匹配的前缀，<code>##</code> 表示删除最长匹配的前缀。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">path=<span class="hljs-string">&quot;/home/user/file.txt&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;path#/home/&#125;</span>  <span class="hljs-comment"># 输出 &quot;user/file.txt&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;path##*/&#125;</span>     <span class="hljs-comment"># 输出 &quot;file.txt&quot;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>删除后缀</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$&#123;variable%pattern&#125;</span><br></code></pre></td></tr></table></figure>

<p>这个语法会删除变量 <code>variable</code> 中匹配 <code>pattern</code> 的最短后缀。<code>%</code> 表示删除最短匹配的后缀，<code>%%</code> 表示删除最长匹配的后缀。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">path=<span class="hljs-string">&quot;/home/user/file.txt&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;path%.txt&#125;</span>   <span class="hljs-comment"># 输出 &quot;/home/user/file&quot;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-替换变量内容"><a href="#2-替换变量内容" class="headerlink" title="2. 替换变量内容"></a><strong>2. 替换变量内容</strong></h3><ul>
<li><p><strong>简单替换</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$&#123;variable/old/new&#125;</span><br></code></pre></td></tr></table></figure>

<p>这个语法会将变量 <code>variable</code> 中第一个匹配 <code>old</code> 的部分替换为 <code>new</code>。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">path=<span class="hljs-string">&quot;/home/user/file.txt&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;path/.txt/.bak&#125;</span>  <span class="hljs-comment"># 输出 &quot;/home/user/file.bak&quot;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>全局替换</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$&#123;variable//old/new&#125;</span><br></code></pre></td></tr></table></figure>

<p>这个语法会将变量 <code>variable</code> 中所有匹配 <code>old</code> 的部分替换为 <code>new</code>。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">path=<span class="hljs-string">&quot;/home/user/file.txt.txt&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;path//.txt/.bak&#125;</span>  <span class="hljs-comment"># 输出 &quot;/home/user/file.bak.bak&quot;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="3、变量的测试和内容替换"><a href="#3、变量的测试和内容替换" class="headerlink" title="3、变量的测试和内容替换"></a>3、变量的测试和内容替换</h3><ul>
<li><p>如果变量没设置，能够以后面的内容替换</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">username=<span class="hljs-variable">$&#123;username-root&#125;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>如果变量内容为空或者是未设置，能够以后面的内容替换</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">username=<span class="hljs-variable">$&#123;username:-root</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>将旧变量内容也一起替换掉，用 <code>=</code></p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@172-12-0-1 ~]# <span class="hljs-built_in">unset</span> str<br>[root@172-12-0-1 ~]# var=<span class="hljs-variable">$&#123;str=mewvar&#125;</span><br>[root@172-12-0-1 ~]# <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;var=<span class="hljs-variable">$&#123;var&#125;</span>,str=<span class="hljs-variable">$&#123;str&#125;</span>&quot;</span><br>var=mewvar,str=mewvar<br><br>[root@172-12-0-1 ~]# str=<span class="hljs-string">&quot;oldval&quot;</span><br>[root@172-12-0-1 ~]# var=<span class="hljs-variable">$&#123;str=newval&#125;</span><br>[root@172-12-0-1 ~]# <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;var=<span class="hljs-variable">$&#123;var&#125;</span>,str=<span class="hljs-variable">$&#123;str&#125;</span>&quot;</span><br>var=oldval,str=oldval<br></code></pre></td></tr></table></figure>

<ul>
<li>如果旧变量不存在，报错提示，用 <code>？</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@172-12-0-1 ~]# <span class="hljs-built_in">unset</span> str<br>[root@172-12-0-1 ~]# var=<span class="hljs-variable">$&#123;str?无此变量&#125;</span><br>-bash: str: 无此变量<br><br>[root@172-12-0-1 ~]# str=<span class="hljs-string">&quot;oldval&quot;</span>; var=<span class="hljs-variable">$&#123;str?无此变量&#125;</span><br>[root@172-12-0-1 ~]# <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;var=<span class="hljs-variable">$&#123;var&#125;</span>, str=<span class="hljs-variable">$&#123;str&#125;</span>&quot;</span><br>var=oldval, str=oldval<br></code></pre></td></tr></table></figure>

<h2 id="命令别名设置：alias、unalias"><a href="#命令别名设置：alias、unalias" class="headerlink" title="命令别名设置：alias、unalias"></a>命令别名设置：alias、unalias</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 设置别名</span><br>[root@172-12-0-1 ~]# <span class="hljs-built_in">alias</span> lm=<span class="hljs-string">&#x27;ls -al | more&#x27;</span><br><br><span class="hljs-comment"># 取消别名设置</span><br>[root@172-12-0-1 ~]# <span class="hljs-built_in">unalias</span> lm<br></code></pre></td></tr></table></figure>

































<p>十一、认识与学习BASH</p>
<p>十二、正则表达式与文件格式化处理</p>
<p>十三、学习Shell Scripts</p>
<p>十四、Linux账号管理与ACL权限设置</p>
<p>十五、磁盘配额（Quota）与进阶文件系统管理</p>
<p>十六、例行组工作调度（crontab）</p>
<p>十七、程序管理与SELinux初探</p>
<p>十八、认识系统服务（daemons）</p>
<p>十九、认识与分析登录文件</p>
<p>二十、开机流程、模块管理与Loader</p>
<p>二十一、基础系统设置与备份策略</p>
<p>二十二、软件安装：源代码与TarBall</p>
<p>二十三、软件安装：RPM、SRPM与YUM</p>
<p>二十四、X WINDOW设置介绍</p>
<p>二十五、Linux核心编译与管理</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">DrJuly2333</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2024/08/10/%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">http://example.com/2024/08/10/%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/09/15/JAVA%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/" title="JAVA面试八股文基础篇"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous</div><div class="prev_info">JAVA面试八股文基础篇</div></div></a></div><div class="next-post pull-right"><a href="/2024/08/05/Linux%E5%85%A5%E9%97%A8/" title="Linux入门"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">Linux入门</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2024/08/05/Linux%E5%85%A5%E9%97%A8/" title="Linux入门"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-08-05</div><div class="title">Linux入门</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">DrJuly2333</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">8</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/DrJuly2333" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:HTTTS2022@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">欢迎光临小站，这里是我日常收集和整理的总结，希望能对您有所帮助：）<br/><br/>本站的内容经过个人加工总结而来，也参考了网友们分享的资料，如有侵权，请第一时间联系我，我将及时进行修改和删除</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">一、计算机概论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU-%E6%9E%B6%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">CPU 架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU%E7%9A%84%E5%B7%A5%E4%BD%9C%E9%A2%91%E7%8E%87"><span class="toc-number">1.1.1.</span> <span class="toc-text">CPU的工作频率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%A2%91%E4%B8%8E%E5%80%8D%E9%A2%91"><span class="toc-number">1.1.2.</span> <span class="toc-text">外频与倍频</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98"><span class="toc-number">1.2.</span> <span class="toc-text">内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DRAM"><span class="toc-number">1.2.1.</span> <span class="toc-text">DRAM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%AE%B9%E9%87%8F"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">内存容量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E9%80%9A%E9%81%93"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">多通道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%BF%A1%E9%81%93"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">内存信道</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%92%8C%E5%8A%9F%E8%83%BD"><span class="toc-number">1.2.1.3.1.</span> <span class="toc-text">作用和功能</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU%E5%86%85%E9%83%A8%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98"><span class="toc-number">1.2.2.</span> <span class="toc-text">CPU内部高速缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">层次结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%B8%AD%E5%92%8C%E5%A4%B1%E6%95%88"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">命中和失效</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ROM%EF%BC%88Read-Only-Memory%EF%BC%8C%E5%8F%AA%E8%AF%BB%E5%AD%98%E5%82%A8%E5%99%A8%EF%BC%89"><span class="toc-number">1.2.3.</span> <span class="toc-text">ROM（Read-Only Memory，只读存储器）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E5%8D%A1"><span class="toc-number">1.3.</span> <span class="toc-text">显卡</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PCIe"><span class="toc-number">1.3.1.</span> <span class="toc-text">PCIe</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E7%9B%98%E5%92%8C%E5%82%A8%E5%AD%98%E8%AE%BE%E5%A4%87"><span class="toc-number">1.4.</span> <span class="toc-text">硬盘和储存设备</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%92%8C%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.0.1.</span> <span class="toc-text">结构和工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E5%92%8C%E7%A3%81%E5%A4%B4"><span class="toc-number">1.4.0.1.1.</span> <span class="toc-text">磁盘和磁头</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">1.4.0.1.2.</span> <span class="toc-text">数据存储原理：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-number">1.4.0.1.3.</span> <span class="toc-text">工作过程：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">1.4.0.2.</span> <span class="toc-text">分类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E7%A1%AC%E7%9B%98%E9%A9%B1%E5%8A%A8%E5%99%A8%EF%BC%88HDD%EF%BC%89%EF%BC%9A"><span class="toc-number">1.4.0.2.1.</span> <span class="toc-text">传统硬盘驱动器（HDD）：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98%EF%BC%88SSD%EF%BC%89%EF%BC%9A"><span class="toc-number">1.4.0.2.2.</span> <span class="toc-text">固态硬盘（SSD）：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%92%8C%E8%AE%BF%E9%97%AE%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.0.3.</span> <span class="toc-text">数据存储和访问的物理结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%87%E5%8C%BA%EF%BC%88Sector%EF%BC%89"><span class="toc-number">1.4.0.3.1.</span> <span class="toc-text">扇区（Sector）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A3%81%E9%81%93%EF%BC%88Track%EF%BC%89"><span class="toc-number">1.4.0.3.2.</span> <span class="toc-text">磁道（Track）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%B1%E9%9D%A2%EF%BC%88Cylinder%EF%BC%89"><span class="toc-number">1.4.0.3.3.</span> <span class="toc-text">柱面（Cylinder）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%B8%83%E5%B1%80%E5%92%8C%E4%BC%98%E5%8C%96"><span class="toc-number">1.4.0.3.4.</span> <span class="toc-text">物理布局和优化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E8%A1%A8"><span class="toc-number">1.4.0.4.</span> <span class="toc-text">分区表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#MBR%EF%BC%88Master-Boot-Record%EF%BC%89"><span class="toc-number">1.4.0.4.1.</span> <span class="toc-text">MBR（Master Boot Record）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#GPT%EF%BC%88GUID-Partition-Table%EF%BC%89"><span class="toc-number">1.4.0.4.2.</span> <span class="toc-text">GPT（GUID Partition Table）</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Linux%E5%AD%A6%E4%B9%A0"><span class="toc-number">2.</span> <span class="toc-text">二、Linux学习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E6%A0%91%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">目录树结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%82%E8%BD%BD%EF%BC%88%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%9B%AE%E5%BD%95%E6%A0%91%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%89"><span class="toc-number">2.2.</span> <span class="toc-text">挂载（文件系统与目录树的关系）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85"><span class="toc-number">2.3.</span> <span class="toc-text">Linux系统安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Kickstart-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">2.3.1.</span> <span class="toc-text">Kickstart 配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">使用步骤</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.4.</span> <span class="toc-text">命令格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4"><span class="toc-number">2.5.</span> <span class="toc-text">基础指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98"><span class="toc-number">2.6.</span> <span class="toc-text">中文乱码问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E8%AF%AD%E8%A8%80"><span class="toc-number">2.6.1.</span> <span class="toc-text">修改语言</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%99%A8%EF%BC%9Abc"><span class="toc-number">2.7.</span> <span class="toc-text">计算器：bc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tab%E4%BB%A3%E7%A0%81%E8%A1%A5%E5%85%A8"><span class="toc-number">2.8.</span> <span class="toc-text">Tab代码补全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%A1%A5%E5%85%A8"><span class="toc-number">2.8.1.</span> <span class="toc-text">代码补全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-%E9%80%89%E9%A1%B9%E8%A1%A5%E9%BD%90"><span class="toc-number">2.8.2.</span> <span class="toc-text">参数&#x2F;选项补齐</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%91%E5%89%8D%E5%90%91%E5%90%8E%E7%BF%BB%E9%A1%B5"><span class="toc-number">2.9.</span> <span class="toc-text">向前向后翻页</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3"><span class="toc-number">2.10.</span> <span class="toc-text">命令帮助文档</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%9A%84help%E6%B1%82%E5%8A%A9"><span class="toc-number">2.10.1.</span> <span class="toc-text">指令的help求助</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#man-page"><span class="toc-number">2.10.2.</span> <span class="toc-text">man page</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%90%9C%E5%AF%BB%E7%89%B9%E5%AE%9A%E6%8C%87%E4%BB%A4-%E6%96%87%E4%BB%B6%E7%9A%84man-page%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3"><span class="toc-number">2.10.2.1.</span> <span class="toc-text">搜寻特定指令&#x2F;文件的man page说明文档</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#info-page"><span class="toc-number">2.10.3.</span> <span class="toc-text">info page</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%9C%89%E7%94%A8%E7%9A%84%E6%96%87%E4%BB%B6%EF%BC%88documents%EF%BC%89"><span class="toc-number">2.10.4.</span> <span class="toc-text">其他有用的文件（documents）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E6%9C%BA"><span class="toc-number">2.11.</span> <span class="toc-text">关机</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81Linux%E7%9A%84%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE"><span class="toc-number">3.</span> <span class="toc-text">三、Linux的文件权限与目录配置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90"><span class="toc-number">3.1.</span> <span class="toc-text">文件权限</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ls-al-%E6%98%BE%E7%A4%BA%E5%AD%97%E6%AE%B5%E8%A7%A3%E9%87%8A"><span class="toc-number">3.1.1.</span> <span class="toc-text">ls -al 显示字段解释</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%9D%83%E9%99%90-%E7%AC%AC1%E4%B8%AA%E5%8F%82%E6%95%B0"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">文件类型和权限(第1个参数)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E9%93%BE%E6%8E%A5%E6%95%B0%E9%87%8F%EF%BC%88%E7%AC%AC2%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%89"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">硬链接数量（第2个参数）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%80%E6%9C%89%E8%80%85%EF%BC%88%E7%AC%AC3%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%89"><span class="toc-number">3.1.1.3.</span> <span class="toc-text">所有者（第3个参数）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%80%E5%B1%9E%E7%BB%84%EF%BC%88%E7%AC%AC4%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%89"><span class="toc-number">3.1.1.4.</span> <span class="toc-text">所属组（第4个参数）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%EF%BC%88%E7%AC%AC5%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%89"><span class="toc-number">3.1.1.5.</span> <span class="toc-text">文件大小（第5个参数）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9%E6%97%B6%E9%97%B4%EF%BC%88%E7%AC%AC6%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%89"><span class="toc-number">3.1.1.6.</span> <span class="toc-text">文件修改时间（第6个参数）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%90%8D%EF%BC%88%E7%AC%AC7%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%89"><span class="toc-number">3.1.1.7.</span> <span class="toc-text">文件名（第7个参数）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E5%92%8C%E6%9D%83%E9%99%90"><span class="toc-number">3.2.</span> <span class="toc-text">改变文件属性和权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FHS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.3.</span> <span class="toc-text">FHS文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E7%9B%AE%E5%BD%95%E5%92%8C%E5%85%B6%E5%90%AB%E4%B9%89"><span class="toc-number">3.3.1.</span> <span class="toc-text">主要目录和其含义</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Linux%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">四、Linux文件与目录管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E4%B8%8E%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84"><span class="toc-number">4.1.</span> <span class="toc-text">绝对路径与相对路径</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%9A%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C"><span class="toc-number">4.2.</span> <span class="toc-text">目录的相关操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E5%8F%98%E9%87%8F%EF%BC%88%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%EF%BC%89%EF%BC%9A-PATH"><span class="toc-number">4.3.</span> <span class="toc-text">可执行文件路径变量（环境变量）：$PATH</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%9F%A5%E8%AF%A2"><span class="toc-number">4.4.</span> <span class="toc-text">文件内容查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E6%97%B6%E9%97%B4%E6%88%96%E5%88%9B%E5%BB%BA%E6%96%B0%E6%96%87%E4%BB%B6%EF%BC%9Atouch"><span class="toc-number">4.5.</span> <span class="toc-text">修改文件时间或创建新文件：touch</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#touch"><span class="toc-number">4.5.1.</span> <span class="toc-text">touch</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8-1"><span class="toc-number">4.5.1.1.</span> <span class="toc-text">作用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%9A%84%E9%BB%98%E8%AE%A4%E6%9D%83%E9%99%90%E4%B8%8E%E9%9A%90%E8%97%8F%E6%9D%83%E9%99%90"><span class="toc-number">4.6.</span> <span class="toc-text">文件与目录的默认权限与隐藏权限</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E9%BB%98%E8%AE%A4%E6%9D%83%E9%99%90%EF%BC%9Aumask"><span class="toc-number">4.6.1.</span> <span class="toc-text">文件默认权限：umask</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E9%9A%90%E8%97%8F%E6%9D%83%E9%99%90"><span class="toc-number">4.6.2.</span> <span class="toc-text">文件隐藏权限</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7"><span class="toc-number">4.6.2.1.</span> <span class="toc-text">查看文件属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7"><span class="toc-number">4.6.2.2.</span> <span class="toc-text">修改文件属性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%89%B9%E6%AE%8A%E6%9D%83%E9%99%90%EF%BC%9A-SUID-SGID-SBIT"><span class="toc-number">4.7.</span> <span class="toc-text">文件特殊权限： SUID, SGID, SBIT</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SUID-SGID-SBIT%E6%9D%83%E9%99%90%E8%AE%BE%E7%BD%AE"><span class="toc-number">4.7.1.</span> <span class="toc-text">SUID&#x2F;SGID&#x2F;SBIT权限设置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E6%95%B0%E5%80%BC%E8%A1%A8%E7%A4%BA"><span class="toc-number">4.7.1.1.</span> <span class="toc-text">权限数值表示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">4.7.1.2.</span> <span class="toc-text">示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%EF%BC%9A-locate"><span class="toc-number">4.8.</span> <span class="toc-text">文件查找： locate</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%EF%BC%9A-file"><span class="toc-number">4.9.</span> <span class="toc-text">查看文件类型： file</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E4%B8%8E%E6%96%87%E4%BB%B6%E7%9A%84%E6%90%9C%E7%B4%A2"><span class="toc-number">4.10.</span> <span class="toc-text">指令与文件的搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%96%87%E4%BB%B6%E5%90%8D%E7%9A%84%E6%90%9C%E7%B4%A2"><span class="toc-number">4.10.1.</span> <span class="toc-text">指令文件名的搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%96%87%E4%BB%B6%E5%90%8D%E6%90%9C%E7%B4%A2"><span class="toc-number">4.10.2.</span> <span class="toc-text">文件文件名搜索</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81Linux%E7%A3%81%E7%9B%98%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">五、Linux磁盘与文件系统管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Ext2%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-inode"><span class="toc-number">5.1.</span> <span class="toc-text">Ext2文件系统(inode)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Data-Block%EF%BC%88%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9D%97%EF%BC%89"><span class="toc-number">5.2.</span> <span class="toc-text">Data Block（数据区块）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#inode-table-%EF%BC%88inode-%E8%A1%A8%E6%A0%BC%EF%BC%89"><span class="toc-number">5.3.</span> <span class="toc-text">inode table （inode 表格）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Superblock%EF%BC%88%E8%B6%85%E7%BA%A7%E5%8C%BA%E5%9D%97%EF%BC%89"><span class="toc-number">5.4.</span> <span class="toc-text">Superblock（超级区块）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Filesystem-Description-%EF%BC%88%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8F%8F%E8%BF%B0%E8%AF%B4%E6%98%8E%EF%BC%89"><span class="toc-number">5.5.</span> <span class="toc-text">Filesystem Description （文件系统描述说明）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#block-bitmap-%EF%BC%88%E5%8C%BA%E5%9D%97%E5%AF%B9%E7%85%A7%E8%A1%A8%EF%BC%89"><span class="toc-number">5.6.</span> <span class="toc-text">block bitmap （区块对照表）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#inode-bitmap-%EF%BC%88inode-%E5%AF%B9%E7%85%A7%E8%A1%A8%EF%BC%89"><span class="toc-number">5.7.</span> <span class="toc-text">inode bitmap （inode 对照表）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8E%E7%9B%AE%E5%BD%95%E6%A0%91%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">5.8.</span> <span class="toc-text">文件系统与目录树的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95"><span class="toc-number">5.8.1.</span> <span class="toc-text">目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E6%A0%91%E8%AF%BB%E5%8F%96"><span class="toc-number">5.8.2.</span> <span class="toc-text">目录树读取</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXT2-EXT3-EXT4-%E6%96%87%E4%BB%B6%E7%9A%84%E5%AD%98%E5%8F%96%E4%B8%8E%E6%97%A5%E5%BF%97%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">5.9.</span> <span class="toc-text">EXT2&#x2F;EXT3&#x2F;EXT4 文件的存取与日志式文件系统的功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%8D%E4%B8%80%E8%87%B4%EF%BC%88Inconsistent%EF%BC%89%E7%8A%B6%E6%80%81"><span class="toc-number">5.9.1.</span> <span class="toc-text">数据的不一致（Inconsistent）状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%88Journaling-filesystem%EF%BC%89"><span class="toc-number">5.9.2.</span> <span class="toc-text">日志式文件系统（Journaling filesystem）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C"><span class="toc-number">5.10.</span> <span class="toc-text">Linux 文件系统的运行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%82%E8%BD%BD%E7%82%B9%E7%9A%84%E6%84%8F%E4%B9%89%EF%BC%88mount-point%EF%BC%89"><span class="toc-number">5.11.</span> <span class="toc-text">挂载点的意义（mount point）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96-Linux-%E6%94%AF%E6%8C%81%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%8E-VFS"><span class="toc-number">5.12.</span> <span class="toc-text">其他 Linux 支持的文件系统与 VFS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-VFS-%EF%BC%88Virtual-Filesystem-Switch%EF%BC%89"><span class="toc-number">5.12.1.</span> <span class="toc-text">Linux VFS （Virtual Filesystem Switch）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XFS-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B"><span class="toc-number">5.12.2.</span> <span class="toc-text">XFS 文件系统简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#XFS-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-number">5.12.2.1.</span> <span class="toc-text">XFS 文件系统的配置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C"><span class="toc-number">5.13.</span> <span class="toc-text">文件系统的简单操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%9A%84%E5%AE%B9%E9%87%8F"><span class="toc-number">5.13.1.</span> <span class="toc-text">磁盘与目录的容量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#df"><span class="toc-number">5.13.1.1.</span> <span class="toc-text">df</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#du"><span class="toc-number">5.13.1.2.</span> <span class="toc-text">du</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BD%93%E9%93%BE%E6%8E%A5%E4%B8%8E%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5%EF%BC%9A-ln"><span class="toc-number">5.14.</span> <span class="toc-text">实体链接与符号链接： ln</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%9A%84%E5%88%86%E5%8C%BA%E3%80%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E3%80%81%E6%A3%80%E9%AA%8C%E4%B8%8E%E6%8C%82%E8%BD%BD"><span class="toc-number">5.15.</span> <span class="toc-text">磁盘的分区、格式化、检验与挂载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E7%8A%B6%E6%80%81"><span class="toc-number">5.15.1.</span> <span class="toc-text">观察磁盘分区状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lsblk-%EF%BC%88list-block-device%EF%BC%89%E5%88%97%E5%87%BA%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%9A%84%E6%89%80%E6%9C%89%E7%A3%81%E7%9B%98%E5%88%97%E8%A1%A8"><span class="toc-number">5.15.1.1.</span> <span class="toc-text">lsblk （list block device）列出系统上的所有磁盘列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#blkid-%E5%88%97%E5%87%BA%E8%AE%BE%E5%A4%87%E7%9A%84-UUID-%E7%AD%89%E5%8F%82%E6%95%B0"><span class="toc-number">5.15.1.2.</span> <span class="toc-text">blkid 列出设备的 UUID 等参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#parted-%E5%88%97%E5%87%BA%E7%A3%81%E7%9B%98%E7%9A%84%E5%88%86%E5%8C%BA%E8%A1%A8%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%88%86%E5%8C%BA%E4%BF%A1%E6%81%AF"><span class="toc-number">5.15.1.3.</span> <span class="toc-text">parted 列出磁盘的分区表类型与分区信息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%EF%BC%9A-gdisk-fdisk"><span class="toc-number">5.15.2.</span> <span class="toc-text">磁盘分区： gdisk&#x2F;fdisk</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gdisk"><span class="toc-number">5.15.2.1.</span> <span class="toc-text">gdisk</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#partprobe-%E6%9B%B4%E6%96%B0-Linux-%E6%A0%B8%E5%BF%83%E7%9A%84%E5%88%86%E5%8C%BA%E8%A1%A8%E4%BF%A1%E6%81%AF"><span class="toc-number">5.15.2.1.1.</span> <span class="toc-text">partprobe 更新 Linux 核心的分区表信息</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fdisk"><span class="toc-number">5.15.2.2.</span> <span class="toc-text">fdisk</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#parted%E5%88%86%E5%8C%BA"><span class="toc-number">5.15.2.3.</span> <span class="toc-text">parted分区</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F%E5%8C%96%EF%BC%88%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%89"><span class="toc-number">5.15.3.</span> <span class="toc-text">磁盘格式化（创建文件系统）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A3%80%E9%AA%8C"><span class="toc-number">5.15.4.</span> <span class="toc-text">文件系统检验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#xfs-repair-%E5%A4%84%E7%90%86-XFS-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.15.4.1.</span> <span class="toc-text">xfs_repair 处理 XFS 文件系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fsck-ext4-%E5%A4%84%E7%90%86-EXT4-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.15.4.2.</span> <span class="toc-text">fsck.ext4 处理 EXT4 文件系统</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%8C%82%E8%BD%BD%E4%B8%8E%E5%8D%B8%E8%BD%BD"><span class="toc-number">5.15.5.</span> <span class="toc-text">文件系统挂载与卸载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8C%82%E8%BD%BD%EF%BC%9Amount"><span class="toc-number">5.15.5.1.</span> <span class="toc-text">文件挂载：mount</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%B8%E8%BD%BD-umount"><span class="toc-number">5.15.5.2.</span> <span class="toc-text">卸载:umount</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%8F%82%E6%95%B0%E4%BF%AE%E8%AE%A2"><span class="toc-number">5.15.6.</span> <span class="toc-text">磁盘&#x2F;文件系统参数修订</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E6%8C%82%E8%BD%BD"><span class="toc-number">5.15.7.</span> <span class="toc-text">设置开机挂载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E6%9C%BA%E6%8C%82%E8%BD%BD-etc-fstab-%E5%8F%8A-etc-mtab"><span class="toc-number">5.15.7.1.</span> <span class="toc-text">开机挂载 &#x2F;etc&#x2F;fstab 及 &#x2F;etc&#x2F;mtab</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E8%AE%BE%E5%A4%87loop%E6%8C%82%E8%BD%BD%EF%BC%88%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6%E4%B8%8D%E7%83%A7%E5%BD%95%E5%B0%B1%E6%8C%82%E8%BD%BD%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="toc-number">5.15.7.2.</span> <span class="toc-text">特殊设备loop挂载（镜像文件不烧录就挂载使用）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%82%E8%BD%BD%E5%85%89%E7%9B%98-DVD%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6"><span class="toc-number">5.15.7.2.1.</span> <span class="toc-text">挂载光盘&#x2F;DVD镜像文件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%A4%A7%E6%96%87%E4%BB%B6%E4%BB%A5%E5%88%B6%E4%BD%9C-loop-%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6"><span class="toc-number">5.15.7.3.</span> <span class="toc-text">创建大文件以制作 loop 设备文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4%EF%BC%88swap%EF%BC%89%E5%88%9B%E5%BB%BA"><span class="toc-number">5.15.8.</span> <span class="toc-text">内存交换空间（swap）创建</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8E%8B%E7%BC%A9%E3%80%81%E6%89%93%E5%8C%85%E4%B8%8E%E5%A4%87%E4%BB%BD"><span class="toc-number">6.</span> <span class="toc-text">六、文件与文件系统的压缩、打包与备份</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8E%8B%E7%BC%A9%E6%8C%87%E4%BB%A4"><span class="toc-number">6.1.</span> <span class="toc-text">常见的压缩指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#gzip-zcat-zmore-zless-zgrep"><span class="toc-number">6.1.1.</span> <span class="toc-text">gzip, zcat&#x2F;zmore&#x2F;zless&#x2F;zgrep</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bzip2-bzcat-bzmore-bzless-bzgrep"><span class="toc-number">6.1.2.</span> <span class="toc-text">bzip2, bzcat&#x2F;bzmore&#x2F;bzless&#x2F;bzgrep</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#xz-xzcat-xzmore-xzless-xzgrep"><span class="toc-number">6.1.3.</span> <span class="toc-text">xz, xzcat&#x2F;xzmore&#x2F;xzless&#x2F;xzgrep</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%8C%85%E6%8C%87%E4%BB%A4%EF%BC%9Atar"><span class="toc-number">6.2.</span> <span class="toc-text">打包指令：tar</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%90%8D%E7%A7%B0%EF%BC%9A-tarfile%EF%BC%8C-tarball"><span class="toc-number">6.2.1.</span> <span class="toc-text">基本名称： tarfile， tarball</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E5%BA%94%E7%94%A8%EF%BC%9A%E5%88%A9%E7%94%A8%E7%AE%A1%E7%BA%BF%E5%91%BD%E4%BB%A4%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">6.2.2.</span> <span class="toc-text">特殊应用：利用管线命令与数据流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%8E%8B%E7%BC%A9%E5%90%8E%E7%9A%84-SELinux-%E8%AF%BE%E9%A2%98"><span class="toc-number">6.2.3.</span> <span class="toc-text">解压缩后的 SELinux 课题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XFS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%87%E4%BB%BD%E4%B8%8E%E8%BF%98%E5%8E%9F"><span class="toc-number">6.3.</span> <span class="toc-text">XFS文件系统的备份与还原</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#XFS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%A4%87%E4%BB%BD-xfsdump"><span class="toc-number">6.3.1.</span> <span class="toc-text">XFS文件系统备份 xfsdump</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8-xfsdump-%E5%A4%87%E4%BB%BD%E5%AE%8C%E6%95%B4%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">6.3.1.1.</span> <span class="toc-text">用 xfsdump 备份完整的文件系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8-xfsdump-%E8%BF%9B%E8%A1%8C%E7%B4%AF%E7%A7%AF%E5%A4%87%E4%BB%BD%EF%BC%88Incremental-backups%EF%BC%89"><span class="toc-number">6.3.1.2.</span> <span class="toc-text">用 xfsdump 进行累积备份（Incremental backups）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XFS-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%BF%98%E5%8E%9F-xfsrestore"><span class="toc-number">6.3.2.</span> <span class="toc-text">XFS 文件系统还原 xfsrestore</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8-xfsrestore-%E8%A7%82%E5%AF%9F-xfsdump-%E5%90%8E%E7%9A%84%E5%A4%87%E4%BB%BD%E6%95%B0%E6%8D%AE%E5%86%85%E5%AE%B9"><span class="toc-number">6.3.2.1.</span> <span class="toc-text">用 xfsrestore 观察 xfsdump 后的备份数据内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%BF%98%E5%8E%9F-level-0-%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">6.3.2.2.</span> <span class="toc-text">简单还原 level 0 的文件系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%98%E5%8E%9F%E7%B4%AF%E7%A7%AF%E5%A4%87%E4%BB%BD%E6%95%B0%E6%8D%AE"><span class="toc-number">6.3.2.3.</span> <span class="toc-text">还原累积备份数据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%89%E7%9B%98%E5%86%99%E5%85%A5%E5%B7%A5%E5%85%B7"><span class="toc-number">6.4.</span> <span class="toc-text">光盘写入工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mkisofs%EF%BC%9A%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6"><span class="toc-number">6.4.1.</span> <span class="toc-text">mkisofs：创建镜像文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cdrecord%EF%BC%9A%E5%85%89%E7%9B%98%E7%83%A7%E5%BD%95%E5%B7%A5%E5%85%B7"><span class="toc-number">6.4.2.</span> <span class="toc-text">cdrecord：光盘烧录工具</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8E%8B%E7%BC%A9%E4%B8%8E%E5%A4%87%E4%BB%BD%E5%91%BD%E4%BB%A4"><span class="toc-number">6.5.</span> <span class="toc-text">其他常见的压缩与备份命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dd"><span class="toc-number">6.5.1.</span> <span class="toc-text">dd</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cpio"><span class="toc-number">6.5.2.</span> <span class="toc-text">cpio</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">6.5.2.1.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%80%89%E9%A1%B9%E5%92%8C%E6%93%8D%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.5.2.2.</span> <span class="toc-text">常见选项和操作模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E9%80%89%E9%A1%B9"><span class="toc-number">6.5.2.3.</span> <span class="toc-text">其他选项</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81BASH"><span class="toc-number">7.</span> <span class="toc-text">七、BASH</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-number">7.1.</span> <span class="toc-text">常用快捷键</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">7.2.</span> <span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%8F%96%E7%94%A8%E4%B8%8E%E8%AE%BE%E7%BD%AE%EF%BC%9Aecho%EF%BC%8C%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE%E8%A7%84%E5%88%99%EF%BC%9Aunset"><span class="toc-number">7.2.1.</span> <span class="toc-text">变量的取用与设置：echo，变量设置规则：unset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">7.2.2.</span> <span class="toc-text">环境变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E9%94%AE%E7%9B%98%E8%AF%BB%E5%8F%96%E3%80%81%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AE%A3%E5%91%8A"><span class="toc-number">7.2.3.</span> <span class="toc-text">变量键盘读取、数组与宣告</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%86%85%E5%AE%B9%E7%9A%84%E5%88%A0%E9%99%A4%E3%80%81%E5%8F%96%E4%BB%A3%E4%B8%8E%E6%9B%BF%E6%8D%A2"><span class="toc-number">7.3.</span> <span class="toc-text">变量内容的删除、取代与替换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%A0%E9%99%A4%E5%8F%98%E9%87%8F%E5%86%85%E5%AE%B9%E7%9A%84%E5%89%8D%E7%BC%80%E6%88%96%E5%90%8E%E7%BC%80"><span class="toc-number">7.3.1.</span> <span class="toc-text">1. 删除变量内容的前缀或后缀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9B%BF%E6%8D%A2%E5%8F%98%E9%87%8F%E5%86%85%E5%AE%B9"><span class="toc-number">7.3.2.</span> <span class="toc-text">2. 替换变量内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E6%B5%8B%E8%AF%95%E5%92%8C%E5%86%85%E5%AE%B9%E6%9B%BF%E6%8D%A2"><span class="toc-number">7.3.3.</span> <span class="toc-text">3、变量的测试和内容替换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E5%88%AB%E5%90%8D%E8%AE%BE%E7%BD%AE%EF%BC%9Aalias%E3%80%81unalias"><span class="toc-number">7.4.</span> <span class="toc-text">命令别名设置：alias、unalias</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/15/JAVA%E9%9D%A2%E8%AF%95Spring%E7%AF%87/" title="JAVA面试八股文Spring篇">JAVA面试八股文Spring篇</a><time datetime="2024-09-16T01:52:32.000Z" title="Created 2024-09-15 21:52:32">2024-09-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/15/JAVA%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/" title="JAVA面试八股文基础篇">JAVA面试八股文基础篇</a><time datetime="2024-09-16T01:52:32.000Z" title="Created 2024-09-15 21:52:32">2024-09-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/10/%E9%B8%9F%E5%93%A5%E7%9A%84Linux%E7%A7%81%E6%88%BF%E8%8F%9C%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" title="鸟哥的Linux实战阅读笔记">鸟哥的Linux实战阅读笔记</a><time datetime="2024-08-10T21:46:35.000Z" title="Created 2024-08-10 17:46:35">2024-08-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/05/Linux%E5%85%A5%E9%97%A8/" title="Linux入门">Linux入门</a><time datetime="2024-08-05T18:33:56.000Z" title="Created 2024-08-05 14:33:56">2024-08-05</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/30/MiniKube%E5%AE%9E%E6%88%98/" title="Kubernetes实战">Kubernetes实战</a><time datetime="2024-07-30T20:03:35.000Z" title="Created 2024-07-30 16:03:35">2024-07-30</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2024 By DrJuly2333</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async src="/js/title.js"></script><script defer src="https://rmt.dogedoge.com/fetch/~/source/jsdelivr/npm/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="https://cdn.jsdelivr.net/gh/sirxemic/jquery.ripples/dist/jquery.ripples.js"></script><script defer data-pjax src="/js/ripples.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>